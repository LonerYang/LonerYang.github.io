{"meta":{"title":"Yang","subtitle":null,"description":null,"author":"Yang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-23T02:57:09.000Z","updated":"2019-05-23T02:57:09.484Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"WebSocket","slug":"2019-05-22-WebSocket","date":"2019-05-22T01:07:00.000Z","updated":"2019-05-23T04:46:11.554Z","comments":true,"path":"2019/05/22/2019-05-22-WebSocket/","link":"","permalink":"http://yoursite.com/2019/05/22/2019-05-22-WebSocket/","excerpt":"","text":"一、WebSocket是什么1.WebSocket对比HTTPWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 2.WebSocket的连接数据包JavaScript中使用下面代码创建WebSocket对象，第一个参数 url（如果是使用https创建连接了，这里就使用wss）, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。 1var Socket = new WebSocket(ws://url:port, [protocol] ); 请求时请求头会多点东西 12345678910Connection: Upgrade #表示这次Http连接需要升级Host: localhost:8080Origin: http://localhost:8080Pragma: no-cache#协议扩展， 某类协议可能支持多个扩展，通过它可以实现协议增强; Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits#一个 Base64 encode 的值，这个是浏览器随机生成的，验证作用Sec-WebSocket-Key: nbZWpYwTT+C0pMwypDFbIA== Sec-WebSocket-Version: 13 #websocket的版本Upgrade: websocket #需要升级为websocket连接 然后服务器会返回下列东西还要响应码101，表示已经接受到请求， 成功建立Websocket 1234567Connection: upgrade #告诉客户端已经升级了Date: Wed, 22 May 2019 01:10:19 GMT#经过服务器确认，根据请求时传来的Sec-WebSocket-Key加密后生成的，#客户端根据的请求时随机生产的key加密后对比是否一致来表示是否验证成功Sec-WebSocket-Accept: +ORSis0LYkT05V6n5h+I3Elt+0I=Sec-WebSocket-Extensions: permessage-deflate;client_max_window_bits=15Upgrade: websocket #告诉客户端升级为websocket协议 3.JavaScript使用WebSocket以下是WebSocket对象的属性 属性 描述 Socket.readyState 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount 只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 以下是 WebSocket 对象的相关事件 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 以下是 WebSocket 对象的相关方法 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 二、实现聊天室1.SpringBoot中使用WebSocket 注解 作用 @ServerEndpoint(“/chat”)【类】 指定该类为WebSocket服务端 需指定端点的访问路径 @OnOpen【方法】 连接成功后调用的方法 @OnMessage【方法】 接受到客户端发送的消息调用的方法 @OnClose【方法】 关闭连接调用的方法 @OnError【方法】 异常调用的方法 类 作用 org.springframework.web.socket.server.standard.ServerEndpointExporter 用于扫描和注册所有携带ServerEndPoint注解的实例（若部署到外部容器 则无需提供此类。） javax.websocket.Session 客户端成功连接到服务器后通过该类产生一个会话对象，可以通过该对象发送消息给客户端 2.代码实现 服务端代码 1234567891011121314@Configurationpublic class WebSocketConfig &#123; /** * 用于扫描和注册所有携带ServerEndPoint注解的实例。 * &lt;/p&gt; * PS:若部署到外部容器 则无需提供此类。 */ @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Component@ServerEndpoint(\"/chat\")public class WebSocketChatServer &#123; /** * 全部在线会话 PS: 基于场景考虑 这里使用线程安全的Map存储会话对象。 * Session就是客户端与服务器端的会话对象 */ private static Map&lt;String, Session&gt; onlineSessions = new ConcurrentHashMap&lt;&gt;(); /** * 当客户端打开连接：1.添加会话对象 2.更新在线人数 */ @OnOpen public void onOpen(Session session) &#123; onlineSessions.put(session.getId(), session); sendMessageToAll(Message.jsonStr(Message.ENTER, \"\", \"\", onlineSessions.size())); &#125; /** * 当客户端发送消息：1.获取它的用户名和消息 2.发送消息给所有人 * &lt;p&gt; * PS: 这里约定传递的消息为JSON字符串 方便传递更多参数！ */ @OnMessage public void onMessage(Session session, String jsonStr) &#123; Message message = JSON.parseObject(jsonStr, Message.class); sendMessageToAll(Message.jsonStr(Message.SPEAK, message.getUsername(), message.getMsg(), onlineSessions.size())); &#125; /** * 当关闭连接：1.移除会话对象 2.更新在线人数 */ @OnClose public void onClose(Session session) &#123; onlineSessions.remove(session.getId()); sendMessageToAll(Message.jsonStr(Message.QUIT, \"\", \"\", onlineSessions.size())); &#125; /** * 当通信发生异常：打印错误日志 */ @OnError public void onError(Session session, Throwable error) &#123; error.printStackTrace(); &#125; /** * 公共方法：发送信息给所有人 */ private static void sendMessageToAll(String msg) &#123; onlineSessions.forEach((id, session) -&gt; &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526@Datapublic class Message &#123; public static final String ENTER = \"ENTER\"; public static final String SPEAK = \"SPEAK\"; public static final String QUIT = \"QUIT\"; private String type;//消息类型 private String username; //发送人 private String msg; //发送消息 private int onlineCount; //在线用户数 public static String jsonStr(String type, String username, String msg, int onlineTotal) &#123; return JSON.toJSONString(new Message(type, username, msg, onlineTotal)); &#125; public Message(String type, String username, String msg, int onlineCount) &#123; this.type = type; this.username = username; this.msg = msg; this.onlineCount = onlineCount; &#125;&#125; 123456789101112131415161718192021222324252627282930@SpringBootApplication@RestControllerpublic class WebsocketApplication &#123; /** * 登陆界面 */ @GetMapping(\"/\") public ModelAndView login() &#123; return new ModelAndView(\"/login\"); &#125; /** * 聊天界面 */ @GetMapping(\"/index\") public ModelAndView index(String username, String password, HttpServletRequest request) throws UnknownHostException &#123; if (StringUtils.isEmpty(username)) &#123; username = \"匿名用户\"; &#125; ModelAndView mav = new ModelAndView(\"chat\"); mav.addObject(\"username\", username); mav.addObject(\"webSocketUrl\", \"ws://\"+ InetAddress.getLocalHost().getHostAddress()+\":\"+request.getServerPort()+request.getContextPath()+\"/chat\"); return mav; &#125; public static void main(String[] args) &#123; SpringApplication.run(WebsocketApplication.class, args); &#125;&#125; 客户端核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function getWebSocket() &#123; /** * 只要创建出来就会连接上指定地址(想下ServerSocket和Socket聊天室怎么实现的) * URL开头表示WebSocket协议 中间是域名端口 结尾是服务端映射地址 */ var webSocket = new WebSocket('ws://localhost:8080/chat'); /** * 当服务端打开连接 */ webSocket.onopen = function(event) &#123; console.log(\"WebSocket打开连接\"); &#125; /** * 当服务端发来消息：1.广播消息 2.更新在线人数 */ webSocket.onmessage = function(event) &#123; console.log(\"WebSocket收到消息：%c\" + event.data, \"color:green\"); //获取服务端消息 || 逻辑或运算会有短路功能，如果前面为true，后面就不执行， //如果为false就会执行后面 var message = JSON.parse(event.data) || &#123;&#125;; var $chatContent = $(\"#chat-content\"); //如果是聊天的消息就把用户名和信息打印出来 if (message.type === \"SPEAK\") &#123; $chatContent.append(message.username + \":\" + message.msg + \"&amp;#10;\"); &#125; //否则只需要更新在线人数 $(\"#chat-num\").html(message.onlineCount); &#125; /** * 关闭连接 */ webSocket.onclose = function(event) &#123; console.log(\"WebSocket关闭连接\"); &#125; /** * 通信失败 */ webSocket.onerror = function(event) &#123; console.log(\"WebSocket发生异常\"); &#125; return webSocket;&#125;var webSocket = getWebSocket();/** * 通过WebSocket对象发送消息给服务端 */$(\"#send\").click(function() &#123; if($(\"#message\").val()) &#123; //将stringify中的值转成json格式的字符串 webSocket.send(JSON.stringify(&#123;username: $('#username').text(), msg: $(\"#message\").val()&#125;)); //发送完清空输入框的内容 $(\"#message\").val(null); &#125;&#125;)/** * 清屏 */$(\"#clear\").click(function() &#123; $(\"#chat-content\").empty();&#125;)/** * 使用ENTER发送消息 */document.onkeydown = function (event) &#123; var e = event || window.event || arguments.callee.caller.arguments[0]; e.keyCode === 13 &amp;&amp; $(\"#send\").click();&#125;; 最终效果 三、项目中使用WebSocket之前在做项目时有个需求就是用户可以查看当前在线的医生，并可以选择医生进行咨询 这里记录下来防止下次再用到同样的业务逻辑 思路： 在医生角色客户端有个列表页，显示与每个用户交流的列表，只要医生进了列表页就使用WebSocket连接上了服务器，并把该医生连接信息加入到userSessionManager中的doctorSocketSessionMap中（key为doctorId，value为WebSocket会话 session）。 用户点击咨询页面，就会查询数据库中的所有医生，并将所有的医生doctorList对比userSessionManager中的doctorSocketSessionMap中的所有数据，只要在doctorSocketSessionMap中有的就设置为在线状态（医生有个status字段）没有的默认status就是0也就是离线状态，页面上保存了医生的id，当某个用户点击咨询那个医生时，这时候用户与服务器建立webSocket连接，只要连接上就把他加入到userSessionManager中的userSocketSessionMap （key为userId，value为会话session）中。当用户发送消息给某个医生时，消息上包括了这个消息是谁发的(userId)和要发给谁(doctorId)，服务器接收到该消息就会去判断当前用户是否为用户然后根据要发给谁也就是doctorId去doctorSocketSessionMap中查出WebSocket的session会话对象，使用该session发送消息到客户端，此时医生客户端就会收到一条信息，医生点开列表页，会有一条信息提醒，点开该信息提醒就会出现对话框，就能对话了。医生发消息也是这样的一个逻辑 注意：医生不能主动找用户聊天，必须是用户点击咨询某个医生然后发送消息给该医生时，医生列表就会得到一条消息推送，医生点开消息推送，就能与用户聊天了 总结：WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信通道。 WebSocket是双向的：使用WebSocket客户端或服务器可以发起消息发送 WebSocket是全双工的：客户端和服务器通信是相互独立的 单个TCP连接：初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信 与HTTP相比，WebSocket消息数据交换要轻的多 浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 WebSocket协议能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}],"author":"Yang"},{"title":"线程池","slug":"2019-05-18-线程池","date":"2019-05-18T07:54:00.000Z","updated":"2019-05-23T04:45:49.025Z","comments":true,"path":"2019/05/18/2019-05-18-线程池/","link":"","permalink":"http://yoursite.com/2019/05/18/2019-05-18-线程池/","excerpt":"","text":"一、ExecutorExecutor是所有线程池的接口，定义了一个用于执行Runnable任务的execute方法，它没有实现类只有另一个重要的子接口ExecutorService，线程池中方法都是实现该子接口而来的。 自己实现Executor接口 12345678910111213public class T01_MyExecutor implements Executor &#123; public static void main(String[] args) &#123; new T01_MyExecutor().execute(() -&gt; &#123; System.out.println(\"测试 Executor\"); &#125;); &#125; @Override public void execute(Runnable command) &#123; new Thread(command).start(); &#125;&#125; 二、Runnable和Callable线程执行的都是任务，分为Runnable和Callable的任务 首先Callable的任务是不能直接传给Thread的构造器的，需要通过FutureTask类（Runnable的子类）包装下再通过new Thread()启动该Callable的任务，Callable的任务是有返回值的，返回值通过FutureTask的阻塞式get()方法获取。且异常可以throws出去，可以不在内部处理。 1234567891011121314public class T06_Future &#123; public static void main(String[] args) throws Exception &#123; //使用线程执行callable的任务 // 创建一个Callable的任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(() -&gt; &#123; Thread.sleep(500); return 1000; &#125;); // new Callable() &#123;Integer call()&#125; new Thread(task).start(); //get()阻塞式的；会等待task任务执行完，这里才会获取任务返回的值 System.out.println(task.get()); &#125;&#125; Runnable的任务就可以直接通过匿名内部类来实现Runnable接口并交给Thread，但是异常不能throws，只能通过内部try…catch 12345678new Thread(() -&gt; &#123; try &#123; Thread.sleep(500); System.out.println(\"test\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start(); 三、线程池线程池的基本API Running：线程的状态，表示正在运行 pool size：线程池中的线程的数量 active threads：正在工作的线程数 queued tasks：在队列等待执行的任务（传入的任务太多，会将没有得到执行的任务放入由线程池维护的一个队列中进行排队，等什么时候线程池有空闲线程来这里调用任务） completed tasks：成功执行的任务数量（任务执行完会将执行完的任务放入由线程池维护的一个队列中）一个线程池维护两个队列 shutdown()：等待所有的任务执行完关闭线程池 shutdownNow()：不管线程池中的任务有没有执行完直接关闭线程池 isTerminated()：线程池中的所有任务是否都执行完了 isShutdown()：线程池是否正在关闭的过程中，并不是现在已经关了 12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) throws InterruptedException &#123; // 创建具有5个 线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(5); //执行6次execute方法，丢入6个任务进去，会由线程池中的线程来执行任务（也就是这里的run方法） for (int i = 0; i &lt; 6; i++) &#123; threadPool.execute(() -&gt; &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125;); &#125; /** * [Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0] */ System.out.println(threadPool); threadPool.shutdown(); // threadPool.shutdownNow(); System.out.println(threadPool.isTerminated()); System.out.println(threadPool.isShutdown()); System.out.println(threadPool); //主线程等待5秒，让所有的任务都执行完 TimeUnit.SECONDS.sleep(5); System.out.println(threadPool.isTerminated()); System.out.println(threadPool.isShutdown()); System.out.println(threadPool); &#125; 1、FixedThreadPoolFixedThreadPool是指定固定大小的线程池，下面通过计算1到200000的质数个数来比较单线程和多线程的效率 ​ 单线程2468毫秒，通过5个线程的线程池计算得出717毫秒（每个人的电脑不同，但是还是可以看出多线程计算的能充分发挥出CPU的能力） Executors是一个工具类可以用来创建线程池 submit()是往线程池中提交一个Callable的任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class T07_ParallelComputing &#123; public static void main(String[] args) throws Exception &#123; //单线程执行 long start = System.currentTimeMillis(); List&lt;Integer&gt; result = getPrime(1, 200000); long end = System.currentTimeMillis(); System.out.println(end - start); //使用线程池(CPU几核最少就创建几个线程的线程池，防止浪费CPU的核数) ExecutorService service = Executors.newFixedThreadPool(4); //这里不平均分是因为自然数越大算出来的质数时间就越慢，所以越到后面就算越少的数 MyTask t1 = new MyTask(1, 80000); MyTask t2 = new MyTask(80001, 130000); MyTask t3 = new MyTask(130001, 170000); MyTask t4 = new MyTask(170001, 200000); Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(t1); Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(t2); Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(t3); Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(t4); start = System.currentTimeMillis(); f1.get(); f2.get(); f3.get(); f4.get(); end = System.currentTimeMillis(); System.out.println(end - start); service.shutdown(); &#125; static class MyTask implements Callable&lt;List&lt;Integer&gt;&gt; &#123; int start; int end; public MyTask(int start, int end) &#123; super(); this.start = start; this.end = end; &#125; @Override public List&lt;Integer&gt; call() throws Exception &#123; return getPrime(start, end); &#125; &#125; /** * 给一个数判断是否为质数 * @param num * @return */ static boolean isPrime(int num) &#123; for (int i = 2; i &lt; num / 2; i++) &#123; if (num % i == 0) &#123; return false; &#125; &#125; return true; &#125; /** * 给定一个范围，返回该范围内的所有质数 * @param start * @param end * @return */ static List&lt;Integer&gt; getPrime(int start, int end) &#123; List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); for (int i = start; i &lt;= end; i++) &#123; if (isPrime(i)) &#123; primes.add(i); &#125; &#125; return primes; &#125;&#125; 2、CachedThreadPoolCachedThreadPool是弹性的 不能指定容量的线程池，来一个任务线程池中没有空闲的线程就会创建一个线程来执行，有空闲的线程就由空闲的线程去执行该任务，线程池中线程最多数量是CPU能支撑最多的数量 一个线程默认60秒不使用系统自动销毁 下面这个例子测试CachedThreadPool中的线程是否在60秒内会销毁 12345678910111213141516171819202122232425262728293031public class T08_CachedThreadPool &#123; public static void main(String[] args) throws Exception &#123; ExecutorService service = Executors.newCachedThreadPool(); //java.util.concurrent.ThreadPoolExecutor@677327b6[Running, pool size = 0, // active threads = 0, queued tasks = 0, completed tasks = 0] System.out.println(service); for (int i = 0; i &lt; 2; i++) &#123; service.execute(() -&gt; &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; //java.util.concurrent.ThreadPoolExecutor@677327b6[Running, pool size = 2, // active threads = 2, queued tasks = 0, completed tasks = 0] System.out.println(service); //等待80秒再查看线程池 TimeUnit.SECONDS.sleep(80); //80秒后线程池中的线程已经自动销毁了 //java.util.concurrent.ThreadPoolExecutor@677327b6[Running, pool size = 0, //active threads = 0, queued tasks = 0, completed tasks = 2] System.out.println(service); service.shutdown(); &#125;&#125; 3、SinglePool Single这个线程池中只有一个线程 优点：任务是按顺序执行的 12345678910111213public class T09_SinglePool &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 6; i++) &#123; final int j = i; service.execute(() -&gt; &#123; System.out.println(j + \"---\" + Thread.currentThread().getName()); &#125;); &#125; service.shutdown(); &#125;&#125; 4、ScheduledThreadPoolScheduledThreadPool执行定时任务的线程池，来一个任务如果第一个线程空闲就会由空闲的线程去执行该任务不会又创建一个新线程去执行 pram1:任务 ; pram2:任务延迟多久启动; parm3:任务间隔多久重复执行; parm4:时间单位 123456789101112131415161718public class T10_ScheduledThreadPool &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newScheduledThreadPool(4); service.scheduleAtFixedRate(() -&gt; &#123; try &#123; //重复执行的优先比较高：启动一个任务，该任务等待1000毫秒，等待到200毫秒时，又要执行该任务， //此时会使用线程池中的线程执行， //如果没有就依次等待 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125;, 0, 200, TimeUnit.MILLISECONDS); service.shutdown(); &#125;&#125; 5、WorkStealingPoolWorkStealingPool线程池中某个线程执行完了自己的任务会主动去拿别人没有执行的任务来执行（之前都是通过CPU的调度来决定哪个线程执行哪个任务） WorkStealingPool是精灵线程(后台线程，守护线程)，使用ForkJoinPool（后面会介绍）实现的 WorkStealingPool根据当前操作系统的CPU有几个核就会创建几个线程 12345678910111213141516171819202122232425262728293031323334353637383940public class T11_WorkStealingPool &#123; public static void main(String[] args) throws IOException &#123; ExecutorService service = Executors.newWorkStealingPool(); System.out.println(\"CPU核数：\" + Runtime.getRuntime().availableProcessors()); service.execute(new R(1000)); service.execute(new R(2000)); service.execute(new R(2000)); service.execute(new R(2000)); //线程中的四个线程执行前面四个任务，线程1执行完后就会来执行这个任务 service.execute(new R(2000)); //因为是精灵线程所以前台看不到输出，将主线程阻塞住就能看到输出 System.in.read(); service.shutdown(); &#125; static class R implements Runnable &#123; int time; public R(int time) &#123; super(); this.time = time; &#125; @Override public void run() &#123; try &#123; Thread.sleep(time); System.out.println(Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 6、ForkJoinPoolForkJoinPool采用的是分而治之的思想来处理任务的，比如任务1我觉得太大了，线程1就可以创建出两个子线程1.1和1.2，如果1.1和1.2中的任务还是觉得太大了，又可以再分，相当于递归。任务的大小和什么时候该创建出子线程可以自定义。Java提供了RecursiveAction（无返回值）和RecursiveTask（有返回值）两个类给我们实现自定义的任务。 适用场景：大数据计算的时候，使用该线程池分而治之，最后将结果加起来 下面这个例子是计算出1000000个数的总和，使用RecursiveAction（无返回值），只要超过50000个数就创建出子线程来计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class T12_ForkJoinPool &#123; static int[] nums = new int[1000000]; static final int MAX_NUM = 50000; static Random r = new Random(47); static &#123; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = r.nextInt(100); &#125; // 一个线程计算 long start = System.currentTimeMillis(); System.out.println(Arrays.stream(nums).sum()); long end = System.currentTimeMillis(); System.out.println(end - start); &#125; static class AddTask extends RecursiveAction &#123; //起始索引和结束索引 int start, end; public AddTask(int start, int end) &#123; super(); this.start = start; this.end = end; &#125; @Override protected void compute() &#123; //如果计算的数小于等于5000就直接运算 if (end - start &lt;= MAX_NUM)&#123; int sum = 0; for (int i = start; i &lt; end; i++) &#123; sum += nums[i]; &#125; /** from-468750-to-500000=1550090 from-968750-to-1000000=1547147 from-437500-to-468750=1543904 from-406250-to-437500=1549217 from-375000-to-406250=1547524 from-343750-to-375000=1550377 from-312500-to-343750=1557548 from-281250-to-312500=1556502 from-250000-to-281250=1548952 from-218750-to-250000=1544876 from-187500-to-218750=1551438 from-156250-to-187500=1540919 from-125000-to-156250=1547592 from-93750-to-125000=1545356 from-62500-to-93750=1551600 from-31250-to-62500=1549447 from-0-to-31250=1548690 from-718750-to-750000=1544974 from-687500-to-718750=1542965 from-656250-to-687500=1549610 from-625000-to-656250=1544851 from-593750-to-625000=1544628 from-562500-to-593750=1554697 from-531250-to-562500=1551386 from-500000-to-531250=1540894 from-843750-to-875000=1545588 from-812500-to-843750=1551625 from-781250-to-812500=1545580 from-750000-to-781250=1543492 from-906250-to-937500=1547821 from-875000-to-906250=1542223 from-937500-to-968750=1555770 **/ System.out.println(\"from-\" + start + \"-to-\" + end + \"=\" + sum); &#125; else&#123; //如果大于5000就切半 int middle = start + (end - start) / 2; //创建两个子任务再来调用compute()，如果还切半还大于50000，又会切半。相当于递归 AddTask subTask1 = new AddTask(start, middle); AddTask subTask2 = new AddTask(middle, end); subTask1.fork(); subTask2.fork(); &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; ForkJoinPool fjp = new ForkJoinPool(); AddTask task = new AddTask(0, nums.length); long start = System.currentTimeMillis(); // 精灵线程（守护线程，后台线程） fjp.execute(task); long end = System.currentTimeMillis(); System.out.println(end - start); // 因为是精灵线程，所以主线程要阻塞住，不然看不到打印 System.in.read(); fjp.shutdown(); &#125;&#125; 如果要看到所有子线程计算完成后的合计结果可以使用RecursiveTask（有返回值） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class T12_ForkJoinPool &#123; static int[] nums = new int[1000000]; static final int MAX_NUM = 50000; static Random r = new Random(47); static &#123; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = r.nextInt(100); &#125; // 一个线程计算 long start = System.currentTimeMillis(); System.out.println(Arrays.stream(nums).sum()); long end = System.currentTimeMillis(); System.out.println(end - start); &#125; static class AddTask extends RecursiveTask&lt;Long&gt; &#123; // 起始索引和结束索引 int start, end; public AddTask(int start, int end) &#123; super(); this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; // 如果计算的数小于等于5000就直接运算 if (end - start &lt;= MAX_NUM) &#123; long sum = 0; for (int i = start; i &lt; end; i++) &#123; sum += nums[i]; &#125; return sum; &#125; // 如果大于5000就切半 int middle = start + (end - start) / 2; // 创建两个子任务再来调用compute()，如果还切半还大于50000，又会切半。相当于递归 AddTask subTask1 = new AddTask(start, middle); AddTask subTask2 = new AddTask(middle, end); subTask1.fork(); subTask2.fork(); //fork完(分开执行完就要合并了) return subTask1.join() + subTask2.join(); &#125; &#125; public static void main(String[] args) throws IOException &#123; ForkJoinPool fjp = new ForkJoinPool(); AddTask task = new AddTask(0, nums.length); long start = System.currentTimeMillis(); // 精灵线程（守护线程，后台线程） fjp.execute(task); //join本来就是阻塞的，这里主线程就不用阻塞 Long result = task.join(); System.out.println(result); long end = System.currentTimeMillis(); System.out.println(end - start); fjp.shutdown(); &#125;&#125; 四、ParallelStreamAPIJava中提供了对集合多线程运算的API，下面使用单线程和多线程计算10000个数中是否为质数，对比双方的效率。 每个人电脑不一样，但是使用多线程效率上还是快上不少的 单线程：1655毫秒使用parallelStream()多线程计算：410毫秒 123456789101112131415161718192021222324252627282930313233343536373839404142public class T14_ParallelStreamAPI &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Random r = new Random(47); for (int i = 0; i &lt; 10000; i++) &#123; list.add(1000000 + r.nextInt(1000000)); &#125; long start = System.currentTimeMillis(); list.forEach(o -&gt; isPrime(o)); long end = System.currentTimeMillis(); System.out.println(end - start); //使用 parallel stream api start = System.currentTimeMillis(); /* list.parallelStream().forEach(new Consumer() &#123; @Override public void accept(Object t) &#123; // TODO Auto-generated method stub T14_ParallelStreamAPI.isPrime((int) t); &#125; &#125;); */ list.parallelStream().forEach(T14_ParallelStreamAPI::isPrime); end = System.currentTimeMillis(); System.out.println(end - start); &#125; static boolean isPrime(int num) &#123; for (int i = 2; i &lt; num / 2; i++) &#123; if (num % i == 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 总结12345678910111213141516171819202122232425Executor 所有线程池的接口ExecutorService Executor的子接口 Runnable和Callable的区别 1、Runnable没有返回值，Callable有返回值 2、Runnable异常只能内部消化，Callable可以throws出去，Callable使用FutureTask的get方法(阻塞) 获取返回值Callable 自定义任务的接口Future 线程池执行完任务返回的值，通过它get()到返回值Executors 工具类，可以用来创建线程池六种线程池使用线程池：先创建一个任务，然后丢给线程池，线程池中的线程会来执行该任务fixed 指定固定大小的线程池cached 弹性的 不能指定容量的线程池，来一个任务线程池中没有空闲的线程就会创建一个线程来执行，线程池中最多数量是CPU能支撑最多的数量 一个线程默认60秒不使用系统自动销毁single 这个线程池中只有一个线程 优点：任务是按顺序执行的scheduled 定时执行任务的线程池workstealing 线程池中某个线程执行完了自己的任务会主动去拿别人没有执行的任务来执行（操作系统CPU几核就会 给你自动创建几个线程）forkjoin 大数据计算的时候，使用该线程池分而治之，最后将结果加起来。类似递归ThreadPoolExecutor 自定义线程池，所有的线程池背后都是使用ThreadPoolExecutor来实现的 也可以继承这个类自定义线程池，需要指定一些参数ParallelStreamAPI 多线程计算数据的API","categories":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"并发容器","slug":"2019-05-09-并发容器","date":"2019-05-09T13:58:00.000Z","updated":"2019-05-23T04:45:34.080Z","comments":true,"path":"2019/05/09/2019-05-09-并发容器/","link":"","permalink":"http://yoursite.com/2019/05/09/2019-05-09-并发容器/","excerpt":"","text":"JDK1.5之前给我们提供的线程安全的容器只有Hashtable，Vector之类的容器，底层用synchronized实现的，所以效率很差，JDK1.5给我们提供了一系列的并发容器，下面用几个例子依次介绍。 一、Hashtable、ConcurrentHashMap、ConcurrentSkipListMap、HashMap 创建100个线程并且每个线程需要往Map中插入10000个数，使用Hashtable、ConcurrentHashMap、ConcurrentSkipListMap、HashMap来测试。 HashMap使用Hash表来实现的，执行时间是最快的，但是线程不是安全的； 用Hashtable是用synchronized加锁的方式实现线程安全，所以效率不是很高； Hashtable是锁住整个hash表，一次只能插入一个，ConcurrentHashMap把hash表分成了16份，每次锁住一份，分段锁，因此可以并发的插入。效率比Hashtable要快点 ConcurrentSkipListMap使用跳表数据结构实现的、高并发并且排序，插入效率较低，查询较高 12345678910111213141516171819202122232425262728293031323334353637public class T01_ConcurrentMap &#123; public static void main(String[] args) &#123; Random r = new Random(); // Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();// Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();// Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;(); //会有并发问题 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //初始化10个线程，每个线程都添加10000个数 Thread[] threads = new Thread[100]; CountDownLatch latch = new CountDownLatch(threads.length); for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 10000; j++) &#123; map.put(\"a\" + r.nextInt(100000), \"a\" + r.nextInt(100000)); &#125; //执行完一个线程就减少一个门闩 latch.countDown(); &#125;); &#125; long start = System.currentTimeMillis(); Arrays.asList(threads).forEach(o -&gt; o.start()); try &#123; //主线程等待所有线程执行完就会被唤醒 latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 二、ArrayList、Vector、CopyOnWriteArrayList 创建100个线程，每个线程插入1000个数，最终List中会插入100000万个数，用ArrayList、Vector、CopyOnWriteArrayList测试 ArrayList会有并发问题，但是效率高 Vector使用synchronized加锁的方式实现线程安全，但是效率很底 CopyOnWriteArrayList写时复制容器 ，多线程环境下，写时效率低（写的时候加锁并且把之前的数组复制到一个新的数组中），读时效率高，适合多线程环境中写少读多 123456789101112131415161718192021222324252627282930313233343536373839404142public class T02_CopyOnWriteList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = // new ArrayList&lt;&gt;(); //这个会有并发问题// new Vector&lt;&gt;(); new CopyOnWriteArrayList&lt;&gt;(); Random r = new Random(47); Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; list.add(\"a \" + r.nextInt(10000)); &#125; &#125;); &#125; runAndCompute(threads); System.out.println(list.size()); &#125; public static void runAndCompute(Thread[] threads) &#123; long start = System.currentTimeMillis(); Arrays.asList(threads).forEach(o -&gt; o.start()); Arrays.asList(threads).forEach(o -&gt; &#123; try &#123; //当主线程每次执行到这里时就会调用自定义线程的join方法 //就要让自定义线程执行完才会执行主线程 o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 三、ConcurrentLinkedQueue、ConcurrentLinkedDeque 测试线程安全的队列的一些API使用，ConcurrentLinkedQueue（单项队列），ConcurrentLinkedDeque（双端队列） size()：返回长度 getFirst()：返回队列第一个元素 getLast()：返回队列最后一个元素 offer()：相当于add(),add()添加可能会报异常，offer()会返回是否插入成功 poll()：返回链表上第一个数，并且从链表中删掉 peek()：返回链表第一个数，不会删除 12345678910111213141516171819202122232425262728293031323334public class T03_ConcurrentQueue &#123; public static void main(String[] args) &#123;// testConcurrentLinkedQueue(); testConcurrentLinkedDeque(); &#125; public static void testConcurrentLinkedDeque() &#123; //双端队列 ConcurrentLinkedDeque&lt;String&gt; queue = new ConcurrentLinkedDeque&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; queue.offer(\"double\" + i); &#125; System.out.println(\"size = \" + queue.size()); System.out.println(\"双端队列头：\" + queue.getFirst()); System.out.println(\"双端队列尾：\" + queue.getLast()); &#125; public static void testConcurrentLinkedQueue() &#123; Queue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; queue.offer(\"a\" + i); &#125; System.out.println(\"size = \" + queue.size()); System.out.println(\"弹出链表头：\" + queue.poll()); System.out.println(\"size = \" + queue.size()); System.out.println(\"链表头：\" + queue.peek()); System.out.println(\"size = \" + queue.size()); &#125;&#125; 四、LinkedBlockingQueue 使用生产者消费者模式来测试LinkedBlockingQueue（阻塞式的同步链表队列） 使用put方法添加满了就会阻塞住（之前写生产者消费者模式使用synchronized、wait、notify很麻烦） 如果队列中为空take()就会等待/阻塞住 12345678910111213141516171819202122232425262728293031323334public class T04_LinkedBlockingQueue &#123; static BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;(); public static void main(String[] args) &#123; //启动一个生产者线程 new Thread(() -&gt; &#123; //生产100个元素 for (int i = 0; i &lt; 100; i++) &#123; try &#123; queue.put(\"a\" + i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); //启动5个消费者线程 for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; //每次消费十个 for (int j = 0; j &lt; 20; j++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" take--\" + queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, \"c\" + i).start(); &#125; &#125;&#125; 五、ArrayBlockingQueue 测试阻塞式的同步数组队列ArrayBlockingQueue add()：满了再添加会报异常 offer()： 满了添加不会报异常，返回一个boolean值来确认是否插入 offer(“a10”, 1, TimeUnit.SECONDS)：等待/阻塞一秒，如果还不能插入就放弃 put()：满了会等待/阻塞住 123456789101112131415161718public class T05_ArrayBlockingQueue &#123; static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; queue.offer(\"a\" + i); &#125;// queue.add(\"a10\"); // boolean isInsert = queue.offer(\"a10\");// System.out.println(isInsert); // queue.offer(\"a10\", 1, TimeUnit.SECONDS); queue.put(\"a10\"); &#125;&#125; 六、DelayQueue DelayQueue需要添加的是一个Delayed类型的任务，因此要使用它需要实现该接口定义自己的任务，然后在自己的任务类中根据实际的业务逻辑来写对应的代码，这里我简单的使用对比时间，时间快的先执行。（执行定时任务） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class T06_DelayQueue &#123; static BlockingQueue&lt;MyTask&gt; tasks = new DelayQueue&lt;&gt;(); static class MyTask implements Delayed &#123; int id; long runningTime; MyTask(long rt, int id) &#123; this.runningTime = rt; this.id = id; &#125; @Override public int compareTo(Delayed o) &#123; //比较的方式可以自定义 if (this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return 1; &#125; else if (this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; @Override public long getDelay(TimeUnit unit) &#123; //在这里可以写自己的业务逻辑 //将第一个参数中的时间转换为第二个参数中对应的时间单元 return unit.convert(this.runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override public String toString() &#123; return id + \" --- \" + this.runningTime; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; long now = System.currentTimeMillis(); MyTask t1 = new MyTask(now + 1000, 1); MyTask t2 = new MyTask(now + 500, 2); MyTask t3 = new MyTask(now + 2500, 3); MyTask t4 = new MyTask(now + 2000, 4); MyTask t5 = new MyTask(now + 1500, 5); //添加任务 tasks.put(t1); tasks.put(t2); tasks.put(t3); tasks.put(t4); tasks.put(t5); System.out.println(tasks); for (int i = 0; i &lt; 5; i++) &#123; //这里消费任务 System.out.println(tasks.take()); &#125; &#125;&#125; 七、LinkedTransferQueue LinkedTransferQueue的transfer方法就是 如果有消费者在等待的话，生产者就不需要先存到队列中，然后再由消费者去队列中拿，而是由生产者直接交给消费者 没有消费者的话，生产者就会一直等待/阻塞 12345678910111213141516171819202122232425262728public class T07_TransferQueue &#123; public static void main(String[] args) throws InterruptedException &#123; LinkedTransferQueue&lt;String&gt; strs = new LinkedTransferQueue&lt;&gt;(); //启动一个消费者等待 new Thread(() -&gt; &#123; try &#123; //take()如果队列中为空就会等待/阻塞住 System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); //这里主线程相当于生产者，没有消费者就会阻塞，所以主线程阻塞，下面消费者执行不了，就会一直阻塞在这里 strs.transfer(\"aaa\"); /** new Thread(() -&gt; &#123; try &#123; //take()如果队列中为空就会等待/阻塞住 System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); **/ &#125;&#125; 八、SynchronousQueue SynchronousQueue容量为0的队列，不能调用add方法，调用add就会报错。 使用put阻塞，只要有消费者，生产者就直接将元素交给消费者 不能使用add()，报错，因为SynchronousQueue容量为0 12345678910111213141516171819202122232425public class T08_SynchronousQueue &#123; public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;String&gt; strs = new SynchronousQueue&lt;&gt;(); //启动消费者线程 new Thread(() -&gt; &#123; try &#123; System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); //报错，因为SynchronousQueue容量为0// strs.add(\"aaa\"); //生产者使用put(),如果队列满的就阻塞，但是此队列只能为0默认就是满的， //所以只要有消费者就会直接给消费者，没有消费者等待就阻塞在这里。一般先启动消费者 //内部使用的还是transfer() strs.put(\"aaa\"); System.out.println(strs.size()); &#125;&#125; 总结12345678910111213141516171819202122232425261、对于map/set的选择使用（set底层就是使用map来实现的，存的都是map的key） 普通情况: HashMap TreeMap LinkedHashMap 并发量不高的情况下使用 Hashtable Collections.synchronizedXXX 并发量比较高的情况下 ConcurrentHashMap ConcurrentSkipListMap(且要求排序的话，使用跳表实现的)2、队列 普通情况： ArrayList LinkedList 并发： Collections.synchronizedXXX CopyOnWriteList(读多写少) ConcurrentLinkedQueue(非阻塞式的并发队列) BlockingQueue(阻塞式队列) LinkedBlockingQueue(阻塞式的无界队列) ArrayBlockingQueue(阻塞式的有界队列) 下面两个一般用于并发量非常大的情况下，不在容器中进行等待浪费时间，直接由生产者交给消费者 TransferQueue(有消费者线程在等待，生产者直接把数据交给消费者，没有消费者，生产者就阻塞) SynchronusQueue(一种特殊的TransferQueue，容量为0) DelayQueue(执行定时任务)","categories":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"synchronized和ReentrantLock的区别","slug":"2019-05-04-synchronized和ReentrantLock的区别","date":"2019-05-04T05:44:00.000Z","updated":"2019-05-23T04:45:18.491Z","comments":true,"path":"2019/05/04/2019-05-04-synchronized和ReentrantLock的区别/","link":"","permalink":"http://yoursite.com/2019/05/04/2019-05-04-synchronized和ReentrantLock的区别/","excerpt":"","text":"一、synchronized 下面代码m1方法锁定的是 o 对象，也就是堆中那个真实的对象，而不是栈中的引用。m2方法锁定的是this对象，m3方法用synchronized修饰方法，相当于m2方法的synchronized(this)，synchronized修饰m4静态方法相当于synchronized(this.getClass())，锁定就是当前对象所属类的字节码对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class T &#123; Object o = new Object() public void m1() &#123; synchronized(o) &#123; System.out.println(Thread.currentThread().getName() + \" m1 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m1 end...\"); &#125; &#125; public void m2() &#123; synchronized(this) &#123; System.out.println(Thread.currentThread().getName() + \" m2 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m2 end...\"); &#125; &#125; public synchronized void m3() &#123; System.out.println(Thread.currentThread().getName() + \" m3 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m3 end...\"); &#125; public synchronized static void m3() &#123; System.out.println(Thread.currentThread().getName() + \" m3 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m3 end...\"); &#125;&#125; synchronized支持可重入锁，也就是可以在同步方法中调用使用相同锁对象的同步方法，如下所示 123456789101112131415public class T &#123; public synchronized void m1() &#123; System.out.println(\"m1 method\"); m2(); &#125; public synchronized void m2() &#123; System.out.println(\"m2 method\"); &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m1).start();; &#125;&#125; synchronized执行时如果抛出异常交给jvm处理，会释放锁，因此碰到异常时要小心处理 123456789101112131415161718192021222324252627282930313233343536public class T &#123; int count; public synchronized void m() &#123; System.out.println(Thread.currentThread().getName() + \" start...\"); while(true) &#123; count++; System.out.println(Thread.currentThread().getName() + \" count = \" + count); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (count == 5) &#123; //要想抛异常锁不被释放，这里应该try...catch...捕获到异常正确的处理 //原因：自己没有处理异常jvm就会处理，这时候jvm就会把锁释放 try &#123; int i = 1 / 0; &#125; catch (Exception e) &#123; System.out.println(\"出现了异常\"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m, \"t1\").start(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(t::m, \"t2\").start(); &#125;&#125; synchronized中的代码越少效率越高，因为减少了线程抢占锁的时间 123456789101112131415161718192021222324252627282930313233public class T &#123; int count = 0; synchronized void m1() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //真正需要原子操作的只有下面这一句代码 count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; void m2() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(this) &#123; count++; &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二、ReentrantLock ReentrantLock 可以用来替换synchronized ReentrantLock手动开锁，必须要必须要必须要手动释放锁，因为要手动释放锁，所以报异常时并不会释放锁 12345678910111213141516171819202122232425262728293031323334353637public class ReentrantLock1 &#123; Lock lock = new ReentrantLock(); public void m1() &#123; lock.lock(); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; Thread.sleep(1000); System.out.println(i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void m2() &#123; lock.lock(); System.out.println(\"m2...\"); lock.unlock(); &#125; public static void main(String[] args) &#123; ReentrantLock1 r = new ReentrantLock1(); new Thread(r::m1).start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(r::m2).start(); &#125;&#125; ReentrantLock可以使用tryLock尝试拿下锁，根据是否拿到锁进行不同的业务处理，也可以指定允许等待锁的时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ReentrantLock2 &#123; Lock lock = new ReentrantLock(); public void m1() &#123; lock.lock(); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; Thread.sleep(1000); System.out.println(i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void m2() &#123; //尝试拿锁 boolean isLock = lock.tryLock(); if (isLock) &#123; System.out.println(\"执行拿到的锁的业务逻辑：\" + isLock); lock.unlock(); &#125; else &#123; System.out.println(\"执行没有拿到锁的业务逻辑：\" + isLock); &#125; /*boolean isLock = false; try &#123; //尝试等待5秒，看是否能拿到锁 isLock = lock.tryLock(5, TimeUnit.SECONDS); if (isLock) &#123; System.out.println(\"执行拿到的锁的业务逻辑：\" + isLock); &#125; else &#123; System.out.println(\"执行没有拿到锁的业务逻辑：\" + isLock); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (isLock) &#123; lock.unlock(); &#125; &#125;*/ &#125; public static void main(String[] args) &#123; ReentrantLock2 r = new ReentrantLock2(); new Thread(r::m1).start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(r::m2).start(); &#125;&#125; lockInterruptibly()可对interrupt()作出响应，这个拿锁如果一直拿不到可被打断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ReentrantLock3 &#123; public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(\"t1 start...\"); //基本上就是在这死等着了 Thread.sleep(Integer.MAX_VALUE); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); //如果释放锁了,t2线程就能拿到这把锁 System.out.println(\"t1 end...\"); &#125; &#125;); t1.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread t2 = new Thread(() -&gt; &#123; System.out.println(\"t2 start...\"); try &#123;// lock.lock(); //对interrupt()作出响应，可被打断的拿锁 lock.lockInterruptibly(); &#125; catch (Exception e) &#123; System.out.println(\"interrupted!\"); &#125; finally &#123; lock.unlock(); System.out.println(\"t2 end...\"); &#125; &#125;); t2.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //使t2线程不要一直在那等待锁了，直接停止 t2.interrupt(); &#125;&#125; ReentrantLock默认构造器为非公平锁,构造器传true可以指定为公平锁 非公平锁:谁拿到锁不确定,全靠CPU调度 公平锁:线程拿锁的机会平均 12345678910111213141516171819public class ReentrantLock4 extends Thread &#123;// Lock lock = new ReentrantLock(); Lock lock = new ReentrantLock(true); public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + \"拿到了锁\"); lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ReentrantLock4 r = new ReentrantLock4(); new Thread(r).start(); new Thread(r).start(); &#125;&#125; 三、生产者消费者模式自定义一个固定容量同步容器,具有put,get,getCount方法. 能够支持2个生产者线程以及10个消费者线程的阻塞调用 1、使用synchronized​ 1）判断那里为什么使用while而不是if？ 12因为while会一直判断,而if只会判断一次比如有两个生产者线程t1和t2,两个都被唤醒了,当t1拿到锁后往里扔了一个,这时候容器满了,执行完后释放锁,这时候t2线程又拿到了锁,因为if判断之前只判断了一次,所以这时候不会判断了,拿到锁之后继续执行添加,此时容器已经满了,这里就会出问题 ​ 2）使用notifyAll()而不是notify() 1唤醒所有线程这里使用notifyAll而不是notify,如果使用notify又唤醒了一个生产者线程而不是消费者线程,生产者线程判断此时容器满了它就会等待,此时程序就卡住了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MyContainer1&lt;T&gt; &#123; private final LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;(); //容器最大容量为10 private static final int MAX = 10; private int count = 0; public synchronized void put(T t) &#123; while(list.size() == MAX) &#123; try &#123; //如果当前容量满了就等待然后释放锁 this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果没有满就往里添加 list.add(t); ++count; System.out.println(Thread.currentThread().getName() + \"生产了第\" + count + \"个元 素\"); this.notifyAll(); &#125; public synchronized T get() &#123; while(list.size() == 0) &#123; try &#123; //如果容器中没有数据了就等待 this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //有数据就减少一个并且唤醒所有线程(生产者线程进行生产),返回一个元素 System.out.println(Thread.currentThread().getName() + \"消费了第\" + count + \"个元 素\"); --count; this.notifyAll(); return list.removeFirst(); &#125; public int getCount() &#123; return count; &#125; public static void main(String[] args) &#123; MyContainer1&lt;Object&gt; c = new MyContainer1&lt;&gt;(); //先启动十个消费者线程进行等待 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; //一次消费5个 for (int j = 1; j &lt;= 5; j++) &#123; c.get(); &#125; &#125;, \"c\" + i).start(); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //再启动2个生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(() -&gt; &#123; //生产者一次生产25个 for (int j = 1; j &lt;= 25; j++) &#123; c.put(j); &#125; &#125;,\"p\" + i).start(); &#125; &#125;&#125; 2、使用ReentrantLock实现​ 使用ReentrantLock实现显然效率要高一点，这里可以使用Condition来指定线程在哪个条件上等待，后面唤 醒的时候直接在对应的条件上唤醒，而不是唤醒所有的线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class MyContainer2&lt;T&gt; &#123; private final LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;(); // 容器最大容量为10 private static final int MAX = 10; private int count = 0; private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); public void put(T t) &#123; try &#123; lock.lock(); while (list.size() == MAX) &#123; //如果当前容量满了就等待然后释放锁 producer.await(); &#125; // 如果没有满就往里添加 list.add(t); ++count; System.out.println(Thread.currentThread().getName() + \"生产了第\" + count + \"个 元素\"); // 唤醒所有在consumer条件上等待的线程 consumer.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public T get() &#123; T t = null; try &#123; lock.lock(); while (list.size() == 0) &#123; //如果容器中没有数据了就等待 consumer.await(); &#125; //有数据就减少一个并且唤醒所有线程(生产者线程进行生产),返回一个元素 System.out.println(Thread.currentThread().getName() + \"消费了第\" + count + \"个 元素\"); --count; //唤醒所有在producer条件上等待的线程 producer.signalAll(); t = list.removeFirst(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; return t; &#125; public int getCount() &#123; return count; &#125; public static void main(String[] args) &#123; MyContainer2&lt;Object&gt; c = new MyContainer2&lt;&gt;(); // 先启动十个消费者线程进行等待 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; // 一个消费者可以消费5个 for (int j = 1; j &lt;= 5; j++) &#123; c.get(); &#125; &#125;, \"c\" + i).start(); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 再启动2个生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(() -&gt; &#123; // 一个生产者可以生产25个 for (int j = 1; j &lt;= 25; j++) &#123; c.put(j); &#125; &#125;, \"p\" + i).start(); &#125; &#125;&#125; 结论： ReentrantLock 可以用来替换synchronized ReentrantLock手动开锁，必须要必须要必须要手动释放锁 synchronized报异常时jvm会手动释放锁，ReentrantLock不会释放 ReentrantLock比synchronized要灵活 ReentrantLock可以指定为公平锁 ReentrantLock还可以打断拿锁，尝试拿锁，指定线程在哪个条件上等待 它们都是可重入锁，虽然ReentrantLock比synchronized看起来要好很多，但是synchronized实现简单，语义清晰，便于JVM堆栈跟踪，加锁解锁过程由JVM自动控制，具体使用哪个看实际中的业务。","categories":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"volatile和synchronized的区别","slug":"2019-04-27-volatile和synchronized的区别","date":"2019-04-27T10:20:00.000Z","updated":"2019-05-23T04:45:07.942Z","comments":true,"path":"2019/04/27/2019-04-27-volatile和synchronized的区别/","link":"","permalink":"http://yoursite.com/2019/04/27/2019-04-27-volatile和synchronized的区别/","excerpt":"","text":"1、先看一段代码 123456789101112131415161718192021222324public class T &#123; boolean isRunning = true; public void m() &#123; System.out.println(\"m start...\"); while(isRunning) &#123; &#125; System.out.println(\"m end...\"); &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m, \"t1\").start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.isRunning = false; &#125; &#125; 首先新建一个线程t1启动，调用m方法，进入死循环，按道理来说我主线程执行到下面的时候把isRunning改成false就会结束t1线程中的死循环，但是执行你会发现并不会结束。 这是因为每个线程运行都会有自己的一份内存也可以叫做缓冲区，比如下面这张图，上面一个t1线程和主线程分别占用一个CPU，那么CPU中会有个对应线程的缓冲区。 代码执行过程：栈内存，堆内存，方法区之类的内存称之为主内存，堆内存对应的t对象中有个成员变量isRunning=true，在t1线程启动的时候会从主内存中copy一份isRunning（boolean类型为一个字节）的值到自己的缓冲区中，然后就开始死循环一直执行下去，这时候主线程把isRunning的值copy到自己的缓冲区然后执行isRunning=false并且写会主内存中去，但是t1线程是非常繁忙的，一直在执行死循环没有时间去主内存刷新自己isRunning的值，所以就算主线程修改了isRunning的值，t1线程还是死循环 解决方法：在isRunning成员变量前面加上volatile关键字 volatile关键字的作用：就是保持线程的可见性，只要该变量的值修改了，就会通知其他线程你们缓冲区中的copy过期了，需要重新来主内存中刷新一下，这时候t1线程就会得到通知，并且来主内存中刷新isRunning的值，从而停止死循环。注意：使用volatile的作用不是t1线程会每次使用到isRunning的时候都去主内存中读一下isRunning的值，而是主内存中的isRunning被修改了，就会通知所有的使用到isRunning的线程来主内存中刷新一下isRunning的值 也可以在死循环中sleep一段时间，或者打印一些语句，使CPU不要太忙，得出空闲就会来主内存中刷新isRunning的值，但是这样是不稳定的，我怎么知道你CPU什么时候空闲，所以该用volatile还是得用volatile 2、再来看一段代码 1234567891011121314151617181920212223242526272829public class T &#123; volatile int count = 0; public void m() &#123; for (int i = 0; i &lt; 10000; i++) &#123; count++; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, \"thread-\" + i)); &#125; threads.forEach(o -&gt; o.start()); threads.forEach(o -&gt; &#123; try &#123; //等待所有线程结束 o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 按照正常的思路打印出来应该是100000，但是打印出来的结果会远远小于100000，因为volatile只保证可见性不保证原子性，而count++不是原子性操作，分为拿到count的值，然后加1，再赋值。这时候如果有两个线程同时拿到count=100到缓冲区中，加1再写入主内存中。这时候两个线程合起来只增加了1，所以最终会少很多。这里保证的可见性，只保证线程拿到的值一定是最新的。 解决方法： 成员变量上不加volatile，用synchronized修饰m方法，或者用synchronized同步代码块包裹住count++ 或者使用如果仅仅只是一些自增自减，判断是否为true等之类的操作，没必要使用synchronized来保证原子性，Java中提供了很AtomicXXX类，原子操作的类，就是该类中的所有方法都是原子性的。不是使用synchronized保证原子性，使用的是很底层的方式，比synchronized效率要高。但是该类两个方法同时使用时不能保证原子性（在两个方法调用的之间还是有可能会被别的线程抢占进入） 12345678910111213141516171819202122232425262728public class T &#123; AtomicInteger count = new AtomicInteger(0); public void m() &#123; for (int i = 0; i &lt; 10000; i++) &#123; count.incrementAndGet(); &#125; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, \"thread-\" + i)); &#125; threads.forEach(o -&gt; o.start()); threads.forEach(o -&gt; &#123; try &#123; //等待所有线程结束 o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 结论：volatile只保证线程的可见性，synchronized既保证可见性也保证原子性，但是synchronized相对于volatile效率会低很多，所以能用volatile替代synchronized，就尽量使用volatile。","categories":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"HashMap实现原理","slug":"2019-04-21-HashMap实现原理","date":"2019-04-21T13:19:00.000Z","updated":"2019-05-23T04:44:55.632Z","comments":true,"path":"2019/04/21/2019-04-21-HashMap实现原理/","link":"","permalink":"http://yoursite.com/2019/04/21/2019-04-21-HashMap实现原理/","excerpt":"","text":"HashMap底层是通过数组加单项链表的方式实现的 初始数组长度为16 链表中的节点具有的元素为 hash：用hashCode（哈希码）通过hash算法计算出来的哈希值 key：键值对的key value：键值对的value next：下一个节点 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125; put(key, value) 首先会获取key的hashCode，根据hash算法（比如hashCode%数组的长度）算出对应的hash(哈希值)，就把哈希值作为下标，将Node对象（hash(哈希值)，key，value，next[只有一个的话就为null]）放入对应的下标位置中。 再来一个就重复上面的操作，如果key算出的哈希值一样的话，就用equals对比key，如果返回true，就覆盖，如果equals对比返回false，就将其添加在该下标位置中的单链表末尾。并设置上一个Node节点的next属性指向现在添加的Node。以此类推。 因为hashCode一样，equals还是有可能会为false。hashCode取余可能最终会得到相同的哈希值 Java中规定 1、equals为true，则hashCode必须一样。反之不成立，也就是hashCode一样，equals不一定为true hashCode本身是根据在jvm中的内存地址使用hash算法算出来的int类型的数，如果equals为true，说明两个对象在内存中的地址是一样的，所以根据在jvm中的内存地址使用hash算法算出来的hashCode肯定也一样。 hashCode一样，equals也有可能为false，因为hashCode是int类型的，最多允许存在2^32个分组，也是有限的，而jvm中的内存地址不止这么多，因此不同的内存地址根据hash算法算出来的hashCode也是有可能一致的。所以hashCode一样，equals不一定为true 2、重写equals方法一定要重写hashCode方法 get(key) 根据key获取对应hashCode，根据hash算法算出对应的哈希值，把哈希值当作下标去数组找找到对应的位置，使用key从头节点开始遍历，equals每个节点中的key，如果返回true，就将其对应的value返回 在Java8之后只要数组中的链表长度为8时，就会将链表转 化为红黑树，以减少搜索时间。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"author":"Yang"},{"title":"计算机的位移运算","slug":"2019-04-18-计算机的位移运算","date":"2019-04-18T14:20:00.000Z","updated":"2019-05-23T04:44:40.260Z","comments":true,"path":"2019/04/18/2019-04-18-计算机的位移运算/","link":"","permalink":"http://yoursite.com/2019/04/18/2019-04-18-计算机的位移运算/","excerpt":"","text":"最近看编程思想看到操作符这章实在不理解位运算那地方的例子： 其实就是不明白计算机中是怎么进行位运算和负数是怎么表示的。网上查阅博客都是千篇一律，没有解决问题，且没有根据，今天看到《码出高效》这本书还没看过，就翻开看看，第一章就是讲位运算，看完之后豁然开朗，总结下计算机中是怎么进行位运算的。 一、计算机中负数的运算计算机中是以二进制补码进行存储的，正数的原码、反码、补码都是一样，负数的补码是原码的反码再加1，这样可以减法运算可以使用加法器实现，符号位也参与运算（二进制的最高位为符号位0为正，1为负，以8位来算，最高位为符号位，其余7位表示数值），取反码与符号位无关。 eg： 1234547 + (-47) 在计算机中这样运算 0010 1111+ 1101 0001 (-47的补码) 原码：1010 1111 补码：1101 0001------------ 0000 0000（遇2进1，最后的结果就是0） 二、移位操作移位分为有符号左移（&lt;&lt;），有符号右移（&gt;&gt;） 无符号右移（&gt;&gt;&gt;）没有无符号左移（&lt;&lt;&lt;） 1、有符号位移运算，何为有符号左移、右移，因为计算机中符号位最高位0代表正数，1代表负数，所以正数有符号右移高位补0，负数有符号右移高位补1，不管有无符号位移运算左移低位都是补0。 借书上的的例子： 负数位移运算根据补码来移位（符号位也要跟着移位，取反码与符号位无关，符号位不参与数值表示） 最终高位如果为0，说明正数不用进行操作，按照二进制转换成十进制就是结果了。 如果高位为1，说明是负数，也就是补码，可以补码减1再取反码就是原码了，也可以根据结果取反码再加1就是原码（补码的补码就是原码），按照二进制转换成十进制就是结果了。 2、无符号位运算 无符号位移运算意思是我不关心你的符号位，（而有符号位移运算会根据是正数还是负数高位会进行不同的补位），不管正数负数高位都补0，只有无符号右移（&gt;&gt;&gt;），没有无符号左移（&lt;&lt;&lt;），因为符号位在左边，你往左移影响不到符号位，没有意义。 继续借书上的例子（允许偷点懒） 总结：1、计算机中是以补码进行存储的，最高位为符号位。 2、符号位不参与反码，符号位不参与数值表示，符号位参与位移运算移位，符号位参与运算加法 3、位移运算移动按补码进行移动，结果的高位为0，说明是正数，不需要操作 如果高位为1，说明是负数，得到的结果是补码，则取反加1得到原码 4、输入给计算机的二进制码，计算机会当作原码进行处理，而计算机输出的二进制码是补 码（正数的补码即原码，负数需要转换得到最终的结果） 码出高效这本书全是干货，后面应该会有更大的惊喜。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"author":"Yang"},{"title":"处理同一个用户多处登录","slug":"2019-04-17-处理同一个用户多处登录","date":"2019-04-17T01:30:00.000Z","updated":"2019-05-23T04:43:57.159Z","comments":true,"path":"2019/04/17/2019-04-17-处理同一个用户多处登录/","link":"","permalink":"http://yoursite.com/2019/04/17/2019-04-17-处理同一个用户多处登录/","excerpt":"","text":"qq都用过，在不同的手机上登录同一个用户后面登录的会把之前的挤掉，游戏也是这样，像LOL，后面登录的都会把前面登录的用户给挤掉。最近做项目中也使用了这种原理 一、思想HttpSession 的原理是基于 Cookie 的，只要访问当前网站，就会有一个名称为 JSESSIONID 的 Cookie ，第一次创建 HttpSession 对象，就是第一次执行到 request.getSession() 这个方法时，在 getSession() 方法里面就会获取到名称为 JSESSIONID 的 Cookie ，根据对应的 value 去服务端查找对应的 HttpSession 对象，如果没有找到就会创建 HttpSession 对象，此时，HttpSession 对象被创建，当前会话如果不关闭，每次请求响应都会带着名称为 JSESSIONID 的 Cookie ，第二次执行到 request.getSession() 方法时，就不用创建 HttpSession 对象了，会把第一次执行到该方法创建的 HttpSession 对象返回，所以这也就是一次会话中只有一个 HttpSession对象。 基于上面 HttpSession的原理，就有了解决同一个用户多处登录，挤掉上一次登录的解决方案了。 可以写一个 HttpSessionListener ，只要有对应的 HttpSession 对象创建，就会被监听到，只要有 HttpSession对象被创建，就可以把当前的 HttpSession 对象存到一个 Map 中，key 为 sessionId，value 为 HttpSession对象 每次登录成功后把 userId当作 key ，当前会话的 currentSessionId 当作value，存入到一个 Map 中。这样就与上面的 Map 通过一个 currentSessionId 联系起来了。不过在每次存入之前都根据当前的 userId 当作key，在当前的 Map 中找下有没有对应的 sessionId ，如果sessionId不为空且和当前的 currentSessionId 不一致，那么说明当前登录就是同一个用户在不同的地方第二次登录。我们就可以根据之前的 sessionId 当作 key，去前面的 Map 中获取到对应的 HttpSession 对象，并将其销毁，那么第一次登录的地方再请求通过携带的 JSESSIONID 获取不到之前的 HttpSession 对象，此时就会创建一个新的 HttpSession 对象，在拦截器中根据这个新的 HttpSession 对象就获取不到 User 对象了，此时就会跳转到登录页面，达到同一个用户在不同地方同时登录，后面会把前面的用户给挤掉的功能。 二、代码实现怎么让上面两个Map让应用中只有唯一的一个呢，可以写一个管理类，将这两个 Map 作为该管理类的成员变量，然后将管理类交给Spring容器类管理，Spring容器中的Bean都是单例的，就能达到整个应用中只有唯一的一个了 SpringUtils类 这里碰到个坑，因为 HttpSessionListener 是tomcat来实例化的，并不能加入到 Spring容器中通过Spring容器来实例化，这样也就不能在 HttpSessionListener 实现类中自动注入组件，只能直接获取到Spring容器调用Spring容器中的方法来获取对应的Bean。 在Spring容器创建时，Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。 12345678910111213141516171819202122232425262728293031323334353637/** * spring 帮助类 * * @author pineapple * @create 2019/3/5 */@Componentpublic class SpringUtils implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; if(SpringUtils.applicationContext == null)&#123; SpringUtils.applicationContext = applicationContext; &#125; &#125; public static ApplicationContext getApplicationContext()&#123; return applicationContext; &#125; //根据name public static Object getBean(String name)&#123; return getApplicationContext().getBean(name); &#125; //根据类型 public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123; return getApplicationContext().getBean(clazz); &#125; public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123; return getApplicationContext().getBean(name,clazz); &#125;&#125; UserSessionManager（管理类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Componentpublic class UserSessionManager &#123; //userId : sessionId private ConcurrentHashMap&lt;String, String&gt; userSessionMap = new ConcurrentHashMap&lt;&gt;(); //sessionId : HttpSession对象 private ConcurrentHashMap&lt;String, HttpSession&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /** * UserSessionMap中增加一条键值对 * @param userId * @param sessionId */ public void putUserSessionMap(String userId, String sessionId) &#123; userSessionMap.put(userId, sessionId); &#125; /** * 根据SessionId删除对应的键值对 * @param sessionId */ public void removeInUserSessionMap(String sessionId) &#123; String key = null; for (Map.Entry&lt;String, String&gt; entry : userSessionMap.entrySet()) &#123; String value = entry.getValue(); if (Objects.equals(value, sessionId)) &#123; key = entry.getKey(); break; &#125; &#125; if (key != null) &#123; userSessionMap.remove(key); &#125; &#125; /** * 根据userId去UserSessionMap中获取对应的SessionId * @param userId */ public String getSessionIdByUserId(String userId) &#123; return userSessionMap.get(userId); &#125; /** * 往SessionMap中增加一条键值对 * @param sessionId * @param session */ public void putSessionMap(String sessionId, HttpSession session) &#123; sessionMap.put(sessionId, session); &#125; /** * 根据sessionId销毁HttpSession对象 * @param sessionId */ public void destoryInSessionMap(String sessionId) &#123; HttpSession session = sessionMap.get(sessionId); if (null != session) &#123; session.invalidate(); &#125; //如果包含当前的key，且获取到的session对象又为null，说明对应的HttpSession对象过期了， //需要移除到对应的key，节省内存 if (sessionMap.contains(sessionId) &amp;&amp; session == null) &#123; sessionMap.remove(sessionId); &#125; &#125; /** * 处理多用户登录，登录成功时调用该方法&lt;br/&gt; * 先根据userId去userSessionMap中获取对应的sessionId如果sessionId不为null且与当前 * currentSessionId不一致的话就根据sessionId去sessionMap中获取对应的HttpSession对象并销毁 * 否则的话就把当前的userId和currentSessionId存在UserSessionMap中 * * @param currentSessionId * @param userId */ public void handleMoreUserLogin(String userId, String currentSessionId) &#123; String sessionId = getSessionIdByUserId(userId); if (null != sessionId &amp;&amp; !Objects.equals(sessionId, currentSessionId)) &#123; destoryInSessionMap(sessionId); &#125; putUserSessionMap(userId, currentSessionId); &#125;&#125; HttpSessionLoginListener 12345678910111213141516171819202122@WebListenerpublic class HttpSessionLoginListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123; //监听到HttpSession被创建时，就把当前HttpSession对象存储在SessionMap中 HttpSession session = httpSessionEvent.getSession(); UserSessionManager userSessionManager = SpringUtils.getBean(UserSessionManager.class); userSessionManager.putSessionMap(session.getId(), session); &#125; @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123; //当有HttpSession对象被销毁时就删除UserSessionMap中的键值对 String sessionId = httpSessionEvent.getSession().getId(); UserSessionManager userSessionManager = SpringUtils.getBean(UserSessionManager.class); userSessionManager.removeInUserSessionMap(sessionId); &#125;&#125; 仔细看上面的代码这样每次在登录成功后就调用userSessionManager类中的handleMoreUserLogin方法 12//处理多处同时登录该用户的情况userSessionManager.handleMoreUserLogin(user.getId() + \"\", session.getId());","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"author":"Yang"},{"title":"Spring Boot学习15_监控管理（完结）","slug":"2019-04-14-SpringBoot学习15_监控管理","date":"2019-04-14T01:57:00.000Z","updated":"2019-05-23T04:43:36.755Z","comments":true,"path":"2019/04/14/2019-04-14-SpringBoot学习15_监控管理/","link":"","permalink":"http://yoursite.com/2019/04/14/2019-04-14-SpringBoot学习15_监控管理/","excerpt":"","text":"通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进行操作，自动得到审计、健康及指标信息等 一、端点介绍通过执行器端点，您可以监控应用程序并与之交互。Spring Boot包含许多内置端点，允许您添加自己的端点。例如， health端点提供基本的应用程序健康信息。 可以启用或禁用每个端点。它控制是否创建端点并且其3bean存在于应用程序上下文中。要进行远程访问，还必须通过JMX或HTTP公开端点。大多数应用程序选择HTTP，其中端点的ID以及前缀/actuator映射到URL。例如，默认情况下，health映射到/actuator/health 下图对每个端点进行了介绍，以及默认情况下是否启用 ID 描述 默认情况下启用 auditevents 公开当前应用程序的审核事件信息。 是 beans 显示应用程序中所有Spring bean的完整列表。 是 caches 暴露可用的缓存。 是 conditions 显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。 是 configprops 显示所有的整理列表@ConfigurationProperties。 是 env 露出Spring的属性ConfigurableEnvironment。 是 flyway 显示已应用的任何Flyway数据库迁移。 是 health 显示应用健康信息。 是 httptrace 显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）。 是 info 显示任意应用信息。 是 integrationgraph 显示Spring Integration图。 是 loggers 显示和修改应用程序中记录器的配置。 是 liquibase 显示已应用的任何Liquibase数据库迁移。 是 metrics 显示当前应用程序的“指标”信息。 是 mappings 显示所有@RequestMapping路径的整理列表。 是 scheduledtasks 显示应用程序中的计划任务。 是 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用。 是 shutdown 允许应用程序正常关闭。 没有 threaddump 执行线程转储。 是 二、启用端点默认情况下，除了shutdown之外的端点都会被启用，可以通过management.endpoint.&lt;id&gt;.enabled来启用或禁止某个端点，以下示例启用shutdown端点 1management.endpoint.shutdown.enabled = true 三、暴露端点端点启用了，要想访问还得通过配置来暴露端点。web端默认暴露的就是health和info其他都不会被暴露。 可以通过include和exclude来配置 include属性列出了公开的端点的ID。该exclude 属性列出了不应公开的端点的ID。该exclude 属性优先于该include属性。 *可用于选择所有端点。例如，要通过HTTP公开除了env和beans端点之外的所有内容，请使用以下属性： 12management.endpoints.web.exposure.include = *management.endpoints.web.exposure.exclude = env，beans 四、Demo pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 全局配置文件application.properties 1234#默认端点都是激活的除了shutdownmanagement.endpoint.shutdown.enabled=true#默认端点只有health和info暴露，可以使用如下所示暴露所有端点management.endpoints.web.exposure.include=* 启动应用，测试http://localhost:8080/actuator/beans返回所有Spring容器中所有bean的信息 通过post请求shutdown远程关闭应用 设置访问端点的前缀（默认是actuator）：management.endpoints.web.base-path=/manage 设置访问端点的端口：management.server.port=9000 通过management.endpoints.web.path-mapping.&lt;id&gt;的方式来自定义某个端点的访问路径 下面例子展示了自定义beans端点的访问路径 1management.endpoints.web.path-mapping.beans=mybean 五、自定义健康指示器1、默认的健康指示器 显示健康具体信息，默认不会 显示 management.endpoint.health.show-details=always 在org.springframework.boot.actuate包下面有很多SpringBoot为我们写好的指示器，比如Rabbit的，Redis的，只要引入了对应的starter这些指示器就会生效 引入redis的starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 我启动虚拟机上的redis，并指定虚拟机的ip，这时候再访问http://localhost:8080/actuator/health就显示了UP，启用状态。这样我们在生产环境中，就可以通过http的方式知道我们环境中的某些组件的运行事健康状态 2、自定义健康指示器 实现HealthIndicator接口 1234567891011121314@Componentpublic class MyAppHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; //可以通过自己的业务逻辑来确定健康状态 long currentTime = System.currentTimeMillis(); if (currentTime % 2 == 0) &#123; return Health.up().withDetail(\"success\", \"健康\").build(); &#125; else &#123; return Health.down().withDetail(\"Error Msg\", \"You'll never start it, hahaha!\").build(); &#125; &#125;&#125; 访问http://localhost:8080/actuator/health出现自定义的指示器健康状态","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习14_热部署","slug":"2019-04-13-SpringBoot学习14_热部署","date":"2019-04-13T14:31:00.000Z","updated":"2019-05-23T04:43:23.990Z","comments":true,"path":"2019/04/13/2019-04-13-SpringBoot学习14_热部署/","link":"","permalink":"http://yoursite.com/2019/04/13/2019-04-13-SpringBoot学习14_热部署/","excerpt":"","text":"在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 1、模板引擎–在Spring Boot中开发情况下禁用模板引擎的cache –页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring LoadedSpring官方提供的热部署程序，实现修改类文件的热部署 –下载Spring Loaded（项目地址&lt;https://github.com/spring-projects/spring-loaded&gt;） –添加运行时参数； -javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify 3、JRebel收费的一个热部署软件 安装插件使用即可 4、Spring Boot Devtools（推荐） 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; IDEA使用ctrl+F9 或做一些小调整 Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Linux用户管理","slug":"2019-04-09-Linux用户管理","date":"2019-04-09T14:22:00.000Z","updated":"2019-05-23T04:41:19.275Z","comments":true,"path":"2019/04/09/2019-04-09-Linux用户管理/","link":"","permalink":"http://yoursite.com/2019/04/09/2019-04-09-Linux用户管理/","excerpt":"","text":"一、Linux用户配置文件Linux配置文件是非常多的，这里只说四个重要的 /etc/passwd用户信息文件 /etc/shadow 影子文件 /etc/group组信息文件 /etc/gshadow组密码文件 1、用户信息文件​ /etc/passwd 用户管理简介: 越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范，在linux中主要是通过用户配置文件来查看和修改用户信息。 初始组和附加组说明： 初始组：用户已登录就拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用 户名相同的组名作为这个用户的初始组 附加组：之后用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。 /etc/passwd设置 以第一行的root用户来举例说明 root:x:0:0:root:/root:/bin/bash 第一字段：用户名称 第二字段：密码标志（centos6和centos7无意义了） 第三字段：UID（用户ID） ​ 0：超级用户 ​ 1-499： 系统用户(伪用户;Linux系统自带的很多软件都需要系统用户来支持启动，但是这些系统 ​ 户是不能用来登陆的) ​ 500-65535：普通用户 第四字段：GID（用户初始组ID） 第五字段：用户说明（默认就是用户名，也可以自己修改） 第六字段：家目录 ​ 普通用户：/home/用户名/ ​ 超级用户：/root/ 第七字段：登录之后的shell 123456789101112131415161718192021222324252627 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 4 adm:x:3:4:adm:/var/adm:/sbin/nologin 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin10 operator:x:11:0:operator:/root:/sbin/nologin11 games:x:12:100:games:/usr/games:/sbin/nologin12 ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin13 nobody:x:99:99:Nobody:/:/sbin/nologin14 avahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologin15 systemd-bus-proxy:x:999:997:systemd Bus Proxy:/:/sbin/nologin16 systemd-network:x:998:996:systemd Network Management:/:/sbin/nologin17 dbus:x:81:81:System message bus:/:/sbin/nologin18 polkitd:x:997:995:User for polkitd:/:/sbin/nologin19 tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin20 postfix:x:89:89::/var/spool/postfix:/sbin/nologin21 sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin22 dockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologin #下面是自己添加的用户23 zhangsan:x:1000:1000::/home/zhangsan:/bin/bash24 lisi:x:1001:1001::/home/lisi:/bin/bash25 testuser:x:1002:1002:test user:/home/testuser:/bin/bash 2、影子文件​ /etc/shadow ​ 第一字段：用户名 ​ 第二字段：加密密码 ​ 加密算法为SHA512散列加密算法 ​ 如果密码位是”!!”（代表锁定了）或者”*”（代表没有密码），不能登录 ​ 第三字段：密码最后一次修改日期 ​ 使用1970年1月1日作为标准时间，每过一天时间戳+1 ​ 第四字段：两次密码的修改最小间隔时间（和第三个字段相比） ​ 第五字段：密码有效期限（和第三个字段相比） ​ 第六字段：密码修改到期前的警告天数（和第五个字段相比） ​ 第七字段：密码过期后的宽限天数(和第五个字段相比) ​ 0：代表密码过期后立即失效 ​ -1：代表密码永远不失效 ​ 第八字段：账号失效时间 ​ 要用时间戳表示 ​ 第九字段：保留 1234567891011121314151617181920212223242526272829 1 root:$6$VsE.SDFhC2LG1zie$H60peSW6Oz1gwsw3pXpGnRvKjrmEvEHKhdQky8tkBNGcY6AKY6A2H2Sffj RItQKSL/8f1gNwATEC/HIDxX9H01::0:99999:7::: 2 bin:*:16659:0:99999:7::: 3 daemon:*:16659:0:99999:7::: 4 adm:*:16659:0:99999:7::: 5 lp:*:16659:0:99999:7::: 6 sync:*:16659:0:99999:7::: 7 shutdown:*:16659:0:99999:7::: 8 halt:*:16659:0:99999:7::: 9 mail:*:16659:0:99999:7:::10 operator:*:16659:0:99999:7:::11 games:*:16659:0:99999:7:::12 ftp:*:16659:0:99999:7:::13 nobody:*:16659:0:99999:7:::14 avahi-autoipd:!!:17941::::::15 systemd-bus-proxy:!!:17941::::::16 systemd-network:!!:17941::::::17 dbus:!!:17941::::::18 polkitd:!!:17941::::::19 tss:!!:17941::::::20 postfix:!!:17941::::::21 sshd:!!:17941::::::22 dockerroot:!!:17941::::::23 zhangsan:$6$pijbttcg$pQY0lCT61hJh9FrwlBdZIhP1KxJk21keQ/ER0DsIlsg8oF015pvlddzMNHAnJB.C KiziCIdmH3TqFRzaHWrd60:17995:0:99999:7:::24 lisi:$6$LgAqOmYD$38l9NI1L6BWYjETiu0Z9Sia8fh5qDwJ0M8sG39gNXlvSVq3wQkjWkpeLZBsU.QHbkOV7 1FiqDQPzZxhDxsPlB/:17995:0:99999:7:::25 testuser:$6$wkev.JGc$12ipqH//xtXVZWEezuuPH8wPYisoaRLHSDxrSiyzP.2VUQ9I5DzR0DGy9Zr0yfjC FCOw9T.eoKHlc.DhL1LEw.:17995:0:99999:7::: ​ 时间戳换算方式 ​ 把时间戳换算成日期[17991] 1date -d \"1970-01-01 [时间戳] days\" ​ 把日期换算成时间戳 1echo $(($(date --date=\"2016/01/06\" +%s)/86400+1)) 3、组信息文件​ /etc/group ​ 第一字段：组名 ​ 第二字段：组密码标志(拥有组密码的用户，可以往组里添加或者删除用户) ​ 第三字段：GID（组id） ​ 第四字段：组中附加用户(例如 root组中的有testuser用户) 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 root:x:0:testuser 2 bin:x:1:testuser 3 daemon:x:2: 4 sys:x:3: 5 adm:x:4: 6 tty:x:5: 7 disk:x:6: 8 lp:x:7: 9 mem:x:8:10 kmem:x:9:11 wheel:x:10:12 cdrom:x:11:13 mail:x:12:postfix14 man:x:15:15 dialout:x:18:16 floppy:x:19:17 games:x:20:18 tape:x:30:19 video:x:39:20 ftp:x:50:21 lock:x:54:22 audio:x:63:23 nobody:x:99:24 users:x:100:25 avahi-autoipd:x:170:26 utmp:x:22:27 utempter:x:35:28 ssh_keys:x:999:29 input:x:998:30 systemd-journal:x:190:31 systemd-bus-proxy:x:997:32 systemd-network:x:996:33 dbus:x:81:34 polkitd:x:995:35 dip:x:40:36 tss:x:59:37 postdrop:x:90:38 postfix:x:89:39 sshd:x:74:40 cgred:x:994:41 dockerroot:x:993:42 docker:x:992:43 zhangsan:x:1000:44 lisi:x:1001:45 testuser:x:1002: 4、组密码文件​ /etc/gshadow ​ 第一字段：组名 ​ 第二字段：组密码 ​ 第三字段：组管理员用户名 ​ 第四字段：组中附加用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 root:::testuser 2 bin:::testuser 3 daemon::: 4 sys::: 5 adm::: 6 tty::: 7 disk::: 8 lp::: 9 mem:::10 kmem:::11 wheel:::12 cdrom:::13 mail:::postfix14 man:::15 dialout:::16 floppy:::17 games:::18 tape:::19 video:::20 ftp:::21 lock:::22 audio:::23 nobody:::24 users:::25 avahi-autoipd:!::26 utmp:!::27 utempter:!::28 ssh_keys:!::29 input:!::30 systemd-journal:!::31 systemd-bus-proxy:!::32 systemd-network:!::33 dbus:!::34 polkitd:!::35 dip:!::36 tss:!::37 postdrop:!::38 postfix:!::39 sshd:!::40 cgred:!::41 dockerroot:!::42 docker:!::43 zhangsan:!::44 lisi:!::45 testuser:!:: 二、LINUX用户相关命令 查看当前登录用户 whoami 12[root@localhost network-scripts]# whoamiroot 查看用户ID，组ID，所在的组 id [用户名] 12[root@localhost network-scripts]# id rootuid=0(root) gid=0(root) groups=0(root) 用户添加命令 useradd [选项] 用户名 -u ：手工指定用户的UID号 -d ：手工指定用户的家目录 -c ：手工指定用户的说明 -g ：手工指定用户的初始组 -G ：手工指定用户的附加组 -s ：手工指定用户的登录shell。默认是/bin/bash eg：（一般不会使用这些选项，Linux中默认设置的就是最好的） 1useradd -G root,bin -d /home/testuser -c \"test user\" -s /bin/bash testuser 查看组信息 groups ：查看当前登录用户所在的组（很多博客都是说查看当前登录用户的组内成员，测试并不是，man查看了下才知道自己测试的是对的） groups test ：查看test用户所在的组以及还存在于哪些组中 用户添加命令默认设置 ​ /etc/default/useradd ​ GROUP=100 #用户默认组 ​ HOME=/home #用户家目录 ​ INACTIVE=-1 #密码过期宽限时间（shadow文件7字段） ​ EXPIRE= #密码失效时间(8) ​ SHELL=/bin/bash #默认shell ​ SKEL=/etc/skel #默认模板 ​ CREATE_MAIL_SPPPL=yes #是否建立邮箱 修改用户密码 ​ passwd [选项] 用户名 ​ -S 查询用户密码的状态（仅root用户可以） ​ -l 暂时锁定用户（仅root用户可以） ​ -u 解锁用户（仅root用户可以） ​ eg： 12[root@localhost ~]# passwd -S testusertestuser PS 2019-04-09 0 99999 7 -1 (Password set, SHA512 crypt.) ​ 密码修改间隔时间(0) ​ 密码有效期(99999) ​ 警告时间(7) ​ 密码不失效(-1) ​ eg：passwd -l 用户 ​ 锁定原理为在shadow文件中，用户第二个字段前加上”!!”号 删除用户 userdel [选项] [用户名] -r 删除用户的同时删除用户家目录 ​ 删除原理是：删除了以下文件中的用户信息 ​ /etc/passwd ​ /etc/shadow ​ /etc/group ​ /etc/gshadow ​ /home/sc ​ /var/spool/mail/sc 切换用户 su [用户名] eg: 123[root@localhost ~]# su testuser[testuser@localhost root]$ whoamitestuser 切换时连用户的环境变量一同切换 直接使用su 用户 切换模式只切换了用户，但是没有切换用户变量，所以要想把用户和环境变量一起改变的话，需要使用su - root 命令形式。可以使用echo $PATH查看两者的区别 添加组 groupadd [选项] [组名] -g GID：指定组ID（最好不要指定，这样可能导致Linux处理组的时候发生异常） 删除组 groupdel [组名] 删除组的时候需要注意，如果组中有初始用户则不能删除这个组，可以通过删除这个用户，再删除组。 把用户添加入组或从组中删除(操作对象是附加用户) gpasswd [选项] [用户] [组名] -a ：把用户加入组 -d ：把用户从组中删除 eg：把testuser用户添加进root组 12[root@localhost ~]# gpasswd -a testuser rootAdding user testuser to group root eg：把testuser用户从root组中删除 12[root@localhost ~]# gpasswd -d testuser rootRemoving user testuser from group root 可以进入/etc/group验证 或者通过grep testuser /etc/group命令查看变化 注：其实Linux中很多指令原理都是帮我们操作文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Spring Boot学习07_自定义starter","slug":"2019-04-05-SpringBoot学习07_自定义starter","date":"2019-04-04T16:21:00.000Z","updated":"2019-05-23T04:39:07.479Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习07_自定义starter/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习07_自定义starter/","excerpt":"","text":"​ 查看Spring Boot的源码，starter包并没有真正的代码，代码都在autoconfigurer包中，所以我也可以照葫芦画瓢，创建一个starter项目和一个autoconfigurer项目，在autoconfigurer项目中写自动配置类，在starter项目中依赖autoconfigurer项目，到时候别人用就直接引入starter的坐标就能使用我自定义的starter了 Mybatis的starter与autoconfigurer也是自己写的，所以我们的命名方式可以根据它这样来定义为ahead-spring-boot-starter，ahead-spring-boot-starter-autoconfigurer 1、创建一个普通的maven工程，打包方式为jar，名称为ahead-spring-boot-starter 2、创建一个Spring boot应用，命名为ahead-spring-boot-starter-autoconfigurer，不需要添加任何组件，只保留默认的spring-boot-starter依赖就行，删除自带的maven插件，最终的pom文件如下 3、编写自定义的starter 我在前面就写过SpringBoot的配置原理，通过全局配置文件中的值与xxxProperties属性映射并添加到组件中去，在配置类中就能获取到xxxProperties对象并获取其中的属性值设置给某些组件的属性，最后在classpath路径下的META-INF文件夹下的spring.factories文件中指定需要自动配置的类，就会被SpringBoot读取到，达到了自动配置的效果 3.1、创建HelloProperties类并指定与全局配置文件中的那个下面的属性进行映射 3.2、编写HelloService组件 3.3、编写HelloAutoConfiguration自动配置类，并注册HelloService组件 3.4、在classpath下的META-INF文件夹下的spring.factories文件指定要自动配置的类（之前用@Configuration注解标注的配置类因为在Spring Boot主配置类的扫描范围内，而这里的扫描不到，就需要在文件中指定自动配置类的位置，这样Spring Boot就能获取到） 3.5、在starter项目中引入autoconfigurer项目的坐标，并通过maven命令先打包 ahead-spring-boot-starter-autoconfigurer项目在打包ahead-spring-boot-starter项目 4、编写一个Spring Boot应用进行测试 4.1、引入自定义的starter 4.2、在全局配置文件中指定HelloProperties中的name属性值 4.3、编写HelloController并启动应用通过浏览器访问测试。 4.4、自动配置成功","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_外部Servlet容器启动原理","slug":"2019-04-04-SpringBoot学习04_外部Servlet容器启动原理","date":"2019-04-04T15:29:00.000Z","updated":"2019-05-23T04:35:18.726Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器启动原理/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器启动原理/","excerpt":"","text":"1、创建使用外部Servlet容器的Spring Boot的项目，会多一个类。 2、通过外部的tomcat的启动时会发现先启动tomcat，然后就会启动之前Spring Boot的主配置类程序。 3、在Servlet3.0的有几个规范 服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例 ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名** 还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；** 该文件就在spring-web包下 4、在应用启动时就会加载web应用里面每一个jar包里面ServletContainerInitializer实例中的onStartup方法 这里会获得感兴趣的类的实例并遍历调用它们的onStartup方法 5、在ServletContainerInitializer的实现类SpringServletContainerInitializer上有个@HandlesTypes({WebApplicationInitializer.class})，WebApplicationInitializer就是我们感兴趣的类，查看WebApplicationInitializer接口的子类发现就有我们上面比嵌入式Servlet容器的Spring Boot项目多余出来的ServletInitializer类 6、而我们这个类没有onStartUp方法，进入它父类找到onStartUp方法 主要就是这个createRootApplicationContext方法，我们进入这个方法 7、configure方法ServletInitializer类有这个方法，所以就会调用自己的configure方法，传进去的参数是当前项目的主配置类 8、最后构建出一个SpringApplication对象并调用run方法跑起来。 9、而run方法一路点过去，会发现到了之前我们主配置类启动时调用的run方法，最终我们的SpringBoot应用就启动起来了。 总结：在外部的Servlet的容器启动的时候因为Servlet3.0有个规则就会加载所有感兴趣类中的onStartUp方法，然后调用我们多出来的ServletInitializer类的Configure方法，把当前项目的主配置类传进去，创建出SpringApplication对象并启动SpringBoot应用。最终项目就是tomcat先启动，然后再是Spring Boot项目启动，当然Spring Boot中的功能是一样能用的","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_外部Servlet容器JSP支持","slug":"2019-04-04-SpringBoot学习04_外部Servlet容器JSP支持","date":"2019-04-04T15:23:00.000Z","updated":"2019-05-23T04:35:07.904Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器JSP支持/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器JSP支持/","excerpt":"","text":"Spring Boot的嵌入式的Servlet容器虽然方便，快捷，支持jar包的方式运行项目 但是却是不能支持jsp的，这时候我们可以使用外部的Servlet容器。 1、新建一个Module，然后next 2、项目的坐标，这里要改成war包，下一步 3、选中web模块，然后next，再finish完成项目的创建 4、但是我们项目中并没有webapp，不需要自己创建，可以通过ide来自动创建 5、选中项目按f4或右键open module setting，点击web 6、点击右边的添加 7、把地址修改成如下图，点击ok，然后apply 8、点击右上角的添加选中web.xml 9、修改地址如下，版本也是可以选择的，点击ok，apply，ok，关闭 10、创建hello.jsp，这时候需要添加tomcat容器(自行添加)，部署项目到tomcat容器上，访问成功","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_嵌入式Servlet容器启动原理","slug":"2019-04-04-SpringBoot学习04_嵌入式Servlet容器启动原理","date":"2019-04-04T15:13:00.000Z","updated":"2019-05-23T04:35:32.406Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习04_嵌入式Servlet容器启动原理/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习04_嵌入式Servlet容器启动原理/","excerpt":"","text":"注：看完这一篇再回头看上一篇就会理解了 上一篇文章解释了嵌入式Servlet容器的默认配置和修改配置的原理，但其前提条件是创建嵌入式Servlet容器工厂。下面就进行debug解释嵌入式Servlet容器是怎么启动的。 1、来到ServletWebServerFactoryConfiguration类给组件TomcatServletWebServerFactory打上断点。再来到TomcatServletWebServerFactory类上给getWebServer方法打上断点并debug运行 2、先是创建好一个Spring Boot应用并启动项目 3、刷新容器 4、进入createApplicationContext方法看容器怎么创建的 会判断当前项目是否为web项目，然后创建一个web的IOC容器， 5、一直调用，来到真正的代码逻辑上。(刷新刚才创建好的容器，都是一些初始化方法) 6、下一步来到了获取嵌入式的Servlet容器工厂中，IOC容器机制就是有人需要时我才会通过注册的组件创建对象返回给你，这里需要获取容器工厂。 7、一旦需要获取容器工厂了，IOC容器就会创建TomcatServletWebServerFactory（ServletWebServerFactory的子类）对象，它一创建就会惊动bean注册后置处理器（BeanPostProcessorsRegistrar），就会调用所有的定制器定制Servlet容器的相关配置。(上一篇文章详解了地址) 8、不重要的不看，直接放行 这一步就会通过嵌入式的Servlet容器工厂获得嵌入式的Servlet容器 9、最终来到这里创建Tomcat容器并进行初始化一些值，getTomcatWebServer中会启动Tomcat(上一篇文章详解了地址)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Linux文本编辑器vi/vim","slug":"2019-04-02-Linux文本编辑器vim","date":"2019-04-02T10:20:00.000Z","updated":"2019-05-23T04:34:53.632Z","comments":true,"path":"2019/04/02/2019-04-02-Linux文本编辑器vim/","link":"","permalink":"http://yoursite.com/2019/04/02/2019-04-02-Linux文本编辑器vim/","excerpt":"","text":"只会总结常用命令，不常用的文档就行 一、介绍1、Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 2、二者的区别 vi：相当于普通文本打开，默认Linux系统自带 vim：相当于一个IDE，如果有特殊的代码或者关键字会有不同颜色的显示（没有自带，使用 yum -y install vim 安装） 3、vim 键盘图： 二、vi/vim工作模式vi/vim工作分为三种模式：命令模式、输入模式、底线命令模式 1、命令模式：用户刚刚启动 vi/vim，便进入了命令模式。该模式下等待用户做出进一步的指令，进入输入模式或底线模式。 输入模式快捷键 i 切换到插入模式，并在当前光标位置之前开始插入 I 将光标移至当前行的开头位置，并切换到插入模式 a 切换到插入模式，并在当前光标位置之后开始插入 A 将光标移至当前行的结尾位置，并切换到插入模式 o 在当前行的下方新打开一个行，并切换至插入模式 O 在当前行的上方新打开一个行，并切换至插入模式 r 替换当前光标所在位置的字符 R 从当前光标所在位置开始替换输出后面的内容，按ESC结束 D 删除光标所在处到行尾的内容 gg 跳转到文档第一行 G 跳转到文档到最后一行 x 删除光标所在位置的字符 yy 复制当前行 P 粘贴到当前行的上面（大写） p 粘贴到当前行的下面（小写） u 取消上一步操作 2、输入模式编辑模式，即进入文本编辑模式。 3、底线命令模式底线命令模式可以输入单个或多个字符的命令，调用不同的VI编辑功能，可用的命令多样。 底线命令模式功能 :set nu 设置行号** :set nonu 设置取消行号 :n 前往某一行 :wq 保存修改并且退出 :q! 不保存修改退出 /string 在文件中所搜制定字符串string n 查看字符串上一个出现的位置 N查看字符串上一个出现的位置 4、vim默认的初始化设置通过编辑”/root/.vimrc”文件可以设置vim编辑器初始化的一些设置 例如在改文件中输入该命令保存退出：:set nu 默认使用vim进入文件编辑就会显示行号了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Linux课堂之网络命令详解","slug":"2019-03-29-Linux课堂之网络命令详解","date":"2019-03-29T03:14:00.000Z","updated":"2019-05-23T04:34:41.071Z","comments":true,"path":"2019/03/29/2019-03-29-Linux课堂之网络命令详解/","link":"","permalink":"http://yoursite.com/2019/03/29/2019-03-29-Linux课堂之网络命令详解/","excerpt":"","text":"一、网络相关命令1、用ping命令测试Linux是否联网ping[选项] [网址/ip] ping 网址还是会被解析成 ip 地址 选项：-c n Linux中 ping 默认是无限 ping ，可以使用 -c选择设置 ping 的次数，如果不使用 -c选项，无限 ping 可以使用 Ctrl + c 退出 eg：使用 ping -c 3 www.baidu.com 命令 ping 百度3次 123456789[root@localhost ~]# ping -c 3 www.baidu.comPING www.a.shifen.com (183.232.231.172) 56(84) bytes of data.64 bytes from localhost (183.232.231.172): icmp_seq=1 ttl=128 time=65.8 ms64 bytes from localhost (183.232.231.172): icmp_seq=2 ttl=128 time=104 ms64 bytes from localhost (183.232.231.172): icmp_seq=3 ttl=128 time=79.6 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2026msrtt min/avg/max/mdev = 65.831/83.310/104.460/15.985 ms 2、使用 ip addr 查看网卡信息eno16777736：网卡代号 inet 192.168.35.157： ip地址inet6：IPv6的地址，还不怎么普及 lo：loop设备的意思，地址是127.0.0.1即本机回送地址 12345678910111213[root@localhost ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:11:08:1f brd ff:ff:ff:ff:ff:ff inet 192.168.35.157/24 brd 192.168.35.255 scope global noprefixroute eno16777736 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe11:81f/64 scope link valid_lft forever preferred_lft forever 3、traceroute [网址] 显示本机到目标网址的路径traceroute [网址] 1234567891011[root@instance-y2jixxt2 ~]# traceroute www.baidu.comtraceroute to www.baidu.com (220.181.112.244), 30 hops max, 60 byte packets 1 10.166.49.30 (10.166.49.30) 1.129 ms 1.592 ms 10.166.49.20 (10.166.49.20) 1.076 ms 2 10.166.13.127 (10.166.13.127) 6.982 ms 7.031 ms 10.166.14.127 (10.166.14.127) 4.317 ms 3 10.166.97.3 (10.166.97.3) 0.911 ms 10.166.97.5 (10.166.97.5) 0.880 ms 10.166.97.1 (10.166.97.1) 0.957 ms 4 10.166.50.4 (10.166.50.4) 9.345 ms 10.166.50.2 (10.166.50.2) 0.925 ms 10.166.50.6 (10.166.50.6) 0.925 ms 5 182.61.253.22 (182.61.253.22) 3.570 ms 182.61.253.20 (182.61.253.20) 3.543 ms 182.61.253.30 (182.61.253.30) 3.537 ms 6 192.168.0.33 (192.168.0.33) 3.044 ms 192.168.0.29 (192.168.0.29) 2.959 ms 2.885 ms 7 10.34.238.245 (10.34.238.245) 3.278 ms 3.267 ms * 8 * * * 9 * * * 4、查看网络状态netstat [选项] -t TCP 协议 -u UDP 协议 -l 监听 -r 路由 -n 显示 ip地址和端口号 常用的组合 4.1、netstat -tlun查看端口信息 4.2、netstat -an 查看本地所有网络连接 4.3、netstat -rn 查看本地路由网关 二、扩展命令5、finger [用户名] 查看用户信息eg：查看 root 用户信息 12345678910[root@localhost ~]# finger root#登录名 #用户名Login: root Name: root#用户所拥有的路径 #使用bash shellDirectory: /root Shell: /bin/bash#什么时候开机的On since Fri Mar 29 08:38 (CST) on pts/0 from 192.168.25.1 3 seconds idleNo mail.No Plan. finger 相当于 env env：查看当前用户的环境信息 1234567891011121314151617181920212223242526[root@localhost ~]# envXDG_SESSION_ID=1HOSTNAME=localhost.localdomainSELINUX_ROLE_REQUESTED=TERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=192.168.25.1 9652 22SELINUX_USE_CURRENT_RANGE=SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:MAIL=/var/spool/mail/rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/binPWD=/rootLANG=en_US.UTF-8SELINUX_LEVEL_REQUESTED=HISTCONTROL=ignoredupsSHLVL=1HOME=/rootLOGNAME=rootSSH_CONNECTION=192.168.25.1 9652 192.168.25.157 22LESSOPEN=||/usr/bin/lesspipe.sh %sXDG_RUNTIME_DIR=/run/user/0_=/usr/bin/envOLDPWD=/home 6、echo输出命令1、eg：打印字符串输出到控制台中 echo &quot;aaa&quot; 12[root@localhost ~]# echo \"aaa\"aaa 2、echo [信息] &gt;&gt; [文件名] ：追加内容到文件后面 ​ echo [信息] &gt; [文件名]：将内容覆盖文件中原有的内容 eg：通过echo bb &gt;&gt; a.txt 将字符串 bb 追加到 a.txt 文件中 123456789#a.txt文件中本来就有aa字符串[root@localhost study-linux]# cat a.txtaa#使用echo命令追加[root@localhost study-linux]# echo bb &gt;&gt; a.txt#查看a.txt文件中的内容发现bb已经追加到aa后面了[root@localhost study-linux]# cat a.txtaabb eg：通过 echo cc &gt; a.txt 将字符串 cc 覆盖 a.txt原有的内容 123456[root@localhost study-linux]# cat a.txtaabb[root@localhost study-linux]# echo cc &gt; a.txt[root@localhost study-linux]# cat a.txtcc 7、有关时间的命令date ：查看当前系统时间 eg： 12[root@localhost study-linux]# dateFri Mar 29 11:00:00 CST 2019 man date：查看帮助文档发现可以通过 date 加上格式就可以修改系统默认时间 MMDDhhmmCCYY.ss ===&gt; 月/日/时/分/公元/年/.秒 1234567891011121314151617181920212223DATE(1) User Commands DATE(1)NAME date - print or set the system date and timeSYNOPSIS date [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION Display the current time in the given FORMAT, or set the system date. Mandatory arguments to long options are mandatory for short options too. -d, --date=STRING display time described by STRING, not 'now' -f, --file=DATEFILE like --date once for each line of DATEFILE -I[TIMESPEC], --iso-8601[=TIMESPEC] output date/time in ISO 8601 format. TIMESPEC='date' for date only (the default), 'hours', 'minutes', 'seconds', or 'ns' for date and time to the indicated precision. eg：修改系统默认时间为2020年1月1号12时24分48秒 1234[root@localhost study-linux]# date 010112242020.48Wed Jan 1 12:24:48 CST 2020[root@localhost study-linux]# dateWed Jan 1 12:24:49 CST 2020 cal：日历 eg：cal -y 2019 查看2019年的整年的日历 12345678910111213141516171819202122232425262728293031323334[root@localhost study-linux]# cal -y 2019 2019 January February March Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 1 2 1 2 6 7 8 9 10 11 12 3 4 5 6 7 8 9 3 4 5 6 7 8 913 14 15 16 17 18 19 10 11 12 13 14 15 16 10 11 12 13 14 15 1620 21 22 23 24 25 26 17 18 19 20 21 22 23 17 18 19 20 21 22 2327 28 29 30 31 24 25 26 27 28 24 25 26 27 28 29 30 31 April May June Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 1 2 3 4 1 7 8 9 10 11 12 13 5 6 7 8 9 10 11 2 3 4 5 6 7 814 15 16 17 18 19 20 12 13 14 15 16 17 18 9 10 11 12 13 14 1521 22 23 24 25 26 27 19 20 21 22 23 24 25 16 17 18 19 20 21 2228 29 30 26 27 28 29 30 31 23 24 25 26 27 28 29 30 July August September Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 1 2 3 1 2 3 4 5 6 7 7 8 9 10 11 12 13 4 5 6 7 8 9 10 8 9 10 11 12 13 1414 15 16 17 18 19 20 11 12 13 14 15 16 17 15 16 17 18 19 20 2121 22 23 24 25 26 27 18 19 20 21 22 23 24 22 23 24 25 26 27 2828 29 30 31 25 26 27 28 29 30 31 29 30 October November December Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 1 2 1 2 3 4 5 6 7 6 7 8 9 10 11 12 3 4 5 6 7 8 9 8 9 10 11 12 13 1413 14 15 16 17 18 19 10 11 12 13 14 15 16 15 16 17 18 19 20 2120 21 22 23 24 25 26 17 18 19 20 21 22 23 22 23 24 25 26 27 2827 28 29 30 31 24 25 26 27 28 29 30 29 30 31 eg：cal 3 2019 查看2019年3月的整月的日历 123456789[root@localhost study-linux]# cal 3 2019 March 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 3031 8、设置别名命令alias：查看系统所有被设置别名的命令 eg：alias al = ’ls -i‘ 设置ls -i 命令的别名为al （重启后失效） 123[root@localhost study-linux]# alias al='ls -i'[root@localhost study-linux]# al24560 a.txt 9、帮助文档命令man [命令名称] help [命令名称] 只能查看Linux内部命令（不是外部额外安装的）， 使用 type [命令] 查看是否为内部命令 whereis [命令]：查看命令文件信息（查看到命令安装路径、查看到命令帮助文档的安装路径） which[命令]：只能查看到命令的安装路径","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Spring Boot学习04_嵌入式Servlet容器自动配置原理","slug":"2019-03-28-SpringBoot学习04_嵌入式Servlet容器自动配置原理","date":"2019-03-28T14:38:00.000Z","updated":"2019-05-23T04:33:52.757Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器自动配置原理/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器自动配置原理/","excerpt":"","text":"在Spring Boot的自动配置包下，找到web模块中的servlet文件夹下的ServletWebServerFactoryConfiguration类 一、嵌入式Servlet容器默认的配置原理1、该类中有三个静态内部类（都是配置类）： EmbeddedUndertow、EmbeddedJetty、EmbeddedTomcat 这里拿EmbeddedTomcat来举例说明 @ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class}) 判断classpath下有没有Servlet, Tomcat, UpgradeProtocol这三个类，也就是看maven有没有引入对应的依赖，如果引入了对应的依赖，下面的配置就生效。（上一篇文章SpringBoot切换嵌入式容器就是根据这里来的链接） 2、@ConditionalOnMissingBean(value = {ServletWebServerFactory.class},search = SearchStrategy.CURRENT) 如果容器中没有ServletWebServerFactory这个组件下面的配置就生效 点进ServletWebServerFactory看，该接口只有一个方法，前面只判断这个类型的组件有没有在容器中，而该类型又只有一个方法，说明最终Spring Boot会调用该接口实现类中的getWebServer方法。 3、查看ServletWebServerFactory接口的实现，有三个很面熟的实现类，就是上面ServletWebServerFactoryConfiguration类中要往容器中添加的组件 4、进入TomcatServletWebServerFactory类中查看getWebServer方法 首先会创建一个Tomcat对象，给其设置连接器等一些配置 最终还会调用getTomcatWebServer方法 this.getTomcatWebServer(tomcat); –&gt;return new TomcatWebServer(tomcat, this.getPort() &gt;= 0); 端口号默认是8080所以上面传过去的是true，进入TomcatWebServer的构造方法TomcatWebServer中，在构造方法中又调用了this.initialize();进入initialize方法，该方法就会启动tomcat。(所以这一切都是建立在创建好嵌入式Servlet容器之后) 二、修改SpringBoot初始化嵌入式Servlet容器的默认配置原理上一篇文章（链接）中我们自己配置个WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;组件就可以实现修改SpringBoot初始化嵌入式Servlet容器的默认配置了，下面开始说怎么修改其默认配置的。 在ServletWebServerFactoryAutoConfiguration类上面有 @EnableConfigurationProperties，@Import注解 1、@EnableConfigurationProperties({ServerProperties.class}) 把ServerProperties注册到容器中，并读取全局配置文件中的数据赋值给类中的属性。 只有一个有参构造，形参的值(serverProperties)会从容器中获取，最终交给ServletWebServerFactoryCustomizer类，进入ServletWebServerFactoryCustomizer类 该类也是WebServerFactoryCustomizer的子类 里面有个customize方法会把从容器中获取到的servlerProperties中的值拿出来然后一个一个的设置给factory，最后交给那个map。 2.1、通过@Import往容器中导入了一个BeanPostProcessorsRegistrar类，该类中的作用是 bean注册后置处理器：Bean初始化前后（创建好对象，还没赋值）执行初始化工作(容器中某个组件要创建bean，就会惊动后置处理器，容器中要创建bean这个才会触发，下面的方法才会被调用) 2.2、进入BeanPostProcessorsRegistrar类查看registerBeanDefinitions方法(注册bean的定义)，然后调用registerSyntheticBeanIfMissing方法 2.3、我们点进WebServerFactoryCustomizerBeanPostProcessor类中只需要看postProcessBeforeInitialization方法，在bean创建好之后，初始化之前的调用的方法，该方法首先会判断当前的bean如果为WebServerFactory类型（我们前面需要往容器中注册三个嵌入式Servlet容器就是该接口的实现类，所以当前这个bean就是嵌入式的Servlet容器），就调用postProcessBeforeInitialization方法 2.4、进入postProcessBeforeInitialization方法，该方法会获得所有的定制器，然后遍历，调用每个定制器的customize方法，并把嵌入式的Servlet容器传进去。 上一篇文章（链接）中我们修改嵌入式的Servlet容器的配置也是往容器中添加一个WebServerFactoryCustomizer组件，并在其customize方法中修改配置。 在前面说到通过配置文件来修改配置也是在WebServerFactoryCustomizer的子类中重写了 customize方法，并在其customize方法中修改配置。 回到这里的postProcessBeforeInitialization方法，我们这里把嵌入式的Servlet容器传过去，调用所有定制器的customize方法，不就是调用的上面两种修改配置的重写后的customize方法吗，我们在重写后的customize方法中对参数进行设置值，就是对我们这里传过去的嵌入式Servlet容器设置值，最终通过全局配置文件中配置和往容器中添加一个WebServerFactoryCustomizer组件就可以达到修改嵌入式的Servlet容器的默认值了 往容器中添加一个WebServerFactoryCustomizer组件 前面说到的，经过一系列的逻辑最终全局配置文件中的值会在这里给嵌入式的Servlet容器进行赋值 注：看完这一篇文章要结合下一篇文章来理解","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_嵌入式Servlet容器基本API","slug":"2019-03-28-SpringBoot学习04_嵌入式Servlet容器基本API","date":"2019-03-28T14:32:00.000Z","updated":"2019-05-23T04:33:32.188Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器基本API/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器基本API/","excerpt":"","text":"一、嵌入式Servlet容器配置修改1、通过全局配置文件修改(application.properties/yml) 之前的文章说过自动配置原理(文章地址)，只要涉及到自动配置的一定是在xxxAutoConfiguration类中，而xxxAutoConfiguration类中自动配置的组件会在xxxProperties类中获取值，而xxxProperties类与全局配置文件中映射了，所以我们只需要在配置文件给对应的属性赋值就会被Spring Boot自动配置上。 在ServerProperties中有很多属性，还有很多静态内部类，这些我们都可以在全局配置文件中进行配置，比如服务的端口号，请求的项目路径等等。 这里测试端口号和项目路径 2、给容器中配置WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;组件，在匿名内部类中的customize方法里面设置 二、注册Servlet三大组件1、Servlet：往容器中注册一个ServletRegistration&lt;Servlet类名&gt; 2、Filter：往容器中注册一个FilterRegistrationBean&lt;Filter类名&gt; 3、Listener：往容器中注册一个ServletListenerRegistrationBean&lt;Listener类名&gt; 三、切换其他Servlet容器Spring Boot支持三种嵌入式Servlet容器，默认使用Tomcat 1、Tomcat 2、Jetty 3、Undertow 我们可以通过IDEA的依赖关系图来判断。由下面关系图可知，我们只要把对应的依赖排除，要使用哪种嵌入式Servlet容器只要添加对应的依赖就行了。 对应的Undertow也是一样的道理。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_自适应定制错误数据原理","slug":"2019-03-28-SpringBoot学习04_自适应定制错误数据原理","date":"2019-03-28T13:41:00.000Z","updated":"2019-05-23T04:34:25.418Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_自适应定制错误数据原理/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_自适应定制错误数据原理/","excerpt":"","text":"在我们访问Spring Boot应用的时候，出现譬如404，500的错误，默认会跳到如下页面 而做服务端的，浏览器并非为唯一客户端，还有安卓客户端app显示错误数据的方式，如下：（使用postman工具模拟安卓客户端app接受请求），Spring Boot会响应给安卓客户端json数据 这样的页面终归是不友好的，一般会自己定制页面或定制json数据（符合项目风格的错误页面） 前面的文章说了Spring Boot的自动配置一般都会在xxxAutoConfiguration类中 一、错误页面的自动配置在ErrorMvcAutoConfiguration类中1、该类中有个errorPageCustomizer方法，返回的类型是ErrorPageCustomizer（错误页面定制器），只要项目中出现4xx或者5xx错误就会执行该方法。 2、我们点进ErrorPageCustomizer类中查看registerErrorPages方法，而该方法呢会发送一个getPath()请求，最终获得是@Value(“${error.path:/error}”)，意思是从配置文件中获取error.path的值，如果没有就使用”/error”请求url 3、只要请求”/error”，那么在ErrorMvcAutoConfigutaion类中注册的BasicErrorController就会起作用了。 4、点进该类中查看发现该类就是映射”/error”请求的 5、该类中有两个方法errorHtml方法返回ModelAndView，这两个方法都能接收”/error”请求，error方法返回ResponseEntity也就是json数据，说明这两个方法对应的就是浏览器和客户端，errorHtml方法上的produces等于”text/html”，就是响应html类型的数据，而在浏览器中优先接受的就是该类型，客户端优先接受的是application/json类型，所以Spring Boot就能自适应返回不同的数据了 二、浏览器怎么定制错误页面(errorHtml方法)1、进入resolveErrorView方法，点进去 this.resolveErrorView(request, response, status, model); –&gt;resolver.resolveErrorView(request, status, model); 进入到ErrorViewResolver接口，该接口只有一个实现类，进入DefaultErrorViewResolver类中的resolveErrorView方法（DefaultErrorViewResolver也是在ErrorMvcAutoConfiguration类中进行注册了的） 2、resolveErrorView方法会调用resolve方法，会传入状态码和model(后面解释怎么来的)进去，SERIES_VIEWS中有4xx，5xx 3、进入到resolve方法，里面会拼一个视图名称”error/“ 加上传进来的状态码(4xx,5xx)， 这里会根据你的错误类型是什么就会拼成什么类型的视图名称。接着看下面有个方法判断有没有使用模板，如果使用了模板就直接把拼好的视图名称当作逻辑视图名称创建ModelAndView对象返回（使用了Thymeleaf模板，会有一个Thymeleaf视图解析器：前缀是classpath:templates/,后缀是html），如果没有就调用下面resolveResource方法 4、进入resolveResource方法里面的逻辑就是获得静态资源映射的路径(专栏前面的文章有详细讲过(链接))，然后跟传过来的视图名称拼起来并加上html后缀 5、最后说明我们只要把4xx，5xx命名html错误页面放在error文件夹下，然后把error文件夹放入templates文件夹下Spring Boot就会根据是什么类型的错误而跳转到指定的错误页面中。静态资源文件夹下的错误页面就不测试了，一定也是有用的 6、之前Spring Boot默认的错误处理页面中的数据是怎么获得的呢 回到errorHtml方法，点进getErrorAttributes方法 protected Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) –&gt;return this.errorAttributes.getErrorAttributes(webRequest, includeStackTrace); this.errorAttributes就是ErrorAttributes接口类型的，该类只有一个实现类DefaultErrorAttributes(在ErrorMvcAutoConfiguration类中在容器中注册了) 6.1、看getErrorAttributes方法中会创建一个Map，而下面的方法处理就是往该map中添加一些错误数据，比如status状态码，error错误提示信息，exception异常类型。添加完成之后将该Map返回作为model 6.2、所以我们在模板里面就能通过表达式取到错误信息了，异常必须在全局配置中设置项目中包含异常server.error.include-exception=true 7、Spring Boot默认的页面是怎么组成的呢 如果ModelAndView为空(说明自己在规定的路径中没有自定义错误页面)就自己创建一个ModelAndView，然后返回 7.1、在ErrorMvcAutoConfiguraion类中配置了一个组件name就是error，点进defaultErrorView（StaticView类型） 7.2、该类中有个视图渲染方法，就是一个组装好的html字符串和之前Spring Boot默认处理错误页面中的信息一样。 三、客户端怎么定制错误数据（error方法）1、error方法中获取Map数据也是和上面一样的逻辑，最后转换成一个json数据返回给安卓客户端 2、之前说了哪个数据的获得其实是在容器中获取一个ErrorAttributes类型的实例然后调用该实例的getErrorAttributes方法，而ErrorAttributes类型的实例又是在ErrorMvcAutoConfiguration中进行了配置。 3、ErrorMvcAutoConfiguration中配置ErrorAttributes的方法上面有@ConditionalOnMissingBean，意思是容器中没有ErrorAttributes这个类型我就自动配置，那我们就可以写一个DefaultErrorAttributes的子类并重写getErrorAttributes方法，然后添加到容器中。这样的话上面Spring Boot的自动配置ErrorAttributes就不会生效，到时候调用getErrorAttributes方法就会调用我们自己重写的方法，以达到我们定制异常数据的效果。 4、我们这里调用父类的方法，先把Spring Boot默认可以获得到的数据先拿到，然后自己可以添加一些额外的数据并返回，最终获得到的model就是我们这个map，浏览器和客户端的数据都是在这获得到的。 5、如果项目中要处理对应的异常类型但是我们又要兼顾Spring Boot的自适应异常处理，在Spring MVC中我们就已经学习了自定义异常处理。这时候我们只需要根据Spring MVC的来做，最终我们请求转发到 “/error”请求，就会由BasicErrorController来处理自适应。最终又会执行到我们重写的getErrorAttributes方法中，我们自定义的异常信息就能放到request域中，在重写的getErrorAttributes中取出来放到map中，在前端就能取到自定义的错误值了。 总结：在ErrorMvcAutoConfiguration类中自动重要的四个组件1、DefaultErrorAttributes：封装异常数据的，getErrorAttributes方法 2、BasicErrorController：处理异常请求的，映射error请求，进行自适应处理 3、ErrorPageCustomizer：错误页面定制器，出现了4xx，5xx的错误就会执行该类中的 registerErrorPages方法，然后发送error请求 4、DefaultErrorViewResolver：异常视图解析器，resolveErrorView方法根据是什么类型 的异常就解析成什么视图名称 1、在error文件夹下创建4xx,5xx为名的html后缀的页面，用到了模板就把error文件夹放入templates文件夹。没有用到模板就放到静态资源映射路径文件夹下。项目出现了错误，Spring Boot就可以找到对应的页面。 2、页面中可以通过模板中的表达式取到错误信息，也可以通过重写方法配合自定义异常处理器来定制错误信息 12345678910&lt;!-- 状态码 --&gt;&lt;h1&gt;status:[[$&#123;status&#125;]]&lt;/h1&gt;&lt;!-- 时间 --&gt;&lt;h3&gt;time:[[$&#123;#dates.format(timestamp, 'yyyy-MM-dd HH:mm:ss')&#125;]]&lt;/h3&gt;&lt;!-- 错误提示 --&gt;&lt;h3&gt;error:[[$&#123;error&#125;]]&lt;/h3&gt;&lt;!-- 异常信息 --&gt;&lt;h3&gt;message:[[$&#123;message&#125;]]&lt;/h3&gt;&lt;!-- 异常对象 --&gt;&lt;h3&gt;exception:[[$&#123;exception&#125;]]&lt;/h3&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_Spring MVC自动配置原理","slug":"2019-03-28-SpringBoot学习04_SpringMVC自动配置原理","date":"2019-03-28T12:36:00.000Z","updated":"2019-05-23T04:32:50.033Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_SpringMVC自动配置原理/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_SpringMVC自动配置原理/","excerpt":"","text":"这里复制官网的一段话—&gt;原地址 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. Spring Boot为SpringMVC提供了自动配置，使用于大多数程序 The auto-configuration adds the following features on top of Spring’s defaults: 自动配置在Spring的默认配置之上添加了以下功能 一、包含ContentNegotiatingViewResolver和BeanNameViewResolver类 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 1.1、查看WebMvcAutoConfiguration类中的viewResolver()方法的返回值ContentNegotiatingViewResolver 1.2、进ContentNegotiatingViewResolver类中找到resolveViewName()[解析视图名称]方法。 this.getCandidateViews(viewName, locale, requestedMediaTypes) –&gt;private List getCandidateViews（xxx,xxx,xxx） –&gt;this.viewResolvers 1.3、该类中有个初始化viewResolvers的方法，可以看到该方法中从容器中获得所有的ViewResolver类型的类 1.4、说明ContentNegotiatingViewResolver类就是组合所有的视图解析器 如何定制：通过源码我们可以推导出，我们可以自己编写一个视图解析器类，实现ViewResolver接口，Spring Boot就会把我们自定义的视图解析器和默认的自动组合起来。 在主程序中编写一个静态内部类，并配置到容器中。 1.5、在DispatcherServlet中的doDispatch方法打上断点，启动然后在浏览器随便访问项目的一个url，可以看到我们自定义的视图解析器已经被组合进去了。 Support for serving static resources, including support for WebJars (covered later in this document)). 支持提供静态资源，包括对WebJars的支持：详情见上一篇文章。 二、自动注册了Converter，GenericConverter，Formatter类 utomatic registration of Converter, GenericConverter, and Formatter beans. 2.1、依然可以在WebMvcAutoConfiguration类中找到，下面这段代码的意思是从容器中分别获得Converter，GenericConverter，Formatter这三个类型的所有组件，并添加到格式化注册表中，也就是帮我们自动配置这三个类。 Converter：转换器，我们前端传过来的数据都是文本字符串格式的，而我们在形参上接收是有不同的类型的，比如传一个11过来，前端是文本形式的，这时候Converter类就会把这个11转换为int类型，GenericConverter也是同样的效果。 Formatter：格式化器，比如前端传过来的时间格式是1999/11/20，或者1999-11-20，这时候Formatter类就会把它们转换为Date类型 添加自己的格式化器，我们只需要实现对应的接口然后放入容器中即可。 三、对HttpMessageConverters类进行了支持 Support for HttpMessageConverters (covered later in this document). 3.1、官方文档也解释了其作用，意思就是把对象类型能转换为json和xml形式返回 3.2、只有一个构造方法，会从容器中获得，然后配置HttpMessageConverter。如果我们要配置自己的HttpMessageConverter，就可以自己写个组件，然后添加到容器中，Spring Boot就会自动获取了。 四、自动注册了MessageCodesResolver类 Automatic registration of MessageCodesResolver (covered later in this document). 4.1、找到getMessageCodesResolver()方法 public MessageCodesResolver getMessageCodesResolver() –&gt;this.mvcProperties.getMessageCodesResolverFormat() –&gt;public Format getMessageCodesResolverFormat() –&gt;Format 进入到Format类中看官方的注释可以很清楚的知道这是校验错误信息的处理，比如JSR303 Static index.html support. 静态index.html支持，详情见上一篇文章。 Custom Favicon support (covered later in this document). 自定义图标支持，详情见上一篇文章。 Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动注册了ConfigurableWebBindingInitializer类 这个就不用说了吧，Spring MVC中用来做参数绑定的类 If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapterinstance to provide such components. 如果想使用Spring Boot提供给我们的自动配置而且你还要加上自己自定义的配置的话你可以使用@Configuration注解且类型必须是WebMvcConfigurer，但是你不能使用@EnableWebMvc注解 五、实现WebMvcConfigurer接口测试 5.2、为什么实现WebMvcConfigurer接口就能达到这样的效果 在WebMvcAutoConfiguration类中有个WebMvcAutoConfigurationAdapter静态内部类，它也实现了WebMvcConfigurer接口，在这个类上有个 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) 在所有自动配置前会向容器中添加一个EnableWebMvcConfiguration组件。 5.3、我们进入EnableWebMvcConfiguration类，也是一个配置类，里面有很多组件，重要的是它父类 5.4、父类中有个setConfigurers(List configurers)方法，方法上加 @Autowired注解，其参数就会从容器中获取，而它参数类型又是WebMvcConfigurer类型的集合，我们前面自己写的配置就是实现了WebMvcConfigurer接口的类， 5.5、该类中有很多这样的方法，拿其中一个举例吧 this.configurers.addViewControllers(registry) –&gt;public void addViewControllers(ViewControllerRegistry registry) addViewControllers(ViewControllerRegistry registry)方法中会遍历WebMvcConfigurer类型的集合，并调用其中每个的addViewControllers()方法，同理可得：其它的自定义配置类也是实现WebMvcConfigurer接口，并实现其方法，这时候会被该类全部调用，所以我们自定义的配置类就与Spring Boot的配置一起生效了 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 如果你想全面接管SpringMVC，请在你的配置类上使用@EnableWebMvc。 意思是你不使用SpringBoot提供的自动配置，一切由自己来配置。这里就写Demo验证了，说下为什么加了这个注解，Spring Boot的自动配置就不会生效呢？ 六、@EnableWebMvc注解使自动配置失效6.1、使用了@EnableWebMvc注解就会向容器添加一个DelegatingWebMvcConfiguration组件。其父类是WebMvcConfigurationSupport 6.2、来到WebMvcAutoConfiguration类，该配置类上有个@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})，意思是容器中如果没有WebMvcConfigurationSupport组件，WebMvcAutoConfiguration中的配置才生效，所以使用了@EnableWebMvc注解，而使用该注解又会向容器中添加一个WebMvcConfigurationSupport组件，Spring Boot的自动配置就会失效。 结论：模式： 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置这其中就有我们上面说到的WebMvcConfigurer 3）、还有很多xxxCustomizer类，继承可以用来定制功能（后面的嵌入式的Servlet容器就是一个例子）","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_web静态资源映射规则(源码)","slug":"2019-03-28-SpringBoot学习04_web静态资源映射规则","date":"2019-03-28T12:06:00.000Z","updated":"2019-05-23T04:33:06.487Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_web静态资源映射规则/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_web静态资源映射规则/","excerpt":"","text":"在前面讲了Spring Boot的自动配置原理，所以静态资源映射的规则自然也能在自动配置类源码中找到，所有的跟web mvc有关的配置都可以在WebMvcAutoConfiguration类中找到 一、Spring Boot提供了一种webjar的方式引入前端的一些资源（如jquery，bootstrap等）WebMvcAutoConfiguration类中有个内部类WebMvcAutoConfigurationAdapter中有个addResourceHandlers方法（添加资源处理器） 从该方法中可以看出所有匹配/webjars/**这种路径规则的都去 classpath:/META-INF/resources/webjars/中找，下面进行测试。 1234567891011121314151617181920212223242526public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol(). toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; this.customizeResourceHandlerRegistration(registry. addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;). addResourceLocations (new String[]&#123;\"classpath:/META-INF/resources/webjars/\"&#125;). setCachePeriod(this.getSeconds(cachePeriod)). setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler (new String[]&#123;staticPathPattern&#125;). addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())). setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; &#125; 1.2、测试：这里引入jquery的webJars，并通过浏览器访问，在jquery的webjars中也有对应的路径 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 二、自定义静态资源存储路径那我们自己引入的静态资源在哪找呢，在上面提到的方法中有一段这个代码 123456String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler (new String[]&#123;staticPathPattern&#125;). addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())). setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); 2.1、this.mvcProperties.getStaticPathPattern()** –&gt;public String getStaticPathPattern() –&gt;this.staticPathPattern = “/\\“** 2.2、接着看该代码块的后半部分 this.resourceProperties.getStaticLocations() –&gt;public String[] getStaticLocations() –&gt;private String[] staticLocations –&gt;this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS –&gt;new String[]{“classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“}; ==上面的所展现代码的意思是访问项目的任意资源，如果没有对应的Controller映射到都 去下面四个路径找，优先级从上到下。 “classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ “/“：当前项目的根路径 测试classpath:/static/asserts/js/feather.min.js 三、Spring Boot 中的Welcome pageSpring Boot默认也提供了欢迎页面，就在前面提到的方法下面有个welcomePageHandlerMapping方法，上面有@Bean，说明也是容器中的一个组件 3.1、这其中有个getStaticLocations（）方法，点进去看自然也是上面提到过的四种静态资源的路径，这里意思就是会在上面那四种路径中找index.html，第二张截图的方法获得的结果是 /*，我们访问项目的默认路径localhost:8080自然也是满足/**的匹配的。 3.2、测试 四、SpringBoot中logo配置每个网站都有自己的logo，像Spring Boot官网的logo图标就是这样 4.1、Spring Boot也提供了这样的功能，在往下面翻会找到一个静态内部类FaviconConfiguration，看里面faviconHandlerMapping()这个方法 4.2、this.faviconRequestHandler() –&gt;public ResourceHttpRequestHandler faviconRequestHandler() –&gt;this.resolveFaviconLocations() –&gt;private List resolveFaviconLocations() –&gt;this.resourceProperties.getStaticLocations() 最终还是找到前面提到的那四种静态资源路径，而对应的url是**/favicon.ico，不管多少级的url，最后以favicon.ico结尾的都会去上面四种静态资源路径中找 测试访问 总结：1）、所有 /webjars/\\ ，都去 classpath:/META-INF/resources/webjars/ 找资源；==** webjars：以jar包的方式引入静态资源； 2）、”/\\“ 访问当前项目的任何资源，都去（静态资源的文件夹）找映射** “classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ “/“：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc 3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/\\“映射；==** localhost:8080/ 找index页面 4）、所有的 \\/favicon.ico 都是在静态资源文件下找；**","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Linux进程管理","slug":"2019-03-27-Linux进程管理方法","date":"2019-03-27T14:37:00.000Z","updated":"2019-05-23T04:31:57.382Z","comments":true,"path":"2019/03/27/2019-03-27-Linux进程管理方法/","link":"","permalink":"http://yoursite.com/2019/03/27/2019-03-27-Linux进程管理方法/","excerpt":"","text":"进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 #类似LS之类的命令都会产生进程。 1、查看系统运行了哪些进程ps aux #查看系统中所有的进程，使用BSD操作系统格式 ps -le #查看系统中所有的进程，使用LINUX标准格式 2、动态查看电脑负载状态 top [选项] -d 秒数：指定top命令每隔几秒更新，默认是3秒。 在top命令的交互模式当中可以执行的命令： ?或h：查看帮助文档 P:以CPU使用率排序，默认就是此项 M:以内存使用率排序 N:以PID排序 q:退出top 第一行任务列队信息 第二行进程信息 第三行CPU行为信息 第四行物理内存信息 第五行交换分区（swap）信息 3、停止进程运命令kill [选项] -l ：查看可用的进程信号 eg: Kill -1 22354 #重启PID为22354的程序 Kill -9 22354 #强制杀死PID为22354的程序","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Linux压缩解压文件","slug":"2019-03-27-Linux压缩解压文件","date":"2019-03-27T13:37:00.000Z","updated":"2019-05-23T04:31:28.025Z","comments":true,"path":"2019/03/27/2019-03-27-Linux压缩解压文件/","link":"","permalink":"http://yoursite.com/2019/03/27/2019-03-27-Linux压缩解压文件/","excerpt":"","text":"一、LINUX中的常见的压缩格式zip、gz、bz2 二、gz压缩文件的压缩与解压1、压缩：gzip [文件路径]gz文件压缩文件特点: 1）、不保留源文件，压缩完成后删除源文件 2）、不能压缩文件夹 eg：压缩文件 a.txt 压缩完成后删除源文件 12345678[root@instance-y2jixxt2 study-linux]# touch a.txt[root@instance-y2jixxt2 study-linux]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 19:43 a.txt[root@instance-y2jixxt2 study-linux]# gzip a.txt[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 26 Mar 27 19:43 a.txt.gz eg：不能压缩文件夹 1234567[root@instance-y2jixxt2 study-linux]# mkdir aa[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 19:45 aa-rw-r--r-- 1 root root 26 Mar 27 19:43 a.txt.gz[root@instance-y2jixxt2 study-linux]# gzip aagzip: aa is a directory -- ignored 2、解压：gunzip [文件路径]eg：解压压缩包 a.txt.gz 1234567[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 26 Mar 27 19:40 a.txt.gz[root@instance-y2jixxt2 study-linux]# gunzip a.txt.gz[root@instance-y2jixxt2 study-linux]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 19:40 a.txt 三、zip压缩文件的压缩与解压1、压缩：zip [选项] [压缩后文件名] [文件或目录]2、解压：unzip [文件路径]-r:压缩文件夹，把所有子目录以及文件一起处理 eg：压缩 a.txt文件 （默认后缀名为zip） 1234567[root@instance-y2jixxt2 study-linux]# touch a.txt[root@instance-y2jixxt2 study-linux]# zip a a.txt adding: a.txt (stored 0%)[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 0 Mar 27 19:50 a.txt-rw-r--r-- 1 root root 160 Mar 27 19:50 a.zip eg：压缩 a 文件夹 如果不使用 -r文件夹中的文件是不会被压缩的 1234567891011121314151617181920212223242526272829[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 19:54 aa[root@instance-y2jixxt2 study-linux]# cd aa[root@instance-y2jixxt2 aa]# touch aa.txt[root@instance-y2jixxt2 aa]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:00 aa.txt[root@instance-y2jixxt2 aa]# cd ..[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:00 aa#压缩文件夹aa[root@instance-y2jixxt2 study-linux]# zip aa aa adding: aa/ (stored 0%)[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:00 aa-rw-r--r-- 1 root root 156 Mar 27 20:03 aa.zip#删除原来的aa文件夹[root@instance-y2jixxt2 study-linux]# rm -rf aa#解压刚刚压缩好的aa.zip[root@instance-y2jixxt2 study-linux]# unzip aa.zipArchive: aa.zip creating: aa/[root@instance-y2jixxt2 study-linux]# cd aa#进入解压后的文件夹发现并没有aa.txt[root@instance-y2jixxt2 aa]# lltotal 0 使用 -r 压缩文件夹，文件夹所有子目录以及文件也会一起处理 1234567891011121314151617181920212223242526[root@instance-y2jixxt2 study-linux]# cd aa[root@instance-y2jixxt2 aa]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:09 aa.txt[root@instance-y2jixxt2 aa]# cd ..[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:09 aa#加上选项 -r 压缩[root@instance-y2jixxt2 study-linux]# zip -r aa aa adding: aa/ (stored 0%) adding: aa/aa.txt (stored 0%)[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:09 aa-rw-r--r-- 1 root root 302 Mar 27 20:11 aa.zip[root@instance-y2jixxt2 study-linux]# rm -rf aa[root@instance-y2jixxt2 study-linux]# unzip aa.zipArchive: aa.zip creating: aa/ extracting: aa/aa.txt [root@instance-y2jixxt2 study-linux]# cd aa#解压后文件夹所有子目录以及文件也会解压出来[root@instance-y2jixxt2 aa]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:09 aa.txt 四、bzip2压缩文件的压缩与解压1、压缩：bzip2 [选项] [文件]特点：不能压缩文件夹 -k 压缩后不删除源文件 eg：压缩 aa.txt 默认删除源文件 12345678910111213141516[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa[root@instance-y2jixxt2 study-linux]# bzip2 aabzip2: Input file aa is a directory.[root@instance-y2jixxt2 study-linux]# touch aa.txt[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa-rw-r--r-- 1 root root 0 Mar 27 20:23 aa.txt#压缩aa.txt文件[root@instance-y2jixxt2 study-linux]# bzip2 aa.txt[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa-rw-r--r-- 1 root root 14 Mar 27 20:23 aa.txt.bz2 eg：使用选项 -k 不删除源文件 12345678[root@instance-y2jixxt2 study-linux]# touch bb.txt[root@instance-y2jixxt2 study-linux]# bzip2 -k bb.txt[root@instance-y2jixxt2 study-linux]# lltotal 12drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa-rw-r--r-- 1 root root 14 Mar 27 20:23 aa.txt.bz2-rw-r--r-- 1 root root 0 Mar 27 20:26 bb.txt-rw-r--r-- 1 root root 14 Mar 27 20:26 bb.txt.bz2 2、解压：bunzip2 [文件路径]eg：解压 aa.txt.bz2 1234567[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 14 Mar 27 20:29 aa.txt.bz2[root@instance-y2jixxt2 study-linux]# bunzip2 aa.txt.bz2[root@instance-y2jixxt2 study-linux]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:29 aa.txt eg：使用选项 -k 不删除源文件 12345678[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 14 Mar 27 20:29 aa.txt.bz2[root@instance-y2jixxt2 study-linux]# bunzip2 -k aa.txt.bz2[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 0 Mar 27 20:29 aa.txt-rw-r--r-- 1 root root 14 Mar 27 20:29 aa.txt.bz2 五、tar打包并且压缩文件（常用）1、压缩文件：tar [选项] [压缩后文件名] [需要压缩的目录或文件路径] -c 打包 -v 显示详细信息 -f 制定文件名 -z 打包使用gzip压缩（.gz） -j 打包使用bzip2压缩（.bz2） -P 来源文件绝对路径 eg：以绝对路径压缩 aa 文件夹为 aa.gz tar -zcvf aa.gz -P /home/work/study-linux/aa （bzip2压缩换成 -j 选项） 123456789[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa[root@instance-y2jixxt2 study-linux]# tar -zcvf aa.gz -P /home/work/study-linux/aa/home/work/study-linux/aa/[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa-rw-r--r-- 1 root root 132 Mar 27 20:49 aa.gz 2、解压文件：tar [选项] [解压文件] -C [解压到的目录] -x 解包 -v 显示详细信息 -f 制定文件名 -z 使用gzip解压缩（.gz） -j 使用bzip2解压缩（.bz2） eg：解压 aa.gz 压缩包到 target 文件夹 tar -zxvf aa.gz -C target （bzip2解压换成 -j 选项） 12345678910111213141516[root@instance-y2jixxt2 study-linux]# lltotal 12drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa-rw-r--r-- 1 root root 105 Mar 27 21:26 aa.gzdrwxr-xr-x 2 root root 4096 Mar 27 21:25 target[root@instance-y2jixxt2 study-linux]# tar -zxvf aa.gz -C targetaa/[root@instance-y2jixxt2 study-linux]# lltotal 12drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa-rw-r--r-- 1 root root 105 Mar 27 21:26 aa.gzdrwxr-xr-x 3 root root 4096 Mar 27 21:27 target[root@instance-y2jixxt2 study-linux]# cd target[root@instance-y2jixxt2 target]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Linux权限管理","slug":"2019-03-26-Linux权限管理","date":"2019-03-26T10:53:00.000Z","updated":"2019-05-23T04:30:23.564Z","comments":true,"path":"2019/03/26/2019-03-26-Linux权限管理/","link":"","permalink":"http://yoursite.com/2019/03/26/2019-03-26-Linux权限管理/","excerpt":"","text":"一、文件属性解释使用ll（ls -l的简写）查看文件的属性 1、文件的所有者：默认创建该文件的用户 2、文件的所有组：默认创建该文件的用户所在的组 1234[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rw-rw-r--. 1 root root 0 Mar 19 10:54 a.txt 第一列：- 为文件，d为文件夹 第二列：所有者权限，r 可读，w 可写，x 可执行 第三列：所有组权限 第四列：其他权限，其他用户的权限 第五列：该文件/目录的所有者 第六列：该文件/目录的所有组 第七列：该文件/目录的大小（不显示单位就是byte） 第八列：该文件/目录创建时间 第九列：该文件/目录名称 二、修改文件的权限u：user代表所有者，g：group代表所有组，o：other代表其他权限，a：all代表所有权限 1、修改文件权限的方式1以上述文件为例把 a.txt 文件的所有者权限加一个可执行，所有组权限加一个可执行，其他权限加一个可写使用 chmod u+x,g+x,o+w a.txt 命令修改 12345[root@localhost study-linux]# chmod u+x,g+x,o+w a.txt[root@localhost study-linux]# lltotal 4drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxrwxrw-. 1 root root 1 Mar 26 19:54 a.txt 创建b.txt，通过chmod a+x b.txt来给所有权限增加可执行 1234567891011[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rw-r--r--. 1 root root 0 Mar 26 20:14 b.txt[root@localhost study-linux]# chmod a+x b.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:14 b.txt 2、修改文件权限的方式2创建文件 c.txt ，通过 chmod u=rwx,g=rw,o=- c.txt 命令将所有者权限改为rwx，所有组权限改为rw，将其他权限设置位不可读不可写不可执行。 1234567891011121314[root@localhost study-linux]# touch c.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-rw-r--r--. 1 root root 0 Mar 26 20:17 c.txt[root@localhost study-linux]# chmod u=rwx,g=rw,o=- c.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-rwxrw----. 1 root root 0 Mar 26 20:17 c.txt 也可以通过 chmod a=r c.txt 将 c.txt 的所有权限改为r（可读） 1234567[root@localhost study-linux]# chmod a=r c.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-r--r--r--. 1 root root 0 Mar 26 20:17 c.txt 3、修改文件权限的方式3r w x 对应着数字 4 2 1 创建 d.txt 文件，通过 chmod 711 d.txt 命令将所有者权限修改为 rwx（4+2+1），所有组修改为 r（1），其他权限修改为 r （1） 12345678910111213141516[root@localhost study-linux]# touch d.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-r--r--r--. 1 root root 0 Mar 26 20:17 c.txt-rw-r--r--. 1 root root 0 Mar 26 20:23 d.txt[root@localhost study-linux]# chmod 711 d.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-r--r--r--. 1 root root 0 Mar 26 20:17 c.txt-rwx--x--x. 1 root root 0 Mar 26 20:23 d.txt","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"编码习惯---Controller规范（转载）","slug":"2019-03-24-编码习惯---Controller规范","date":"2019-03-24T14:57:00.000Z","updated":"2019-05-23T04:30:43.281Z","comments":true,"path":"2019/03/24/2019-03-24-编码习惯---Controller规范/","link":"","permalink":"http://yoursite.com/2019/03/24/2019-03-24-编码习惯---Controller规范/","excerpt":"","text":"转载公众号:Java团长（以后方便查看） 前文回顾： 1、 《吐槽我见过的最烂的Java代码》 2、 《我的编码习惯 —— 接口定义》 第一篇文章中，我贴了2段代码，第1段是原生态的，第2段是我指定了接口定义规范，使用AOP技术之后最终交付的代码，从15行到1行，自己感受一下。 今天来说说大家关注的AOP如何实现。 先说说Controller规范，主要的内容是就是接口定义里面的内容，你只要遵循里面的规范，controller就问题不大，除了这些，还有另外的几点： 1、所有函数返回统一的ResultBean/PageResultBean格式 原因见我的接口定义这个贴。没有统一格式，AOP无法玩。 2、ResultBean/PageResultBean是controller专用的，不允许往后传！ 3、 Controller做参数格式的转换，不允许把json，map这类对象传到services去，也不允许services返回json、map。 一般情况下！写过代码都知道，map，json这种格式灵活，但是可读性差，如果放业务数据，每次阅读起来都比较困难。定义一个bean看着工作量多了，但代码清晰多了。 4、参数中一般情况不允许出现Request，Response这些对象 主要是可读性问题，一般情况下。 5、 不需要打印日志 日志在AOP里面会打印，而且我的建议是大部分日志在Services这层打印。 规范里面大部分是 不要做的项多，要做的比较少，落地比较容易。 ResultBean定义带泛型，使用了lombok。 AOP代码，主要就是打印日志和捕获异常，异常要区分已知异常和未知异常，其中未知的异常是我们重点关注的，可以做一些邮件通知啥的，已知异常可以再细分一下，可以不同的异常返回不同的返回码： 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 处理和包装异常*/public class ControllerAOP &#123; private static final Logger logger = LoggerFactory.getLogger(ControllerAOP.class); public Object handlerControllerMethod(ProceedingJoinPoint pjp) &#123; long startTime = System.currentTimeMillis(); ResultBean&lt;?&gt; result; try &#123; result = (ResultBean&lt;?&gt;) pjp.proceed(); logger.info(pjp.getSignature() + \"use time:\" + (System.currentTimeMillis() - startTime)); &#125; catch (Throwable e) &#123; result = handlerException(pjp, e); &#125; return result; &#125; private ResultBean&lt;?&gt; handlerException(ProceedingJoinPoint pjp, Throwable e) &#123; ResultBean&lt;?&gt; result = new ResultBean(); // 已知异常 if (e instanceof CheckException) &#123; result.setMsg(e.getLocalizedMessage()); result.setCode(ResultBean.FAIL); &#125; else if (e instanceof UnloginException) &#123; result.setMsg(\"Unlogin\"); result.setCode(ResultBean.NO_LOGIN); &#125; else &#123; logger.error(pjp.getSignature() + \" error \", e); //TODO 未知的异常，应该格外注意，可以发送邮件通知等 result.setMsg(e.toString()); result.setCode(ResultBean.FAIL); &#125; return result; &#125;&#125; AOP配置：(关于用java代码还是xml配置，这里我倾向于xml配置，因为这个会不定期改动) 12345678910&lt;!-- aop --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;beans:bean id=\"controllerAop\" class=\"xxx.common.aop.ControllerAOP\" /&gt; &lt;aop:config&gt; &lt;aop:aspect id=\"myAop\" ref=\"controllerAop\"&gt; &lt;aop:pointcut id=\"target\" expression=\"execution(public xxx.common.beans.ResultBean *(..))\" /&gt; &lt;aop:around method=\"handlerControllerMethod\" pointcut-ref=\"target\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 现在知道为什么要返回统一的一个ResultBean了： 为了统一格式 为了应用AOP 为了包装异常信息 分页的PageResultBean大同小异，大家自己依葫芦画瓢自己完成就好了。 贴一个简单的controller（左边的箭头表示AOP拦截了）。请对比吐槽我见过的最烂的Java代码里面原来的代码查看，没有对比就没有伤害。 最后说一句，先有统一的接口定义规范，然后有AOP实现。先有思想再有技术。技术不是关键，AOP技术也很简单，这个帖子的关键点不是技术，而是习惯和思想，不要捡了芝麻丢了西瓜。网络上讲技术的贴多，讲习惯、风格的少，这些都是我工作多年的行之有效的经验之谈，望有缘人珍惜。","categories":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"http://yoursite.com/categories/代码的艺术/"}],"tags":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"http://yoursite.com/tags/代码的艺术/"}],"author":"Yang"},{"title":"去掉烦人的if-else嵌套（转载）","slug":"2019-03-24-去掉烦人的if-else嵌套","date":"2019-03-24T13:40:00.000Z","updated":"2019-05-23T04:30:30.849Z","comments":true,"path":"2019/03/24/2019-03-24-去掉烦人的if-else嵌套/","link":"","permalink":"http://yoursite.com/2019/03/24/2019-03-24-去掉烦人的if-else嵌套/","excerpt":"","text":"转载公众号:Java团长（以后方便查看） 写在前面不知大家有没遇到过像“横放着的金字塔”一样的if else嵌套： 12345678910111213if (true) &#123; if (true) &#123; if (true) &#123; if (true) &#123; if (true) &#123; if (true) &#123; &#125; &#125; &#125; &#125; &#125;&#125; 我并没夸大其词，我是真的遇到过了！嵌套6、7层，一个函数几百行，简！直！看！死！人！ if else作为每种编程语言都不可或缺的条件语句，我们在编程时会大量的用到。但if else一般不建议嵌套超过三层，如果一段代码存在过多的if else嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。所以，我们程序员都应该尽量避免过多的if else嵌套。下面将会谈谈我在工作中如何减少if else嵌套的。 正文在谈我的方法之前，不妨先用个例子来说明if else嵌套过多的弊端。 想象下一个简单分享的业务需求：支持分享链接、图片、文本和图文，分享结果回调给用户（为了不跑题，这里简略了业务，实际复杂得多）。当接手到这么一个业务时，是不是觉得很简单，稍动下脑就可以动手了： 先定义分享的类型、分享Bean和分享回调类： 1234567891011121314151617181920private static final int TYPE_LINK = 0;private static final int TYPE_IMAGE = 1;private static final int TYPE_TEXT = 2;private static final int TYPE_IMAGE_TEXT = 3;public class ShareItem &#123; int type; String title; String content; String imagePath; String link;&#125;public interface ShareListener &#123; int STATE_SUCC = 0; int STATE_FAIL = 1; void onCallback(int state, String msg);&#125; 好了，然后在定义个分享接口，对每种类型分别进行分享就ok了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void share (ShareItem item, ShareListener listener) &#123; if (item != null) &#123; if (item.type == TYPE_LINK) &#123; // 分享链接 if (!TextUtils.isEmpty(item.link) &amp;&amp; !TextUtils.isEmpty(item.title)) &#123; doShareLink(item.link, item.title, item.content, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else if (item.type == TYPE_IMAGE) &#123; // 分享图片 if (!TextUtils.isEmpty(item.imagePath)) &#123; doShareImage(item.imagePath, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else if (item.type == TYPE_TEXT) &#123; // 分享文本 if (!TextUtils.isEmpty(item.content)) &#123; doShareText(item.content, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else if (item.type == TYPE_IMAGE_TEXT) &#123; // 分享图文 if (!TextUtils.isEmpty(item.imagePath) &amp;&amp; !TextUtils.isEmpty(item.content)) &#123; doShareImageAndText(item.imagePath, item.content, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"不支持的分享类型\"); &#125; &#125; &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"ShareItem 不能为 null\"); &#125; &#125;&#125; 到此，简单的分享模型就做出来了。有没问题？老实说，如果没什么追求的话，还真没什么问题，至少思路是清晰的。但一周后呢？一个月后呢？或者一年后呢？share方法的分支有15条，这意味着你每次回看代码得让自己的大脑变成微型的处理器，考虑15种情况。如果出现bug，你又得考虑15种情况，并15种情况都要测试下。再如果现在需要加多分享小视频功能，你又得添加多3个分支，还要改代码，一点都不“开放-闭合”。再再如果后面项目交接给他人跟进，他人又要把自己大脑变成处理器来想每个分支的作用，我敢肯定有百分之八十的人都会吐槽代码。 我们程序员的脑力不应该花费在无止境的分支语句里的，应该专注于业务本身。所以我们很有必要避免写出多分支嵌套的语句。好的，我们来分析下上面的代码多分支的原因： 空值判断 业务判断 状态判断 几乎所有的业务都离不开这几个判断，从而导致if else嵌套过多。那是不是没办法解决了？答案肯定不是的。 上面的代码我是用java写的，对于java程序员来说，空值判断简直使人很沮丧，让人身心疲惫。上面的代码每次回调都要判断一次listener是否为空，又要判断用户传入的ShareItem是否为空，还要判断ShareItem里面的字段是否为空…… 对于这种情况，我采用的方法很简单：接口分层。 减少 if else 方法一：接口分层所谓接口分层指的是：把接口分为外部和内部接口，所有空值判断放在外部接口完成，只处理一次；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。 来，看代码更加直观： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void share(ShareItem item, ShareListener listener) &#123; if (item == null) &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"ShareItem 不能为 null\"); &#125; return; &#125; if (listener == null) &#123; listener = new ShareListener() &#123; @Override public void onCallback(int state, String msg) &#123; Log.i(\"DEBUG\", \"ShareListener is null\"); &#125; &#125;; &#125; shareImpl(item, listener);&#125;private void shareImpl (ShareItem item, ShareListener listener) &#123; if (item.type == TYPE_LINK) &#123; // 分享链接 if (!TextUtils.isEmpty(item.link) &amp;&amp; !TextUtils.isEmpty(item.title)) &#123; doShareLink(item.link, item.title, item.content, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else if (item.type == TYPE_IMAGE) &#123; // 分享图片 if (!TextUtils.isEmpty(item.imagePath)) &#123; doShareImage(item.imagePath, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else if (item.type == TYPE_TEXT) &#123; // 分享文本 if (!TextUtils.isEmpty(item.content)) &#123; doShareText(item.content, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else if (item.type == TYPE_IMAGE_TEXT) &#123; // 分享图文 if (!TextUtils.isEmpty(item.imagePath) &amp;&amp; !TextUtils.isEmpty(item.content)) &#123; doShareImageAndText(item.imagePath, item.content, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"不支持的分享类型\"); &#125;&#125; 可以看到，上面的代码分为外部接口share和内部接口shareImpl，ShareItem和ShareListener的判断都放在share里完成，那么shareImpl就减少了if else的嵌套了，相当于把if else分摊了。这样一来，代码的可读性好很多，嵌套也不超过3层了。 但可以看到，shareImpl里还是包含分享类型的判断，也即业务判断，我们都清楚产品经理的脑洞有多大了，分享的类型随时会改变或添加。嗯说到这里相信大家都想到用多态了。多态不但能应付业务改变的情况，也可以用来减少if else的嵌套。 减少 if else 方法二：多态利用多态，每种业务单独处理，在接口不再做任何业务判断。把ShareItem抽象出来，作为基础类，然后针对每种业务各自实现其子类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class ShareItem &#123; int type; public ShareItem(int type) &#123; this.type = type; &#125; public abstract void doShare(ShareListener listener);&#125;public class Link extends ShareItem &#123; String title; String content; String link; public Link(String link, String title, String content) &#123; super(TYPE_LINK); this.link = !TextUtils.isEmpty(link) ? link : \"default\"; this.title = !TextUtils.isEmpty(title) ? title : \"default\"; this.content = !TextUtils.isEmpty(content) ? content : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125;public class Image extends ShareItem &#123; String imagePath; public Image(String imagePath) &#123; super(TYPE_IMAGE); this.imagePath = !TextUtils.isEmpty(imagePath) ? imagePath : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125;public class Text extends ShareItem &#123; String content; public Text(String content) &#123; super(TYPE_TEXT); this.content = !TextUtils.isEmpty(content) ? content : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125;public class ImageText extends ShareItem &#123; String content; String imagePath; public ImageText(String imagePath, String content) &#123; super(TYPE_IMAGE_TEXT); this.imagePath = !TextUtils.isEmpty(imagePath) ? imagePath : \"default\"; this.content = !TextUtils.isEmpty(content) ? content : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125; （注意：上面每个子类的构造方法还对每个字段做了空值处理，为空的话，赋值default，这样如果用户传了空值，在调试就会发现问题。） 实现了多态后，分享接口的就简洁多了： 1234567891011121314151617181920212223public void share(ShareItem item, ShareListener listener) &#123; if (item == null) &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"ShareItem 不能为 null\"); &#125; return; &#125; if (listener == null) &#123; listener = new ShareListener() &#123; @Override public void onCallback(int state, String msg) &#123; Log.i(\"DEBUG\", \"ShareListener is null\"); &#125; &#125;; &#125; shareImpl(item, listener);&#125;private void shareImpl (ShareItem item, ShareListener listener) &#123; item.doShare(listener);&#125; 嘻嘻，怎样，内部接口一个if else都没了，是不是很酷~ 如果这个分享功能是自己App里面的功能，不是第三方SDK，到这里已经没问题了。但如果是第三方分享SDK的功能的话，这样暴露给用户的类增加了很多（各ShareItem的子类，相当于把if else抛给用户了），用户的接入成本提高，违背了“迪米特原则”了。 处理这种情况也很简单，再次封装一层即可。把ShareItem的子类的访问权限降低，在暴露给用户的主类里定义几个方法，在内部帮助用户创建具体的分享类型，这样用户就无需知道具体的类了： 123456789101112131415public ShareItem createLinkShareItem(String link, String title, String content) &#123; return new Link(link, title, content);&#125;public ShareItem createImageShareItem(String ImagePath) &#123; return new Image(ImagePath);&#125;public ShareItem createTextShareItem(String content) &#123; return new Text(content);&#125;public ShareItem createImageTextShareItem(String ImagePath, String content) &#123; return new ImageText(ImagePath, content);&#125; 或者有人会说，这样用户也需额外了解多几个方法。我个人觉得让用户了解多几个方法好过了解多几个类，而已方法名一看就能知道意图，成本还是挺小，是可以接受的。 其实这种情况，更多人想到的是使用工厂模式。嗯，工厂模式能解决这个问题（其实也需要用户额外了解多几个type类型），但工厂模式难免又引入分支，我们可以用Map消除分支。 减少 if else 方法三：使用Map替代分支语句把所有分享类型预先缓存在Map里，那么就可以直接get获取具体类型，消除分支： 1234567891011121314151617private Map&lt;Integer, Class&lt;? extends ShareItem&gt;&gt; map = new HashMap&lt;&gt;();private void init() &#123; map.put(TYPE_LINK, Link.class); map.put(TYPE_IMAGE, Image.class); map.put(TYPE_TEXT, Text.class); map.put(TYPE_IMAGE_TEXT, ImageText.class);&#125;public ShareItem createShareItem(int type) &#123; try &#123; Class&lt;? extends ShareItem&gt; shareItemClass = map.get(type); return shareItemClass.newInstance(); &#125; catch (Exception e) &#123; return new DefaultShareItem(); // 返回默认实现，不要返回null &#125; &#125; 这种方式跟上面分为几个方法的方式各有利弊，看大家取舍了~ 写在最后讲到这里大家有没收获呢？总结下减少if else的方法： 把接口分为外部和内部接口，所有空值判断放在外部接口完成；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。 利用多态，把业务判断消除，各子类分别关注自己的实现，并实现子类的创建方法，避免用户了解过多的类。 把分支状态信息预先缓存在Map里，直接get获取具体值，消除分支。 好了，到此就介绍完了，希望大家以后写代码能注意，有则避之，无则加勉。希望大家写的代码越来越简洁~","categories":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"http://yoursite.com/categories/代码的艺术/"}],"tags":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"http://yoursite.com/tags/代码的艺术/"}],"author":"Yang"},{"title":"Spring Boot学习02_自动配置原理（精髓）","slug":"2019-03-19-SpringBoot学习02_自动配置原理","date":"2019-03-19T02:42:00.000Z","updated":"2019-05-23T04:28:50.820Z","comments":true,"path":"2019/03/19/2019-03-19-SpringBoot学习02_自动配置原理/","link":"","permalink":"http://yoursite.com/2019/03/19/2019-03-19-SpringBoot学习02_自动配置原理/","excerpt":"","text":"Spring Boot 配置文件中有很多可以写的配置，能写的有哪些呢？ 虽然Spring Boot的官网也有文档，自己引用依赖配置文件中也有提醒，但是这都不是正确的学习方式，如果Spring boot 更新了，难道又去看一遍文档吗？所以我们要学习其中的原理以不变应万变。 在前面我有篇文章写了Spring Boot是怎么启动的，里面说在spring-boot-autoconfigure-2.1.2.RELEASE.jar包下能找到集合中的数据，那么Spring Boot是怎么找到的呢？ 1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==接着上次的点过去 @SpringBootApplication–&gt;@EnableAutoConfiguration–&gt;@Import –&gt;AutoConfigurationImportSelector –&gt;selectImports(AnnotationMetadata annotationMetadata) –&gt;getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) –&gt;getCandidateConfigurations(annotationMetadata, attributes); –&gt;SpringFactoriesLoader.loadFactoryNames .(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); 2）、@EnableAutoConfiguration 作用：关键就是这个loadSpringFactories(@Nullable ClassLoader classLoader)方法 1.该方法会加载所有包下的META-INF/spring.factories文件2.把扫描到的这些文件的内容包装成properties对象3.从properties中获取到所有的key和value包装成Map返回 4、这里再根据类名当作key从上面包装好的Map里面获取值 5、而这个类名就是EnableAutoConfiguration.class，最终获取到这个key对应的value，封装成List返回 最终在查找包下面就只有spring-boot-autoconfigure-2.1.2.RELEASE.jar/META-INF/spring.factories这个文件下有EnableAutoConfiguration XXXAutoConfiguration每一个这样的类都是容器中的一个组件，都加入到容器中，用它们来做自动配置 3）、每一个自动配置类进行自动配置功能；4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration //表示这是一个配置类，与配置文件一样//启动指定类的ConfigurationProperties功能；//将配置文件中对应的值和HttpEncodingProperties绑定起来；//并把HttpEncodingProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，//整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //它是HttpProperties中的一个静态内部类 private final Encoding properties; //只有一个有参构造，参数的值会自动从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125;//给容器中添加一个组件 该方法就是在properties中拿到CharacterEncodingFilter的值然后添加给容器 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties. shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties. shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类，配置文件中spring.http下的属性与该类属性对应 精髓：​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件(被@Bean标注的方法)；（只 要我们要用的组件有，我们就不需要再来配置了，只需要写对应的Properties类 的属性） ​ 4）、给容器中自动配置类添加组件的时候，会从Properties类中获取某些属性。我们就 可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可 以很方便的知道哪些自动配置类生效； 自动配置启用的 没有启动，没有匹配成功的自动配置类","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"SpringBoot学习01_HelloWorld","slug":"2019-03-15-SpringBoot学习01_HelloWorld","date":"2019-03-15T02:58:00.000Z","updated":"2019-05-23T04:26:38.787Z","comments":true,"path":"2019/03/15/2019-03-15-SpringBoot学习01_HelloWorld/","link":"","permalink":"http://yoursite.com/2019/03/15/2019-03-15-SpringBoot学习01_HelloWorld/","excerpt":"","text":"Spring Boot 学习01_入门helloworld简化Spring应用开发的一个框架 整个Spring技术的一个大集合 J2EE开发的一站式解决方案 一、手动创建Spring Boot项目1、在IDEA新建一个maven工程 2、导入Spring Boot相关的依赖 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、编写一个主程序启动Spring Boot应用 123456789@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; //将Spring应用启动起来 SpringApplication.run(App.class, args); &#125;&#125; 4、在同包下编写一个Controller测试 123456789@Controllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; return &quot;Hello World!&quot;; &#125;&#125; 5、启动刚刚创建好的主程序通过浏览器测试访问 二、使用向导快速创建Spring Boot应用1、右键项目New-&gt;Module 2、选择Spring initializr 点击Next(注意：一定要使用jdk1.8) 3、依次填写完点击Next 4、选择自己所需要的组件点击Next(右上角可以选择Spring Boot的版本) 5、填写模块名称后点击finish完成 三、Spring Boot部署的简便 1、导入springboot打包的插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、运行maven的package命令，然后找到该jar包运行。 3、通过浏览器也是能访问到的 原因是因为在打包时有很多别的包与springboot项目打包到一起了，其中就包括嵌入式tomcat","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习01_springboot是怎么启动的","slug":"2019-03-15-SpringBoot学习01_springboot是怎么启动的","date":"2019-03-15T02:34:00.000Z","updated":"2019-05-23T04:27:48.050Z","comments":true,"path":"2019/03/15/2019-03-15-SpringBoot学习01_springboot是怎么启动的/","link":"","permalink":"http://yoursite.com/2019/03/15/2019-03-15-SpringBoot学习01_springboot是怎么启动的/","excerpt":"","text":"Spring Boot的启动就两个很难以理解的问题 一、为什么没有引入相关的jar包就可以直接用SpringMVC的功能了呢? 1、前面写那个helloworld的时候导入了一个父项目的坐标和一个依赖，我们先点进父项目的坐标看看。 2、 发现父项目中还有一个父项目再点进去 3、进去我们发现里面有一堆我们日常需要的依赖版本定义，比如activemq，aspectj等。 由此我们可以得出结论，引入的父项目坐标就是为我们引入的依赖做版本控制用的，所以在spring-boot-dependencies中定义好了的我们再引入不需要写版本了，没有的就需要自己定义版本。那依赖又是在哪里导入的呢？ 这时候我们进入官网找到对应的文档找到对应的描述，称其为starter(启动器)，SpringBoot将所有的功能场景抽取出来做成一个个的starter，在项目中引入starter相关场景的依赖也会被导入进来。要什么功能导入什么starter 点击spring-boot-starter-web，我们就能看到相应的依赖了。 二、之前使用Spring或者SpringMVC的时候都需要一堆配置，譬如HandlerMapping,HandlerAdapter等。那么这些配置是怎么生成的呢？ 点击@SpringBootApplication注解中看看，其他的都是元注解，主要就框住的那两个 1、点进@SpringBootConfiguration注解看发现该注解上有个@Configuration注解，@Configuration注解是Spring的注解，其意是被该注解标注了该类就是一个配置类， 配置类相当于配置文件 配置类也是容器中的一个组件：@Component 1.1、结论：@SpringBootConfiguration注解的作用：被标注的类就是一个配置类，就像xml配置文件，而现在是用java配置文件。并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 1.2、可以直接这样获取 2、开始说@EnableAutoConfiguration注解，我们点进去看又有两个重要的注解 @AutoConfigurationPackage，@Import 2.1、点进@AutoConfigurationPackage注解看发现有个@Import注解，该注解也是Spring中的底层注解。我们点进Registrar这个类，发现该类是个静态类，给registerBeanDefinitions方法打上断点，debug运行 2.1.1、 (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()得到的包名正是被@SpringBootApplication所标注类的包下。 2.1.2、结论：@AutoConfigurationPackage作用：将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； 可以自行测试在别的包下使用SpringMVC。 2.2、点进@Import注解上的AutoConfigurationImportSelector类 2.2.1、发现有个selectImports方法。该方法会调用当前对象getAutoConfigurationEntry()方法，点进去并打上断点，debug启动。 2.2.2、该方法最终得到一个List集合，该集合中的值就是配置类的全类名，将所有需要导入的组件以全类名的方式返回；(比如里面有aop，批处理等配置) 2.2.3、通过该集合实例化一个AutoConfigurationImportSelector.AutoConfigurationEntry对象并返回到selectImports方法。 2.2.4、selectImports拿到该集合并返回 所以有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； 在spring-boot-autoconfigure-2.1.2.RELEASE.jar包下能找到集合中的数据 以上就是Spring Boot的启动原理了。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"}]}