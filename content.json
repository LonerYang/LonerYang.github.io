{"meta":{"title":"Yang","subtitle":null,"description":null,"author":"Yang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-23T02:57:09.000Z","updated":"2019-05-23T02:57:09.484Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-05-23T01:45:25.018Z","updated":"2019-05-23T01:45:25.018Z","comments":true,"path":"2019/05/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"WebSocket","slug":"2019-05-22-WebSocket","date":"2019-05-22T01:07:00.000Z","updated":"2019-05-22T06:09:49.834Z","comments":true,"path":"2019/05/22/2019-05-22-WebSocket/","link":"","permalink":"http://yoursite.com/2019/05/22/2019-05-22-WebSocket/","excerpt":"","text":"一、WebSocket是什么1.WebSocket对比HTTPWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 2.WebSocket的连接数据包JavaScript中使用下面代码创建WebSocket对象，第一个参数 url（如果是使用https创建连接了，这里就使用wss）, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。 1var Socket = new WebSocket(ws://url:port, [protocol] ); 请求时请求头会多点东西 12345678910Connection: Upgrade #表示这次Http连接需要升级Host: localhost:8080Origin: http://localhost:8080Pragma: no-cache#协议扩展， 某类协议可能支持多个扩展，通过它可以实现协议增强; Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits#一个 Base64 encode 的值，这个是浏览器随机生成的，验证作用Sec-WebSocket-Key: nbZWpYwTT+C0pMwypDFbIA== Sec-WebSocket-Version: 13 #websocket的版本Upgrade: websocket #需要升级为websocket连接 然后服务器会返回下列东西还要响应码101，表示已经接受到请求， 成功建立Websocket 1234567Connection: upgrade #告诉客户端已经升级了Date: Wed, 22 May 2019 01:10:19 GMT#经过服务器确认，根据请求时传来的Sec-WebSocket-Key加密后生成的，#客户端根据的请求时随机生产的key加密后对比是否一致来表示是否验证成功Sec-WebSocket-Accept: +ORSis0LYkT05V6n5h+I3Elt+0I=Sec-WebSocket-Extensions: permessage-deflate;client_max_window_bits=15Upgrade: websocket #告诉客户端升级为websocket协议 3.JavaScript使用WebSocket以下是WebSocket对象的属性 属性 描述 Socket.readyState 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount 只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 以下是 WebSocket 对象的相关事件 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 以下是 WebSocket 对象的相关方法 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 二、实现聊天室1.SpringBoot中使用WebSocket 注解 作用 @ServerEndpoint(“/chat”)【类】 指定该类为WebSocket服务端 需指定端点的访问路径 @OnOpen【方法】 连接成功后调用的方法 @OnMessage【方法】 接受到客户端发送的消息调用的方法 @OnClose【方法】 关闭连接调用的方法 @OnError【方法】 异常调用的方法 类 作用 org.springframework.web.socket.server.standard.ServerEndpointExporter 用于扫描和注册所有携带ServerEndPoint注解的实例（若部署到外部容器 则无需提供此类。） javax.websocket.Session 客户端成功连接到服务器后通过该类产生一个会话对象，可以通过该对象发送消息给客户端 2.代码实现 服务端代码 1234567891011121314@Configurationpublic class WebSocketConfig &#123; /** * 用于扫描和注册所有携带ServerEndPoint注解的实例。 * &lt;/p&gt; * PS:若部署到外部容器 则无需提供此类。 */ @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Component@ServerEndpoint(\"/chat\")public class WebSocketChatServer &#123; /** * 全部在线会话 PS: 基于场景考虑 这里使用线程安全的Map存储会话对象。 * Session就是客户端与服务器端的会话对象 */ private static Map&lt;String, Session&gt; onlineSessions = new ConcurrentHashMap&lt;&gt;(); /** * 当客户端打开连接：1.添加会话对象 2.更新在线人数 */ @OnOpen public void onOpen(Session session) &#123; onlineSessions.put(session.getId(), session); sendMessageToAll(Message.jsonStr(Message.ENTER, \"\", \"\", onlineSessions.size())); &#125; /** * 当客户端发送消息：1.获取它的用户名和消息 2.发送消息给所有人 * &lt;p&gt; * PS: 这里约定传递的消息为JSON字符串 方便传递更多参数！ */ @OnMessage public void onMessage(Session session, String jsonStr) &#123; Message message = JSON.parseObject(jsonStr, Message.class); sendMessageToAll(Message.jsonStr(Message.SPEAK, message.getUsername(), message.getMsg(), onlineSessions.size())); &#125; /** * 当关闭连接：1.移除会话对象 2.更新在线人数 */ @OnClose public void onClose(Session session) &#123; onlineSessions.remove(session.getId()); sendMessageToAll(Message.jsonStr(Message.QUIT, \"\", \"\", onlineSessions.size())); &#125; /** * 当通信发生异常：打印错误日志 */ @OnError public void onError(Session session, Throwable error) &#123; error.printStackTrace(); &#125; /** * 公共方法：发送信息给所有人 */ private static void sendMessageToAll(String msg) &#123; onlineSessions.forEach((id, session) -&gt; &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526@Datapublic class Message &#123; public static final String ENTER = \"ENTER\"; public static final String SPEAK = \"SPEAK\"; public static final String QUIT = \"QUIT\"; private String type;//消息类型 private String username; //发送人 private String msg; //发送消息 private int onlineCount; //在线用户数 public static String jsonStr(String type, String username, String msg, int onlineTotal) &#123; return JSON.toJSONString(new Message(type, username, msg, onlineTotal)); &#125; public Message(String type, String username, String msg, int onlineCount) &#123; this.type = type; this.username = username; this.msg = msg; this.onlineCount = onlineCount; &#125;&#125; 123456789101112131415161718192021222324252627282930@SpringBootApplication@RestControllerpublic class WebsocketApplication &#123; /** * 登陆界面 */ @GetMapping(\"/\") public ModelAndView login() &#123; return new ModelAndView(\"/login\"); &#125; /** * 聊天界面 */ @GetMapping(\"/index\") public ModelAndView index(String username, String password, HttpServletRequest request) throws UnknownHostException &#123; if (StringUtils.isEmpty(username)) &#123; username = \"匿名用户\"; &#125; ModelAndView mav = new ModelAndView(\"chat\"); mav.addObject(\"username\", username); mav.addObject(\"webSocketUrl\", \"ws://\"+ InetAddress.getLocalHost().getHostAddress()+\":\"+request.getServerPort()+request.getContextPath()+\"/chat\"); return mav; &#125; public static void main(String[] args) &#123; SpringApplication.run(WebsocketApplication.class, args); &#125;&#125; 客户端核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function getWebSocket() &#123; /** * 只要创建出来就会连接上指定地址(想下ServerSocket和Socket聊天室怎么实现的) * URL开头表示WebSocket协议 中间是域名端口 结尾是服务端映射地址 */ var webSocket = new WebSocket('ws://localhost:8080/chat'); /** * 当服务端打开连接 */ webSocket.onopen = function(event) &#123; console.log(\"WebSocket打开连接\"); &#125; /** * 当服务端发来消息：1.广播消息 2.更新在线人数 */ webSocket.onmessage = function(event) &#123; console.log(\"WebSocket收到消息：%c\" + event.data, \"color:green\"); //获取服务端消息 || 逻辑或运算会有短路功能，如果前面为true，后面就不执行， //如果为false就会执行后面 var message = JSON.parse(event.data) || &#123;&#125;; var $chatContent = $(\"#chat-content\"); //如果是聊天的消息就把用户名和信息打印出来 if (message.type === \"SPEAK\") &#123; $chatContent.append(message.username + \":\" + message.msg + \"&amp;#10;\"); &#125; //否则只需要更新在线人数 $(\"#chat-num\").html(message.onlineCount); &#125; /** * 关闭连接 */ webSocket.onclose = function(event) &#123; console.log(\"WebSocket关闭连接\"); &#125; /** * 通信失败 */ webSocket.onerror = function(event) &#123; console.log(\"WebSocket发生异常\"); &#125; return webSocket;&#125;var webSocket = getWebSocket();/** * 通过WebSocket对象发送消息给服务端 */$(\"#send\").click(function() &#123; if($(\"#message\").val()) &#123; //将stringify中的值转成json格式的字符串 webSocket.send(JSON.stringify(&#123;username: $('#username').text(), msg: $(\"#message\").val()&#125;)); //发送完清空输入框的内容 $(\"#message\").val(null); &#125;&#125;)/** * 清屏 */$(\"#clear\").click(function() &#123; $(\"#chat-content\").empty();&#125;)/** * 使用ENTER发送消息 */document.onkeydown = function (event) &#123; var e = event || window.event || arguments.callee.caller.arguments[0]; e.keyCode === 13 &amp;&amp; $(\"#send\").click();&#125;; 最终效果 三、项目中使用WebSocket之前在做项目时有个需求就是用户可以查看当前在线的医生，并可以选择医生进行咨询 这里记录下来防止下次再用到同样的业务逻辑 思路： 在医生角色客户端有个列表页，显示与每个用户交流的列表，只要医生进了列表页就使用WebSocket连接上了服务器，并把该医生连接信息加入到userSessionManager中的doctorSocketSessionMap中（key为doctorId，value为WebSocket会话 session）。 用户点击咨询页面，就会查询数据库中的所有医生，并将所有的医生doctorList对比userSessionManager中的doctorSocketSessionMap中的所有数据，只要在doctorSocketSessionMap中有的就设置为在线状态（医生有个status字段）没有的默认status就是0也就是离线状态，页面上保存了医生的id，当某个用户点击咨询那个医生时，这时候用户与服务器建立webSocket连接，只要连接上就把他加入到userSessionManager中的userSocketSessionMap （key为userId，value为会话session）中。当用户发送消息给某个医生时，消息上包括了这个消息是谁发的(userId)和要发给谁(doctorId)，服务器接收到该消息就会去判断当前用户是否为用户然后根据要发给谁也就是doctorId去doctorSocketSessionMap中查出WebSocket的session会话对象，使用该session发送消息到客户端，此时医生客户端就会收到一条信息，医生点开列表页，会有一条信息提醒，点开该信息提醒就会出现对话框，就能对话了。医生发消息也是这样的一个逻辑 注意：医生不能主动找用户聊天，必须是用户点击咨询某个医生然后发送消息给该医生时，医生列表就会得到一条消息推送，医生点开消息推送，就能与用户聊天了 总结：WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信通道。 WebSocket是双向的：使用WebSocket客户端或服务器可以发起消息发送 WebSocket是全双工的：客户端和服务器通信是相互独立的 单个TCP连接：初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信 与HTTP相比，WebSocket消息数据交换要轻的多 浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 WebSocket协议能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"author":"Yang"},{"title":"线程池","slug":"2019-05-18-线程池","date":"2019-05-18T07:54:00.000Z","updated":"2019-05-18T10:34:37.891Z","comments":true,"path":"2019/05/18/2019-05-18-线程池/","link":"","permalink":"http://yoursite.com/2019/05/18/2019-05-18-线程池/","excerpt":"","text":"一、ExecutorExecutor是所有线程池的接口，定义了一个用于执行Runnable任务的execute方法，它没有实现类只有另一个重要的子接口ExecutorService，线程池中方法都是实现该子接口而来的。 自己实现Executor接口 12345678910111213public class T01_MyExecutor implements Executor &#123; public static void main(String[] args) &#123; new T01_MyExecutor().execute(() -&gt; &#123; System.out.println(\"测试 Executor\"); &#125;); &#125; @Override public void execute(Runnable command) &#123; new Thread(command).start(); &#125;&#125; 二、Runnable和Callable线程执行的都是任务，分为Runnable和Callable的任务 首先Callable的任务是不能直接传给Thread的构造器的，需要通过FutureTask类（Runnable的子类）包装下再通过new Thread()启动该Callable的任务，Callable的任务是有返回值的，返回值通过FutureTask的阻塞式get()方法获取。且异常可以throws出去，可以不在内部处理。 1234567891011121314public class T06_Future &#123; public static void main(String[] args) throws Exception &#123; //使用线程执行callable的任务 // 创建一个Callable的任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(() -&gt; &#123; Thread.sleep(500); return 1000; &#125;); // new Callable() &#123;Integer call()&#125; new Thread(task).start(); //get()阻塞式的；会等待task任务执行完，这里才会获取任务返回的值 System.out.println(task.get()); &#125;&#125; Runnable的任务就可以直接通过匿名内部类来实现Runnable接口并交给Thread，但是异常不能throws，只能通过内部try…catch 12345678new Thread(() -&gt; &#123; try &#123; Thread.sleep(500); System.out.println(\"test\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start(); 三、线程池线程池的基本API Running：线程的状态，表示正在运行 pool size：线程池中的线程的数量 active threads：正在工作的线程数 queued tasks：在队列等待执行的任务（传入的任务太多，会将没有得到执行的任务放入由线程池维护的一个队列中进行排队，等什么时候线程池有空闲线程来这里调用任务） completed tasks：成功执行的任务数量（任务执行完会将执行完的任务放入由线程池维护的一个队列中）一个线程池维护两个队列 shutdown()：等待所有的任务执行完关闭线程池 shutdownNow()：不管线程池中的任务有没有执行完直接关闭线程池 isTerminated()：线程池中的所有任务是否都执行完了 isShutdown()：线程池是否正在关闭的过程中，并不是现在已经关了 12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) throws InterruptedException &#123; // 创建具有5个 线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(5); //执行6次execute方法，丢入6个任务进去，会由线程池中的线程来执行任务（也就是这里的run方法） for (int i = 0; i &lt; 6; i++) &#123; threadPool.execute(() -&gt; &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125;); &#125; /** * [Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0] */ System.out.println(threadPool); threadPool.shutdown(); // threadPool.shutdownNow(); System.out.println(threadPool.isTerminated()); System.out.println(threadPool.isShutdown()); System.out.println(threadPool); //主线程等待5秒，让所有的任务都执行完 TimeUnit.SECONDS.sleep(5); System.out.println(threadPool.isTerminated()); System.out.println(threadPool.isShutdown()); System.out.println(threadPool); &#125; 1、FixedThreadPoolFixedThreadPool是指定固定大小的线程池，下面通过计算1到200000的质数个数来比较单线程和多线程的效率 ​ 单线程2468毫秒，通过5个线程的线程池计算得出717毫秒（每个人的电脑不同，但是还是可以看出多线程计算的能充分发挥出CPU的能力） Executors是一个工具类可以用来创建线程池 submit()是往线程池中提交一个Callable的任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class T07_ParallelComputing &#123; public static void main(String[] args) throws Exception &#123; //单线程执行 long start = System.currentTimeMillis(); List&lt;Integer&gt; result = getPrime(1, 200000); long end = System.currentTimeMillis(); System.out.println(end - start); //使用线程池(CPU几核最少就创建几个线程的线程池，防止浪费CPU的核数) ExecutorService service = Executors.newFixedThreadPool(4); //这里不平均分是因为自然数越大算出来的质数时间就越慢，所以越到后面就算越少的数 MyTask t1 = new MyTask(1, 80000); MyTask t2 = new MyTask(80001, 130000); MyTask t3 = new MyTask(130001, 170000); MyTask t4 = new MyTask(170001, 200000); Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(t1); Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(t2); Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(t3); Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(t4); start = System.currentTimeMillis(); f1.get(); f2.get(); f3.get(); f4.get(); end = System.currentTimeMillis(); System.out.println(end - start); service.shutdown(); &#125; static class MyTask implements Callable&lt;List&lt;Integer&gt;&gt; &#123; int start; int end; public MyTask(int start, int end) &#123; super(); this.start = start; this.end = end; &#125; @Override public List&lt;Integer&gt; call() throws Exception &#123; return getPrime(start, end); &#125; &#125; /** * 给一个数判断是否为质数 * @param num * @return */ static boolean isPrime(int num) &#123; for (int i = 2; i &lt; num / 2; i++) &#123; if (num % i == 0) &#123; return false; &#125; &#125; return true; &#125; /** * 给定一个范围，返回该范围内的所有质数 * @param start * @param end * @return */ static List&lt;Integer&gt; getPrime(int start, int end) &#123; List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); for (int i = start; i &lt;= end; i++) &#123; if (isPrime(i)) &#123; primes.add(i); &#125; &#125; return primes; &#125;&#125; 2、CachedThreadPoolCachedThreadPool是弹性的 不能指定容量的线程池，来一个任务线程池中没有空闲的线程就会创建一个线程来执行，有空闲的线程就由空闲的线程去执行该任务，线程池中线程最多数量是CPU能支撑最多的数量 一个线程默认60秒不使用系统自动销毁 下面这个例子测试CachedThreadPool中的线程是否在60秒内会销毁 12345678910111213141516171819202122232425262728293031public class T08_CachedThreadPool &#123; public static void main(String[] args) throws Exception &#123; ExecutorService service = Executors.newCachedThreadPool(); //java.util.concurrent.ThreadPoolExecutor@677327b6[Running, pool size = 0, // active threads = 0, queued tasks = 0, completed tasks = 0] System.out.println(service); for (int i = 0; i &lt; 2; i++) &#123; service.execute(() -&gt; &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; //java.util.concurrent.ThreadPoolExecutor@677327b6[Running, pool size = 2, // active threads = 2, queued tasks = 0, completed tasks = 0] System.out.println(service); //等待80秒再查看线程池 TimeUnit.SECONDS.sleep(80); //80秒后线程池中的线程已经自动销毁了 //java.util.concurrent.ThreadPoolExecutor@677327b6[Running, pool size = 0, //active threads = 0, queued tasks = 0, completed tasks = 2] System.out.println(service); service.shutdown(); &#125;&#125; 3、SinglePool Single这个线程池中只有一个线程 优点：任务是按顺序执行的 12345678910111213public class T09_SinglePool &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 6; i++) &#123; final int j = i; service.execute(() -&gt; &#123; System.out.println(j + \"---\" + Thread.currentThread().getName()); &#125;); &#125; service.shutdown(); &#125;&#125; 4、ScheduledThreadPoolScheduledThreadPool执行定时任务的线程池，来一个任务如果第一个线程空闲就会由空闲的线程去执行该任务不会又创建一个新线程去执行 pram1:任务 ; pram2:任务延迟多久启动; parm3:任务间隔多久重复执行; parm4:时间单位 123456789101112131415161718public class T10_ScheduledThreadPool &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newScheduledThreadPool(4); service.scheduleAtFixedRate(() -&gt; &#123; try &#123; //重复执行的优先比较高：启动一个任务，该任务等待1000毫秒，等待到200毫秒时，又要执行该任务， //此时会使用线程池中的线程执行， //如果没有就依次等待 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125;, 0, 200, TimeUnit.MILLISECONDS); service.shutdown(); &#125;&#125; 5、WorkStealingPoolWorkStealingPool线程池中某个线程执行完了自己的任务会主动去拿别人没有执行的任务来执行（之前都是通过CPU的调度来决定哪个线程执行哪个任务） WorkStealingPool是精灵线程(后台线程，守护线程)，使用ForkJoinPool（后面会介绍）实现的 WorkStealingPool根据当前操作系统的CPU有几个核就会创建几个线程 12345678910111213141516171819202122232425262728293031323334353637383940public class T11_WorkStealingPool &#123; public static void main(String[] args) throws IOException &#123; ExecutorService service = Executors.newWorkStealingPool(); System.out.println(\"CPU核数：\" + Runtime.getRuntime().availableProcessors()); service.execute(new R(1000)); service.execute(new R(2000)); service.execute(new R(2000)); service.execute(new R(2000)); //线程中的四个线程执行前面四个任务，线程1执行完后就会来执行这个任务 service.execute(new R(2000)); //因为是精灵线程所以前台看不到输出，将主线程阻塞住就能看到输出 System.in.read(); service.shutdown(); &#125; static class R implements Runnable &#123; int time; public R(int time) &#123; super(); this.time = time; &#125; @Override public void run() &#123; try &#123; Thread.sleep(time); System.out.println(Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 6、ForkJoinPoolForkJoinPool采用的是分而治之的思想来处理任务的，比如任务1我觉得太大了，线程1就可以创建出两个子线程1.1和1.2，如果1.1和1.2中的任务还是觉得太大了，又可以再分，相当于递归。任务的大小和什么时候该创建出子线程可以自定义。Java提供了RecursiveAction（无返回值）和RecursiveTask（有返回值）两个类给我们实现自定义的任务。 适用场景：大数据计算的时候，使用该线程池分而治之，最后将结果加起来 下面这个例子是计算出1000000个数的总和，使用RecursiveAction（无返回值），只要超过50000个数就创建出子线程来计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class T12_ForkJoinPool &#123; static int[] nums = new int[1000000]; static final int MAX_NUM = 50000; static Random r = new Random(47); static &#123; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = r.nextInt(100); &#125; // 一个线程计算 long start = System.currentTimeMillis(); System.out.println(Arrays.stream(nums).sum()); long end = System.currentTimeMillis(); System.out.println(end - start); &#125; static class AddTask extends RecursiveAction &#123; //起始索引和结束索引 int start, end; public AddTask(int start, int end) &#123; super(); this.start = start; this.end = end; &#125; @Override protected void compute() &#123; //如果计算的数小于等于5000就直接运算 if (end - start &lt;= MAX_NUM)&#123; int sum = 0; for (int i = start; i &lt; end; i++) &#123; sum += nums[i]; &#125; /** from-468750-to-500000=1550090 from-968750-to-1000000=1547147 from-437500-to-468750=1543904 from-406250-to-437500=1549217 from-375000-to-406250=1547524 from-343750-to-375000=1550377 from-312500-to-343750=1557548 from-281250-to-312500=1556502 from-250000-to-281250=1548952 from-218750-to-250000=1544876 from-187500-to-218750=1551438 from-156250-to-187500=1540919 from-125000-to-156250=1547592 from-93750-to-125000=1545356 from-62500-to-93750=1551600 from-31250-to-62500=1549447 from-0-to-31250=1548690 from-718750-to-750000=1544974 from-687500-to-718750=1542965 from-656250-to-687500=1549610 from-625000-to-656250=1544851 from-593750-to-625000=1544628 from-562500-to-593750=1554697 from-531250-to-562500=1551386 from-500000-to-531250=1540894 from-843750-to-875000=1545588 from-812500-to-843750=1551625 from-781250-to-812500=1545580 from-750000-to-781250=1543492 from-906250-to-937500=1547821 from-875000-to-906250=1542223 from-937500-to-968750=1555770 **/ System.out.println(\"from-\" + start + \"-to-\" + end + \"=\" + sum); &#125; else&#123; //如果大于5000就切半 int middle = start + (end - start) / 2; //创建两个子任务再来调用compute()，如果还切半还大于50000，又会切半。相当于递归 AddTask subTask1 = new AddTask(start, middle); AddTask subTask2 = new AddTask(middle, end); subTask1.fork(); subTask2.fork(); &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; ForkJoinPool fjp = new ForkJoinPool(); AddTask task = new AddTask(0, nums.length); long start = System.currentTimeMillis(); // 精灵线程（守护线程，后台线程） fjp.execute(task); long end = System.currentTimeMillis(); System.out.println(end - start); // 因为是精灵线程，所以主线程要阻塞住，不然看不到打印 System.in.read(); fjp.shutdown(); &#125;&#125; 如果要看到所有子线程计算完成后的合计结果可以使用RecursiveTask（有返回值） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class T12_ForkJoinPool &#123; static int[] nums = new int[1000000]; static final int MAX_NUM = 50000; static Random r = new Random(47); static &#123; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = r.nextInt(100); &#125; // 一个线程计算 long start = System.currentTimeMillis(); System.out.println(Arrays.stream(nums).sum()); long end = System.currentTimeMillis(); System.out.println(end - start); &#125; static class AddTask extends RecursiveTask&lt;Long&gt; &#123; // 起始索引和结束索引 int start, end; public AddTask(int start, int end) &#123; super(); this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; // 如果计算的数小于等于5000就直接运算 if (end - start &lt;= MAX_NUM) &#123; long sum = 0; for (int i = start; i &lt; end; i++) &#123; sum += nums[i]; &#125; return sum; &#125; // 如果大于5000就切半 int middle = start + (end - start) / 2; // 创建两个子任务再来调用compute()，如果还切半还大于50000，又会切半。相当于递归 AddTask subTask1 = new AddTask(start, middle); AddTask subTask2 = new AddTask(middle, end); subTask1.fork(); subTask2.fork(); //fork完(分开执行完就要合并了) return subTask1.join() + subTask2.join(); &#125; &#125; public static void main(String[] args) throws IOException &#123; ForkJoinPool fjp = new ForkJoinPool(); AddTask task = new AddTask(0, nums.length); long start = System.currentTimeMillis(); // 精灵线程（守护线程，后台线程） fjp.execute(task); //join本来就是阻塞的，这里主线程就不用阻塞 Long result = task.join(); System.out.println(result); long end = System.currentTimeMillis(); System.out.println(end - start); fjp.shutdown(); &#125;&#125; 四、ParallelStreamAPIJava中提供了对集合多线程运算的API，下面使用单线程和多线程计算10000个数中是否为质数，对比双方的效率。 每个人电脑不一样，但是使用多线程效率上还是快上不少的 单线程：1655毫秒使用parallelStream()多线程计算：410毫秒 123456789101112131415161718192021222324252627282930313233343536373839404142public class T14_ParallelStreamAPI &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Random r = new Random(47); for (int i = 0; i &lt; 10000; i++) &#123; list.add(1000000 + r.nextInt(1000000)); &#125; long start = System.currentTimeMillis(); list.forEach(o -&gt; isPrime(o)); long end = System.currentTimeMillis(); System.out.println(end - start); //使用 parallel stream api start = System.currentTimeMillis(); /* list.parallelStream().forEach(new Consumer() &#123; @Override public void accept(Object t) &#123; // TODO Auto-generated method stub T14_ParallelStreamAPI.isPrime((int) t); &#125; &#125;); */ list.parallelStream().forEach(T14_ParallelStreamAPI::isPrime); end = System.currentTimeMillis(); System.out.println(end - start); &#125; static boolean isPrime(int num) &#123; for (int i = 2; i &lt; num / 2; i++) &#123; if (num % i == 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 总结12345678910111213141516171819202122232425Executor 所有线程池的接口ExecutorService Executor的子接口 Runnable和Callable的区别 1、Runnable没有返回值，Callable有返回值 2、Runnable异常只能内部消化，Callable可以throws出去，Callable使用FutureTask的get方法(阻塞) 获取返回值Callable 自定义任务的接口Future 线程池执行完任务返回的值，通过它get()到返回值Executors 工具类，可以用来创建线程池六种线程池使用线程池：先创建一个任务，然后丢给线程池，线程池中的线程会来执行该任务fixed 指定固定大小的线程池cached 弹性的 不能指定容量的线程池，来一个任务线程池中没有空闲的线程就会创建一个线程来执行，线程池中最多数量是CPU能支撑最多的数量 一个线程默认60秒不使用系统自动销毁single 这个线程池中只有一个线程 优点：任务是按顺序执行的scheduled 定时执行任务的线程池workstealing 线程池中某个线程执行完了自己的任务会主动去拿别人没有执行的任务来执行（操作系统CPU几核就会 给你自动创建几个线程）forkjoin 大数据计算的时候，使用该线程池分而治之，最后将结果加起来。类似递归ThreadPoolExecutor 自定义线程池，所有的线程池背后都是使用ThreadPoolExecutor来实现的 也可以继承这个类自定义线程池，需要指定一些参数ParallelStreamAPI 多线程计算数据的API","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"并发容器","slug":"2019-05-09-并发容器","date":"2019-05-09T13:58:00.000Z","updated":"2019-05-09T15:19:11.935Z","comments":true,"path":"2019/05/09/2019-05-09-并发容器/","link":"","permalink":"http://yoursite.com/2019/05/09/2019-05-09-并发容器/","excerpt":"","text":"JDK1.5之前给我们提供的线程安全的容器只有Hashtable，Vector之类的容器，底层用synchronized实现的，所以效率很差，JDK1.5给我们提供了一系列的并发容器，下面用几个例子依次介绍。 一、Hashtable、ConcurrentHashMap、ConcurrentSkipListMap、HashMap 创建100个线程并且每个线程需要往Map中插入10000个数，使用Hashtable、ConcurrentHashMap、ConcurrentSkipListMap、HashMap来测试。 HashMap使用Hash表来实现的，执行时间是最快的，但是线程不是安全的； 用Hashtable是用synchronized加锁的方式实现线程安全，所以效率不是很高； Hashtable是锁住整个hash表，一次只能插入一个，ConcurrentHashMap把hash表分成了16份，每次锁住一份，分段锁，因此可以并发的插入。效率比Hashtable要快点 ConcurrentSkipListMap使用跳表数据结构实现的、高并发并且排序，插入效率较低，查询较高 12345678910111213141516171819202122232425262728293031323334353637public class T01_ConcurrentMap &#123; public static void main(String[] args) &#123; Random r = new Random(); // Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();// Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();// Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;(); //会有并发问题 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //初始化10个线程，每个线程都添加10000个数 Thread[] threads = new Thread[100]; CountDownLatch latch = new CountDownLatch(threads.length); for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 10000; j++) &#123; map.put(\"a\" + r.nextInt(100000), \"a\" + r.nextInt(100000)); &#125; //执行完一个线程就减少一个门闩 latch.countDown(); &#125;); &#125; long start = System.currentTimeMillis(); Arrays.asList(threads).forEach(o -&gt; o.start()); try &#123; //主线程等待所有线程执行完就会被唤醒 latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 二、ArrayList、Vector、CopyOnWriteArrayList 创建100个线程，每个线程插入1000个数，最终List中会插入100000万个数，用ArrayList、Vector、CopyOnWriteArrayList测试 ArrayList会有并发问题，但是效率高 Vector使用synchronized加锁的方式实现线程安全，但是效率很底 CopyOnWriteArrayList写时复制容器 ，多线程环境下，写时效率低（写的时候加锁并且把之前的数组复制到一个新的数组中），读时效率高，适合多线程环境中写少读多 123456789101112131415161718192021222324252627282930313233343536373839404142public class T02_CopyOnWriteList &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = // new ArrayList&lt;&gt;(); //这个会有并发问题// new Vector&lt;&gt;(); new CopyOnWriteArrayList&lt;&gt;(); Random r = new Random(47); Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; list.add(\"a \" + r.nextInt(10000)); &#125; &#125;); &#125; runAndCompute(threads); System.out.println(list.size()); &#125; public static void runAndCompute(Thread[] threads) &#123; long start = System.currentTimeMillis(); Arrays.asList(threads).forEach(o -&gt; o.start()); Arrays.asList(threads).forEach(o -&gt; &#123; try &#123; //当主线程每次执行到这里时就会调用自定义线程的join方法 //就要让自定义线程执行完才会执行主线程 o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 三、ConcurrentLinkedQueue、ConcurrentLinkedDeque 测试线程安全的队列的一些API使用，ConcurrentLinkedQueue（单项队列），ConcurrentLinkedDeque（双端队列） size()：返回长度 getFirst()：返回队列第一个元素 getLast()：返回队列最后一个元素 offer()：相当于add(),add()添加可能会报异常，offer()会返回是否插入成功 poll()：返回链表上第一个数，并且从链表中删掉 peek()：返回链表第一个数，不会删除 12345678910111213141516171819202122232425262728293031323334public class T03_ConcurrentQueue &#123; public static void main(String[] args) &#123;// testConcurrentLinkedQueue(); testConcurrentLinkedDeque(); &#125; public static void testConcurrentLinkedDeque() &#123; //双端队列 ConcurrentLinkedDeque&lt;String&gt; queue = new ConcurrentLinkedDeque&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; queue.offer(\"double\" + i); &#125; System.out.println(\"size = \" + queue.size()); System.out.println(\"双端队列头：\" + queue.getFirst()); System.out.println(\"双端队列尾：\" + queue.getLast()); &#125; public static void testConcurrentLinkedQueue() &#123; Queue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; queue.offer(\"a\" + i); &#125; System.out.println(\"size = \" + queue.size()); System.out.println(\"弹出链表头：\" + queue.poll()); System.out.println(\"size = \" + queue.size()); System.out.println(\"链表头：\" + queue.peek()); System.out.println(\"size = \" + queue.size()); &#125;&#125; 四、LinkedBlockingQueue 使用生产者消费者模式来测试LinkedBlockingQueue（阻塞式的同步链表队列） 使用put方法添加满了就会阻塞住（之前写生产者消费者模式使用synchronized、wait、notify很麻烦） 如果队列中为空take()就会等待/阻塞住 12345678910111213141516171819202122232425262728293031323334public class T04_LinkedBlockingQueue &#123; static BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;(); public static void main(String[] args) &#123; //启动一个生产者线程 new Thread(() -&gt; &#123; //生产100个元素 for (int i = 0; i &lt; 100; i++) &#123; try &#123; queue.put(\"a\" + i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); //启动5个消费者线程 for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; //每次消费十个 for (int j = 0; j &lt; 20; j++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" take--\" + queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, \"c\" + i).start(); &#125; &#125;&#125; 五、ArrayBlockingQueue 测试阻塞式的同步数组队列ArrayBlockingQueue add()：满了再添加会报异常 offer()： 满了添加不会报异常，返回一个boolean值来确认是否插入 offer(“a10”, 1, TimeUnit.SECONDS)：等待/阻塞一秒，如果还不能插入就放弃 put()：满了会等待/阻塞住 123456789101112131415161718public class T05_ArrayBlockingQueue &#123; static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; queue.offer(\"a\" + i); &#125;// queue.add(\"a10\"); // boolean isInsert = queue.offer(\"a10\");// System.out.println(isInsert); // queue.offer(\"a10\", 1, TimeUnit.SECONDS); queue.put(\"a10\"); &#125;&#125; 六、DelayQueue DelayQueue需要添加的是一个Delayed类型的任务，因此要使用它需要实现该接口定义自己的任务，然后在自己的任务类中根据实际的业务逻辑来写对应的代码，这里我简单的使用对比时间，时间快的先执行。（执行定时任务） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class T06_DelayQueue &#123; static BlockingQueue&lt;MyTask&gt; tasks = new DelayQueue&lt;&gt;(); static class MyTask implements Delayed &#123; int id; long runningTime; MyTask(long rt, int id) &#123; this.runningTime = rt; this.id = id; &#125; @Override public int compareTo(Delayed o) &#123; //比较的方式可以自定义 if (this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return 1; &#125; else if (this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; @Override public long getDelay(TimeUnit unit) &#123; //在这里可以写自己的业务逻辑 //将第一个参数中的时间转换为第二个参数中对应的时间单元 return unit.convert(this.runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override public String toString() &#123; return id + \" --- \" + this.runningTime; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; long now = System.currentTimeMillis(); MyTask t1 = new MyTask(now + 1000, 1); MyTask t2 = new MyTask(now + 500, 2); MyTask t3 = new MyTask(now + 2500, 3); MyTask t4 = new MyTask(now + 2000, 4); MyTask t5 = new MyTask(now + 1500, 5); //添加任务 tasks.put(t1); tasks.put(t2); tasks.put(t3); tasks.put(t4); tasks.put(t5); System.out.println(tasks); for (int i = 0; i &lt; 5; i++) &#123; //这里消费任务 System.out.println(tasks.take()); &#125; &#125;&#125; 七、LinkedTransferQueue LinkedTransferQueue的transfer方法就是 如果有消费者在等待的话，生产者就不需要先存到队列中，然后再由消费者去队列中拿，而是由生产者直接交给消费者 没有消费者的话，生产者就会一直等待/阻塞 12345678910111213141516171819202122232425262728public class T07_TransferQueue &#123; public static void main(String[] args) throws InterruptedException &#123; LinkedTransferQueue&lt;String&gt; strs = new LinkedTransferQueue&lt;&gt;(); //启动一个消费者等待 new Thread(() -&gt; &#123; try &#123; //take()如果队列中为空就会等待/阻塞住 System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); //这里主线程相当于生产者，没有消费者就会阻塞，所以主线程阻塞，下面消费者执行不了，就会一直阻塞在这里 strs.transfer(\"aaa\"); /** new Thread(() -&gt; &#123; try &#123; //take()如果队列中为空就会等待/阻塞住 System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); **/ &#125;&#125; 八、SynchronousQueue SynchronousQueue容量为0的队列，不能调用add方法，调用add就会报错。 使用put阻塞，只要有消费者，生产者就直接将元素交给消费者 不能使用add()，报错，因为SynchronousQueue容量为0 12345678910111213141516171819202122232425public class T08_SynchronousQueue &#123; public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;String&gt; strs = new SynchronousQueue&lt;&gt;(); //启动消费者线程 new Thread(() -&gt; &#123; try &#123; System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); //报错，因为SynchronousQueue容量为0// strs.add(\"aaa\"); //生产者使用put(),如果队列满的就阻塞，但是此队列只能为0默认就是满的， //所以只要有消费者就会直接给消费者，没有消费者等待就阻塞在这里。一般先启动消费者 //内部使用的还是transfer() strs.put(\"aaa\"); System.out.println(strs.size()); &#125;&#125; 总结12345678910111213141516171819202122232425261、对于map/set的选择使用（set底层就是使用map来实现的，存的都是map的key） 普通情况: HashMap TreeMap LinkedHashMap 并发量不高的情况下使用 Hashtable Collections.synchronizedXXX 并发量比较高的情况下 ConcurrentHashMap ConcurrentSkipListMap(且要求排序的话，使用跳表实现的)2、队列 普通情况： ArrayList LinkedList 并发： Collections.synchronizedXXX CopyOnWriteList(读多写少) ConcurrentLinkedQueue(非阻塞式的并发队列) BlockingQueue(阻塞式队列) LinkedBlockingQueue(阻塞式的无界队列) ArrayBlockingQueue(阻塞式的有界队列) 下面两个一般用于并发量非常大的情况下，不在容器中进行等待浪费时间，直接由生产者交给消费者 TransferQueue(有消费者线程在等待，生产者直接把数据交给消费者，没有消费者，生产者就阻塞) SynchronusQueue(一种特殊的TransferQueue，容量为0) DelayQueue(执行定时任务)","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"synchronized和ReentrantLock的区别","slug":"2019-05-04-synchronized和ReentrantLock的区别","date":"2019-05-04T05:44:00.000Z","updated":"2019-05-04T06:48:05.660Z","comments":true,"path":"2019/05/04/2019-05-04-synchronized和ReentrantLock的区别/","link":"","permalink":"http://yoursite.com/2019/05/04/2019-05-04-synchronized和ReentrantLock的区别/","excerpt":"","text":"一、synchronized 下面代码m1方法锁定的是 o 对象，也就是堆中那个真实的对象，而不是栈中的引用。m2方法锁定的是this对象，m3方法用synchronized修饰方法，相当于m2方法的synchronized(this)，synchronized修饰m4静态方法相当于synchronized(this.getClass())，锁定就是当前对象所属类的字节码对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class T &#123; Object o = new Object() public void m1() &#123; synchronized(o) &#123; System.out.println(Thread.currentThread().getName() + \" m1 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m1 end...\"); &#125; &#125; public void m2() &#123; synchronized(this) &#123; System.out.println(Thread.currentThread().getName() + \" m2 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m2 end...\"); &#125; &#125; public synchronized void m3() &#123; System.out.println(Thread.currentThread().getName() + \" m3 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m3 end...\"); &#125; public synchronized static void m3() &#123; System.out.println(Thread.currentThread().getName() + \" m3 start...\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" m3 end...\"); &#125;&#125; synchronized支持可重入锁，也就是可以在同步方法中调用使用相同锁对象的同步方法，如下所示 123456789101112131415public class T &#123; public synchronized void m1() &#123; System.out.println(\"m1 method\"); m2(); &#125; public synchronized void m2() &#123; System.out.println(\"m2 method\"); &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m1).start();; &#125;&#125; synchronized执行时如果抛出异常交给jvm处理，会释放锁，因此碰到异常时要小心处理 123456789101112131415161718192021222324252627282930313233343536public class T &#123; int count; public synchronized void m() &#123; System.out.println(Thread.currentThread().getName() + \" start...\"); while(true) &#123; count++; System.out.println(Thread.currentThread().getName() + \" count = \" + count); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (count == 5) &#123; //要想抛异常锁不被释放，这里应该try...catch...捕获到异常正确的处理 //原因：自己没有处理异常jvm就会处理，这时候jvm就会把锁释放 try &#123; int i = 1 / 0; &#125; catch (Exception e) &#123; System.out.println(\"出现了异常\"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m, \"t1\").start(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(t::m, \"t2\").start(); &#125;&#125; synchronized中的代码越少效率越高，因为减少了线程抢占锁的时间 123456789101112131415161718192021222324252627282930313233public class T &#123; int count = 0; synchronized void m1() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //真正需要原子操作的只有下面这一句代码 count++; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; void m2() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(this) &#123; count++; &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 二、ReentrantLock ReentrantLock 可以用来替换synchronized ReentrantLock手动开锁，必须要必须要必须要手动释放锁，因为要手动释放锁，所以报异常时并不会释放锁 12345678910111213141516171819202122232425262728293031323334353637public class ReentrantLock1 &#123; Lock lock = new ReentrantLock(); public void m1() &#123; lock.lock(); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; Thread.sleep(1000); System.out.println(i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void m2() &#123; lock.lock(); System.out.println(\"m2...\"); lock.unlock(); &#125; public static void main(String[] args) &#123; ReentrantLock1 r = new ReentrantLock1(); new Thread(r::m1).start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(r::m2).start(); &#125;&#125; ReentrantLock可以使用tryLock尝试拿下锁，根据是否拿到锁进行不同的业务处理，也可以指定允许等待锁的时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ReentrantLock2 &#123; Lock lock = new ReentrantLock(); public void m1() &#123; lock.lock(); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; Thread.sleep(1000); System.out.println(i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void m2() &#123; //尝试拿锁 boolean isLock = lock.tryLock(); if (isLock) &#123; System.out.println(\"执行拿到的锁的业务逻辑：\" + isLock); lock.unlock(); &#125; else &#123; System.out.println(\"执行没有拿到锁的业务逻辑：\" + isLock); &#125; /*boolean isLock = false; try &#123; //尝试等待5秒，看是否能拿到锁 isLock = lock.tryLock(5, TimeUnit.SECONDS); if (isLock) &#123; System.out.println(\"执行拿到的锁的业务逻辑：\" + isLock); &#125; else &#123; System.out.println(\"执行没有拿到锁的业务逻辑：\" + isLock); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (isLock) &#123; lock.unlock(); &#125; &#125;*/ &#125; public static void main(String[] args) &#123; ReentrantLock2 r = new ReentrantLock2(); new Thread(r::m1).start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(r::m2).start(); &#125;&#125; lockInterruptibly()可对interrupt()作出响应，这个拿锁如果一直拿不到可被打断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ReentrantLock3 &#123; public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(\"t1 start...\"); //基本上就是在这死等着了 Thread.sleep(Integer.MAX_VALUE); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); //如果释放锁了,t2线程就能拿到这把锁 System.out.println(\"t1 end...\"); &#125; &#125;); t1.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread t2 = new Thread(() -&gt; &#123; System.out.println(\"t2 start...\"); try &#123;// lock.lock(); //对interrupt()作出响应，可被打断的拿锁 lock.lockInterruptibly(); &#125; catch (Exception e) &#123; System.out.println(\"interrupted!\"); &#125; finally &#123; lock.unlock(); System.out.println(\"t2 end...\"); &#125; &#125;); t2.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //使t2线程不要一直在那等待锁了，直接停止 t2.interrupt(); &#125;&#125; ReentrantLock默认构造器为非公平锁,构造器传true可以指定为公平锁 非公平锁:谁拿到锁不确定,全靠CPU调度 公平锁:线程拿锁的机会平均 12345678910111213141516171819public class ReentrantLock4 extends Thread &#123;// Lock lock = new ReentrantLock(); Lock lock = new ReentrantLock(true); public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + \"拿到了锁\"); lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ReentrantLock4 r = new ReentrantLock4(); new Thread(r).start(); new Thread(r).start(); &#125;&#125; 三、生产者消费者模式自定义一个固定容量同步容器,具有put,get,getCount方法. 能够支持2个生产者线程以及10个消费者线程的阻塞调用 1、使用synchronized​ 1）判断那里为什么使用while而不是if？ 12因为while会一直判断,而if只会判断一次比如有两个生产者线程t1和t2,两个都被唤醒了,当t1拿到锁后往里扔了一个,这时候容器满了,执行完后释放锁,这时候t2线程又拿到了锁,因为if判断之前只判断了一次,所以这时候不会判断了,拿到锁之后继续执行添加,此时容器已经满了,这里就会出问题 ​ 2）使用notifyAll()而不是notify() 1唤醒所有线程这里使用notifyAll而不是notify,如果使用notify又唤醒了一个生产者线程而不是消费者线程,生产者线程判断此时容器满了它就会等待,此时程序就卡住了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MyContainer1&lt;T&gt; &#123; private final LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;(); //容器最大容量为10 private static final int MAX = 10; private int count = 0; public synchronized void put(T t) &#123; while(list.size() == MAX) &#123; try &#123; //如果当前容量满了就等待然后释放锁 this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果没有满就往里添加 list.add(t); ++count; System.out.println(Thread.currentThread().getName() + \"生产了第\" + count + \"个元 素\"); this.notifyAll(); &#125; public synchronized T get() &#123; while(list.size() == 0) &#123; try &#123; //如果容器中没有数据了就等待 this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //有数据就减少一个并且唤醒所有线程(生产者线程进行生产),返回一个元素 System.out.println(Thread.currentThread().getName() + \"消费了第\" + count + \"个元 素\"); --count; this.notifyAll(); return list.removeFirst(); &#125; public int getCount() &#123; return count; &#125; public static void main(String[] args) &#123; MyContainer1&lt;Object&gt; c = new MyContainer1&lt;&gt;(); //先启动十个消费者线程进行等待 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; //一次消费5个 for (int j = 1; j &lt;= 5; j++) &#123; c.get(); &#125; &#125;, \"c\" + i).start(); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //再启动2个生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(() -&gt; &#123; //生产者一次生产25个 for (int j = 1; j &lt;= 25; j++) &#123; c.put(j); &#125; &#125;,\"p\" + i).start(); &#125; &#125;&#125; 2、使用ReentrantLock实现​ 使用ReentrantLock实现显然效率要高一点，这里可以使用Condition来指定线程在哪个条件上等待，后面唤 醒的时候直接在对应的条件上唤醒，而不是唤醒所有的线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class MyContainer2&lt;T&gt; &#123; private final LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;(); // 容器最大容量为10 private static final int MAX = 10; private int count = 0; private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); public void put(T t) &#123; try &#123; lock.lock(); while (list.size() == MAX) &#123; //如果当前容量满了就等待然后释放锁 producer.await(); &#125; // 如果没有满就往里添加 list.add(t); ++count; System.out.println(Thread.currentThread().getName() + \"生产了第\" + count + \"个 元素\"); // 唤醒所有在consumer条件上等待的线程 consumer.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public T get() &#123; T t = null; try &#123; lock.lock(); while (list.size() == 0) &#123; //如果容器中没有数据了就等待 consumer.await(); &#125; //有数据就减少一个并且唤醒所有线程(生产者线程进行生产),返回一个元素 System.out.println(Thread.currentThread().getName() + \"消费了第\" + count + \"个 元素\"); --count; //唤醒所有在producer条件上等待的线程 producer.signalAll(); t = list.removeFirst(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; return t; &#125; public int getCount() &#123; return count; &#125; public static void main(String[] args) &#123; MyContainer2&lt;Object&gt; c = new MyContainer2&lt;&gt;(); // 先启动十个消费者线程进行等待 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; // 一个消费者可以消费5个 for (int j = 1; j &lt;= 5; j++) &#123; c.get(); &#125; &#125;, \"c\" + i).start(); &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 再启动2个生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(() -&gt; &#123; // 一个生产者可以生产25个 for (int j = 1; j &lt;= 25; j++) &#123; c.put(j); &#125; &#125;, \"p\" + i).start(); &#125; &#125;&#125; 结论： ReentrantLock 可以用来替换synchronized ReentrantLock手动开锁，必须要必须要必须要手动释放锁 synchronized报异常时jvm会手动释放锁，ReentrantLock不会释放 ReentrantLock比synchronized要灵活 ReentrantLock可以指定为公平锁 ReentrantLock还可以打断拿锁，尝试拿锁，指定线程在哪个条件上等待 它们都是可重入锁，虽然ReentrantLock比synchronized看起来要好很多，但是synchronized实现简单，语义清晰，便于JVM堆栈跟踪，加锁解锁过程由JVM自动控制，具体使用哪个看实际中的业务。","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"volatile和synchronized的区别","slug":"2019-04-27-volatile和synchronized的区别","date":"2019-04-27T10:20:00.000Z","updated":"2019-04-27T14:04:28.002Z","comments":true,"path":"2019/04/27/2019-04-27-volatile和synchronized的区别/","link":"","permalink":"http://yoursite.com/2019/04/27/2019-04-27-volatile和synchronized的区别/","excerpt":"","text":"1、先看一段代码 123456789101112131415161718192021222324public class T &#123; boolean isRunning = true; public void m() &#123; System.out.println(\"m start...\"); while(isRunning) &#123; &#125; System.out.println(\"m end...\"); &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m, \"t1\").start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.isRunning = false; &#125; &#125; 首先新建一个线程t1启动，调用m方法，进入死循环，按道理来说我主线程执行到下面的时候把isRunning改成false就会结束t1线程中的死循环，但是执行你会发现并不会结束。 这是因为每个线程运行都会有自己的一份内存也可以叫做缓冲区，比如下面这张图，上面一个t1线程和主线程分别占用一个CPU，那么CPU中会有个对应线程的缓冲区。 代码执行过程：栈内存，堆内存，方法区之类的内存称之为主内存，堆内存对应的t对象中有个成员变量isRunning=true，在t1线程启动的时候会从主内存中copy一份isRunning（boolean类型为一个字节）的值到自己的缓冲区中，然后就开始死循环一直执行下去，这时候主线程把isRunning的值copy到自己的缓冲区然后执行isRunning=false并且写会主内存中去，但是t1线程是非常繁忙的，一直在执行死循环没有时间去主内存刷新自己isRunning的值，所以就算主线程修改了isRunning的值，t1线程还是死循环 解决方法：在isRunning成员变量前面加上volatile关键字 volatile关键字的作用：就是保持线程的可见性，只要该变量的值修改了，就会通知其他线程你们缓冲区中的copy过期了，需要重新来主内存中刷新一下，这时候t1线程就会得到通知，并且来主内存中刷新isRunning的值，从而停止死循环。注意：使用volatile的作用不是t1线程会每次使用到isRunning的时候都去主内存中读一下isRunning的值，而是主内存中的isRunning被修改了，就会通知所有的使用到isRunning的线程来主内存中刷新一下isRunning的值 也可以在死循环中sleep一段时间，或者打印一些语句，使CPU不要太忙，得出空闲就会来主内存中刷新isRunning的值，但是这样是不稳定的，我怎么知道你CPU什么时候空闲，所以该用volatile还是得用volatile 2、再来看一段代码 1234567891011121314151617181920212223242526272829public class T &#123; volatile int count = 0; public void m() &#123; for (int i = 0; i &lt; 10000; i++) &#123; count++; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, \"thread-\" + i)); &#125; threads.forEach(o -&gt; o.start()); threads.forEach(o -&gt; &#123; try &#123; //等待所有线程结束 o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 按照正常的思路打印出来应该是100000，但是打印出来的结果会远远小于100000，因为volatile只保证可见性不保证原子性，而count++不是原子性操作，分为拿到count的值，然后加1，再赋值。这时候如果有两个线程同时拿到count=100到缓冲区中，加1再写入主内存中。这时候两个线程合起来只增加了1，所以最终会少很多。这里保证的可见性，只保证线程拿到的值一定是最新的。 解决方法： 成员变量上不加volatile，用synchronized修饰m方法，或者用synchronized同步代码块包裹住count++ 或者使用如果仅仅只是一些自增自减，判断是否为true等之类的操作，没必要使用synchronized来保证原子性，Java中提供了很AtomicXXX类，原子操作的类，就是该类中的所有方法都是原子性的。不是使用synchronized保证原子性，使用的是很底层的方式，比synchronized效率要高。但是该类两个方法同时使用时不能保证原子性（在两个方法调用的之间还是有可能会被别的线程抢占进入） 12345678910111213141516171819202122232425262728public class T &#123; AtomicInteger count = new AtomicInteger(0); public void m() &#123; for (int i = 0; i &lt; 10000; i++) &#123; count.incrementAndGet(); &#125; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, \"thread-\" + i)); &#125; threads.forEach(o -&gt; o.start()); threads.forEach(o -&gt; &#123; try &#123; //等待所有线程结束 o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 结论：volatile只保证线程的可见性，synchronized既保证可见性也保证原子性，但是synchronized相对于volatile效率会低很多，所以能用volatile替代synchronized，就尽量使用volatile。","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"author":"Yang"},{"title":"HashMap实现原理","slug":"2019-04-21-HashMap实现原理","date":"2019-04-21T13:19:00.000Z","updated":"2019-04-21T14:21:53.933Z","comments":true,"path":"2019/04/21/2019-04-21-HashMap实现原理/","link":"","permalink":"http://yoursite.com/2019/04/21/2019-04-21-HashMap实现原理/","excerpt":"","text":"HashMap底层是通过数组加单项链表的方式实现的 初始数组长度为16 链表中的节点具有的元素为 hash：用hashCode（哈希码）通过hash算法计算出来的哈希值 key：键值对的key value：键值对的value next：下一个节点 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125; put(key, value) 首先会获取key的hashCode，根据hash算法（比如hashCode%数组的长度）算出对应的hash(哈希值)，就把哈希值作为下标，将Node对象（hash(哈希值)，key，value，next[只有一个的话就为null]）放入对应的下标位置中。 再来一个就重复上面的操作，如果key算出的哈希值一样的话，就用equals对比key，如果返回true，就覆盖，如果equals对比返回false，就将其添加在该下标位置中的单链表末尾。并设置上一个Node节点的next属性指向现在添加的Node。以此类推。 因为hashCode一样，equals还是有可能会为false。hashCode取余可能最终会得到相同的哈希值 Java中规定 1、equals为true，则hashCode必须一样。反之不成立，也就是hashCode一样，equals不一定为true hashCode本身是根据在jvm中的内存地址使用hash算法算出来的int类型的数，如果equals为true，说明两个对象在内存中的地址是一样的，所以根据在jvm中的内存地址使用hash算法算出来的hashCode肯定也一样。 hashCode一样，equals也有可能为false，因为hashCode是int类型的，最多允许存在2^32个分组，也是有限的，而jvm中的内存地址不止这么多，因此不同的内存地址根据hash算法算出来的hashCode也是有可能一致的。所以hashCode一样，equals不一定为true 2、重写equals方法一定要重写hashCode方法 get(key) 根据key获取对应hashCode，根据hash算法算出对应的哈希值，把哈希值当作下标去数组找找到对应的位置，使用key从头节点开始遍历，equals每个节点中的key，如果返回true，就将其对应的value返回 在Java8之后只要数组中的链表长度为8时，就会将链表转 化为红黑树，以减少搜索时间。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"author":"Yang"},{"title":"计算机的位移运算","slug":"2019-04-18-计算机的位移运算","date":"2019-04-18T14:20:00.000Z","updated":"2019-04-18T14:21:51.171Z","comments":true,"path":"2019/04/18/2019-04-18-计算机的位移运算/","link":"","permalink":"http://yoursite.com/2019/04/18/2019-04-18-计算机的位移运算/","excerpt":"","text":"最近看编程思想看到操作符这章实在不理解位运算那地方的例子： 其实就是不明白计算机中是怎么进行位运算和负数是怎么表示的。网上查阅博客都是千篇一律，没有解决问题，且没有根据，今天看到《码出高效》这本书还没看过，就翻开看看，第一章就是讲位运算，看完之后豁然开朗，总结下计算机中是怎么进行位运算的。 一、计算机中负数的运算计算机中是以二进制补码进行存储的，正数的原码、反码、补码都是一样，负数的补码是原码的反码再加1，这样可以减法运算可以使用加法器实现，符号位也参与运算（二进制的最高位为符号位0为正，1为负，以8位来算，最高位为符号位，其余7位表示数值），取反码与符号位无关。 eg： 1234547 + (-47) 在计算机中这样运算 0010 1111+ 1101 0001 (-47的补码) 原码：1010 1111 补码：1101 0001------------ 0000 0000（遇2进1，最后的结果就是0） 二、移位操作移位分为有符号左移（&lt;&lt;），有符号右移（&gt;&gt;） 无符号右移（&gt;&gt;&gt;）没有无符号左移（&lt;&lt;&lt;） 1、有符号位移运算，何为有符号左移、右移，因为计算机中符号位最高位0代表正数，1代表负数，所以正数有符号右移高位补0，负数有符号右移高位补1，不管有无符号位移运算左移低位都是补0。 借书上的的例子： 负数位移运算根据补码来移位（符号位也要跟着移位，取反码与符号位无关，符号位不参与数值表示） 最终高位如果为0，说明正数不用进行操作，按照二进制转换成十进制就是结果了。 如果高位为1，说明是负数，也就是补码，可以补码减1再取反码就是原码了，也可以根据结果取反码再加1就是原码（补码的补码就是原码），按照二进制转换成十进制就是结果了。 2、无符号位运算 无符号位移运算意思是我不关心你的符号位，（而有符号位移运算会根据是正数还是负数高位会进行不同的补位），不管正数负数高位都补0，只有无符号右移（&gt;&gt;&gt;），没有无符号左移（&lt;&lt;&lt;），因为符号位在左边，你往左移影响不到符号位，没有意义。 继续借书上的例子（允许偷点懒） 总结：1、计算机中是以补码进行存储的，最高位为符号位。 2、符号位不参与反码，符号位不参与数值表示，符号位参与位移运算移位，符号位参与运算加法 3、位移运算移动按补码进行移动，结果的高位为0，说明是正数，不需要操作 如果高位为1，说明是负数，得到的结果是补码，则取反加1得到原码 4、输入给计算机的二进制码，计算机会当作原码进行处理，而计算机输出的二进制码是补 码（正数的补码即原码，负数需要转换得到最终的结果） 码出高效这本书全是干货，后面应该会有更大的惊喜。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"author":"Yang"},{"title":"处理同一个用户多处登录","slug":"2019-04-17-处理同一个用户多处登录","date":"2019-04-17T01:30:00.000Z","updated":"2019-04-17T02:33:38.146Z","comments":true,"path":"2019/04/17/2019-04-17-处理同一个用户多处登录/","link":"","permalink":"http://yoursite.com/2019/04/17/2019-04-17-处理同一个用户多处登录/","excerpt":"","text":"qq都用过，在不同的手机上登录同一个用户后面登录的会把之前的挤掉，游戏也是这样，像LOL，后面登录的都会把前面登录的用户给挤掉。最近做项目中也使用了这种原理 一、思想HttpSession 的原理是基于 Cookie 的，只要访问当前网站，就会有一个名称为 JSESSIONID 的 Cookie ，第一次创建 HttpSession 对象，就是第一次执行到 request.getSession() 这个方法时，在 getSession() 方法里面就会获取到名称为 JSESSIONID 的 Cookie ，根据对应的 value 去服务端查找对应的 HttpSession 对象，如果没有找到就会创建 HttpSession 对象，此时，HttpSession 对象被创建，当前会话如果不关闭，每次请求响应都会带着名称为 JSESSIONID 的 Cookie ，第二次执行到 request.getSession() 方法时，就不用创建 HttpSession 对象了，会把第一次执行到该方法创建的 HttpSession 对象返回，所以这也就是一次会话中只有一个 HttpSession对象。 基于上面 HttpSession的原理，就有了解决同一个用户多处登录，挤掉上一次登录的解决方案了。 可以写一个 HttpSessionListener ，只要有对应的 HttpSession 对象创建，就会被监听到，只要有 HttpSession对象被创建，就可以把当前的 HttpSession 对象存到一个 Map 中，key 为 sessionId，value 为 HttpSession对象 每次登录成功后把 userId当作 key ，当前会话的 currentSessionId 当作value，存入到一个 Map 中。这样就与上面的 Map 通过一个 currentSessionId 联系起来了。不过在每次存入之前都根据当前的 userId 当作key，在当前的 Map 中找下有没有对应的 sessionId ，如果sessionId不为空且和当前的 currentSessionId 不一致，那么说明当前登录就是同一个用户在不同的地方第二次登录。我们就可以根据之前的 sessionId 当作 key，去前面的 Map 中获取到对应的 HttpSession 对象，并将其销毁，那么第一次登录的地方再请求通过携带的 JSESSIONID 获取不到之前的 HttpSession 对象，此时就会创建一个新的 HttpSession 对象，在拦截器中根据这个新的 HttpSession 对象就获取不到 User 对象了，此时就会跳转到登录页面，达到同一个用户在不同地方同时登录，后面会把前面的用户给挤掉的功能。 二、代码实现怎么让上面两个Map让应用中只有唯一的一个呢，可以写一个管理类，将这两个 Map 作为该管理类的成员变量，然后将管理类交给Spring容器类管理，Spring容器中的Bean都是单例的，就能达到整个应用中只有唯一的一个了 SpringUtils类 这里碰到个坑，因为 HttpSessionListener 是tomcat来实例化的，并不能加入到 Spring容器中通过Spring容器来实例化，这样也就不能在 HttpSessionListener 实现类中自动注入组件，只能直接获取到Spring容器调用Spring容器中的方法来获取对应的Bean。 在Spring容器创建时，Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。 12345678910111213141516171819202122232425262728293031323334353637/** * spring 帮助类 * * @author pineapple * @create 2019/3/5 */@Componentpublic class SpringUtils implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; if(SpringUtils.applicationContext == null)&#123; SpringUtils.applicationContext = applicationContext; &#125; &#125; public static ApplicationContext getApplicationContext()&#123; return applicationContext; &#125; //根据name public static Object getBean(String name)&#123; return getApplicationContext().getBean(name); &#125; //根据类型 public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123; return getApplicationContext().getBean(clazz); &#125; public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123; return getApplicationContext().getBean(name,clazz); &#125;&#125; UserSessionManager（管理类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Componentpublic class UserSessionManager &#123; //userId : sessionId private ConcurrentHashMap&lt;String, String&gt; userSessionMap = new ConcurrentHashMap&lt;&gt;(); //sessionId : HttpSession对象 private ConcurrentHashMap&lt;String, HttpSession&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /** * UserSessionMap中增加一条键值对 * @param userId * @param sessionId */ public void putUserSessionMap(String userId, String sessionId) &#123; userSessionMap.put(userId, sessionId); &#125; /** * 根据SessionId删除对应的键值对 * @param sessionId */ public void removeInUserSessionMap(String sessionId) &#123; String key = null; for (Map.Entry&lt;String, String&gt; entry : userSessionMap.entrySet()) &#123; String value = entry.getValue(); if (Objects.equals(value, sessionId)) &#123; key = entry.getKey(); break; &#125; &#125; if (key != null) &#123; userSessionMap.remove(key); &#125; &#125; /** * 根据userId去UserSessionMap中获取对应的SessionId * @param userId */ public String getSessionIdByUserId(String userId) &#123; return userSessionMap.get(userId); &#125; /** * 往SessionMap中增加一条键值对 * @param sessionId * @param session */ public void putSessionMap(String sessionId, HttpSession session) &#123; sessionMap.put(sessionId, session); &#125; /** * 根据sessionId销毁HttpSession对象 * @param sessionId */ public void destoryInSessionMap(String sessionId) &#123; HttpSession session = sessionMap.get(sessionId); if (null != session) &#123; session.invalidate(); &#125; //如果包含当前的key，且获取到的session对象又为null，说明对应的HttpSession对象过期了， //需要移除到对应的key，节省内存 if (sessionMap.contains(sessionId) &amp;&amp; session == null) &#123; sessionMap.remove(sessionId); &#125; &#125; /** * 处理多用户登录，登录成功时调用该方法&lt;br/&gt; * 先根据userId去userSessionMap中获取对应的sessionId如果sessionId不为null且与当前 * currentSessionId不一致的话就根据sessionId去sessionMap中获取对应的HttpSession对象并销毁 * 否则的话就把当前的userId和currentSessionId存在UserSessionMap中 * * @param currentSessionId * @param userId */ public void handleMoreUserLogin(String userId, String currentSessionId) &#123; String sessionId = getSessionIdByUserId(userId); if (null != sessionId &amp;&amp; !Objects.equals(sessionId, currentSessionId)) &#123; destoryInSessionMap(sessionId); &#125; putUserSessionMap(userId, currentSessionId); &#125;&#125; HttpSessionLoginListener 12345678910111213141516171819202122@WebListenerpublic class HttpSessionLoginListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123; //监听到HttpSession被创建时，就把当前HttpSession对象存储在SessionMap中 HttpSession session = httpSessionEvent.getSession(); UserSessionManager userSessionManager = SpringUtils.getBean(UserSessionManager.class); userSessionManager.putSessionMap(session.getId(), session); &#125; @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123; //当有HttpSession对象被销毁时就删除UserSessionMap中的键值对 String sessionId = httpSessionEvent.getSession().getId(); UserSessionManager userSessionManager = SpringUtils.getBean(UserSessionManager.class); userSessionManager.removeInUserSessionMap(sessionId); &#125;&#125; 仔细看上面的代码这样每次在登录成功后就调用userSessionManager类中的handleMoreUserLogin方法 12//处理多处同时登录该用户的情况userSessionManager.handleMoreUserLogin(user.getId() + \"\", session.getId());","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"author":"Yang"},{"title":"Spring Boot学习15_监控管理（完结）","slug":"2019-04-14-SpringBoot学习15_监控管理","date":"2019-04-14T01:57:00.000Z","updated":"2019-04-14T03:25:43.715Z","comments":true,"path":"2019/04/14/2019-04-14-SpringBoot学习15_监控管理/","link":"","permalink":"http://yoursite.com/2019/04/14/2019-04-14-SpringBoot学习15_监控管理/","excerpt":"","text":"通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进行操作，自动得到审计、健康及指标信息等 一、端点介绍通过执行器端点，您可以监控应用程序并与之交互。Spring Boot包含许多内置端点，允许您添加自己的端点。例如， health端点提供基本的应用程序健康信息。 可以启用或禁用每个端点。它控制是否创建端点并且其3bean存在于应用程序上下文中。要进行远程访问，还必须通过JMX或HTTP公开端点。大多数应用程序选择HTTP，其中端点的ID以及前缀/actuator映射到URL。例如，默认情况下，health映射到/actuator/health 下图对每个端点进行了介绍，以及默认情况下是否启用 ID 描述 默认情况下启用 auditevents 公开当前应用程序的审核事件信息。 是 beans 显示应用程序中所有Spring bean的完整列表。 是 caches 暴露可用的缓存。 是 conditions 显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。 是 configprops 显示所有的整理列表@ConfigurationProperties。 是 env 露出Spring的属性ConfigurableEnvironment。 是 flyway 显示已应用的任何Flyway数据库迁移。 是 health 显示应用健康信息。 是 httptrace 显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）。 是 info 显示任意应用信息。 是 integrationgraph 显示Spring Integration图。 是 loggers 显示和修改应用程序中记录器的配置。 是 liquibase 显示已应用的任何Liquibase数据库迁移。 是 metrics 显示当前应用程序的“指标”信息。 是 mappings 显示所有@RequestMapping路径的整理列表。 是 scheduledtasks 显示应用程序中的计划任务。 是 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用。 是 shutdown 允许应用程序正常关闭。 没有 threaddump 执行线程转储。 是 二、启用端点默认情况下，除了shutdown之外的端点都会被启用，可以通过management.endpoint.&lt;id&gt;.enabled来启用或禁止某个端点，以下示例启用shutdown端点 1management.endpoint.shutdown.enabled = true 三、暴露端点端点启用了，要想访问还得通过配置来暴露端点。web端默认暴露的就是health和info其他都不会被暴露。 可以通过include和exclude来配置 include属性列出了公开的端点的ID。该exclude 属性列出了不应公开的端点的ID。该exclude 属性优先于该include属性。 *可用于选择所有端点。例如，要通过HTTP公开除了env和beans端点之外的所有内容，请使用以下属性： 12management.endpoints.web.exposure.include = *management.endpoints.web.exposure.exclude = env，beans 四、Demo pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 全局配置文件application.properties 1234#默认端点都是激活的除了shutdownmanagement.endpoint.shutdown.enabled=true#默认端点只有health和info暴露，可以使用如下所示暴露所有端点management.endpoints.web.exposure.include=* 启动应用，测试http://localhost:8080/actuator/beans返回所有Spring容器中所有bean的信息 通过post请求shutdown远程关闭应用 设置访问端点的前缀（默认是actuator）：management.endpoints.web.base-path=/manage 设置访问端点的端口：management.server.port=9000 通过management.endpoints.web.path-mapping.&lt;id&gt;的方式来自定义某个端点的访问路径 下面例子展示了自定义beans端点的访问路径 1management.endpoints.web.path-mapping.beans=mybean 五、自定义健康指示器1、默认的健康指示器 显示健康具体信息，默认不会 显示 management.endpoint.health.show-details=always 在org.springframework.boot.actuate包下面有很多SpringBoot为我们写好的指示器，比如Rabbit的，Redis的，只要引入了对应的starter这些指示器就会生效 引入redis的starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 我启动虚拟机上的redis，并指定虚拟机的ip，这时候再访问http://localhost:8080/actuator/health就显示了UP，启用状态。这样我们在生产环境中，就可以通过http的方式知道我们环境中的某些组件的运行事健康状态 2、自定义健康指示器 实现HealthIndicator接口 1234567891011121314@Componentpublic class MyAppHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; //可以通过自己的业务逻辑来确定健康状态 long currentTime = System.currentTimeMillis(); if (currentTime % 2 == 0) &#123; return Health.up().withDetail(\"success\", \"健康\").build(); &#125; else &#123; return Health.down().withDetail(\"Error Msg\", \"You'll never start it, hahaha!\").build(); &#125; &#125;&#125; 访问http://localhost:8080/actuator/health出现自定义的指示器健康状态","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习14_热部署","slug":"2019-04-13-SpringBoot学习14_热部署","date":"2019-04-13T14:31:00.000Z","updated":"2019-04-14T02:44:00.193Z","comments":true,"path":"2019/04/13/2019-04-13-SpringBoot学习14_热部署/","link":"","permalink":"http://yoursite.com/2019/04/13/2019-04-13-SpringBoot学习14_热部署/","excerpt":"","text":"在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 1、模板引擎–在Spring Boot中开发情况下禁用模板引擎的cache –页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring LoadedSpring官方提供的热部署程序，实现修改类文件的热部署 –下载Spring Loaded（项目地址&lt;https://github.com/spring-projects/spring-loaded&gt;） –添加运行时参数； -javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify 3、JRebel收费的一个热部署软件 安装插件使用即可 4、Spring Boot Devtools（推荐） 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; IDEA使用ctrl+F9 或做一些小调整 Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习13_分布式","slug":"2019-04-13-SpringBoot学习13_分布式","date":"2019-04-13T13:31:00.000Z","updated":"2019-04-14T02:39:18.779Z","comments":true,"path":"2019/04/13/2019-04-13-SpringBoot学习13_分布式/","link":"","permalink":"http://yoursite.com/2019/04/13/2019-04-13-SpringBoot学习13_分布式/","excerpt":"","text":"一、在SpringBoot中使用Zookeeper+Dubbo实现分布式调用1、新建一个interface工程，该工程只用来创建接口（将工程打包） TicketService接口类 123public interface TicketService &#123; String getTicket(int date);&#125; 2、新建producer-ticket工程 在主配置程序类上标注@EnableDubbo 引入maven依赖 12345678910111213141516171819&lt;!-- 引入接口依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.ahead&lt;/groupId&gt; &lt;artifactId&gt;ticket-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入Dubbo的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入zookeeper的客户端工具--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 全局配置文件application.yml 123456789101112dubbo: #设置应用名称 application: name: product-ticket #表示采用的dubbo协议 protocol: name: dubbo #发布的端口号 port: 20880 #zookeeper注册中心地址 registry: address: zookeeper://192.168.25.128:2181 TicketService的实现类TicketServiceImpl，使用dubbo的注解@Service将服务注册到zookeeper中 1234567891011121314package com.ahead.service.impl;import com.ahead.service.TicketService;import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Component@Service //将服务注册到zookeeperpublic class TicketServiceImpl implements TicketService &#123; @Override public String getTicket(int date) &#123; return \"&lt;复仇者联盟4&gt; ---\" + date + \"号\"; &#125;&#125; 3、新建consumer-user工程 在主配置程序类上标注@EnableDubbo 引入maven依赖 12345678910111213141516171819&lt;!-- 引入接口依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.ahead&lt;/groupId&gt; &lt;artifactId&gt;ticket-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入Dubbo的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入zookeeper的客户端工具--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 全局配置文件application.yml 12345678910dubbo: #设置应用名称 application: name: consumer-user #zookeeper注册中心地址 registry: address: zookeeper://192.168.25.128:2181#默认是8080，上面已经使用8080了，这里需要设置不同的端口号防止冲突server: port: 8081 在Service层中用Dobbo的注解@Reference引用服务进行消费 123456789101112131415161718import com.alibaba.dubbo.config.annotation.Reference;import org.springframework.stereotype.Service;/** * @author Yang * @version 1.0 * @time 2019/4/7 */@Servicepublic class UserService &#123; @Reference private TicketService ticketService; public String buyTicket(int date) &#123; return ticketService.getTicket(date); &#125;&#125; 测试类 12345678@Autowiredprivate UserService userService;@Testpublic void contextLoads() &#123; String ticket = userService.buyTicket(4); System.out.println(ticket);&#125; 4、在虚拟机中启动zookeeper，然后启动producer-ticket提供服务的工程，执行consumer-user工程中的测试方法。 二、整合SpringCloud实现分布式调用1、新建eureka-server工程作为注册中心 对应的pom依赖如下 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; 全局配置文件application.yml 1234567891011121314server: port: 8761eureka: instance: # eureka实例的主机名 hostname: eureka-server client: #不把自己注册到eureka上 register-with-eureka: false #不从eureka上获取服务的注册信息（因为自己不是消费者，不需要服务的注册信息） fetch-registry: false #指定注册中心的地址 service-url: defaultZone: http://localhost:8761/eureka/ 在主程序配置类上标注@EnableEurekaServer 启动应用访问http://localhost:8761/出现如下页面表示配置成功 2、创建提供服务的工程eureka-producer-ticket 对应的pom如下 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 全局配置文件application.yml 1234567891011121314server: port: 8002spring: application: name: producer-ticketeureka: instance: #注册服务的时候使用服务的ip地址 prefer-ip-address: true client: #指定注册中心的地址 service-url: defaultZone: http://localhost:8761/eureka/ Service类 1234567@Servicepublic class TicketService &#123; public String getTicket(int date) &#123; return \"&lt;复仇者联盟4&gt; ---\" + date + \"号\"; &#125;&#125; 因为SpringCloud是通过http Rest请求来调用服务的，所以写一个Controller层暴露给消费工程调用 123456789101112@RestControllerpublic class TicketController &#123; @Autowired private TicketService ticketService; @GetMapping(\"/ticket/&#123;date&#125;\") public String ticket(@PathVariable int date) &#123; System.out.println(\"8002\"); return ticketService.getTicket(date); &#125;&#125; 3、创建消费服务的工程eureka-consumer-user pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 全局配置文件application.yml 123456789101112131415server: port: 8200#指定应用的名称spring: application: name: consumer-usereureka: instance: #注册服务的时候使用服务的ip地址 prefer-ip-address: true client: #指定注册中心的地址 service-url: defaultZone: http://localhost:8761/eureka/ 1.在主程序配置类上标注@EnableDiscoveryClient开启服务发现功能 2.注册RestTemplate注解并通过LoadBalanced开启负载均衡调用服务 12345678910111213141516171819202122/** * 开启发现服务功能 */@EnableDiscoveryClient@SpringBootApplicationpublic class Springboot14EurekaConsumerUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot14EurekaConsumerUserApplication.class, args); &#125; /** * @LoadBalanced开启负载均衡调用服务 * @return */ @LoadBalanced @Bean public RestTemplate restTemplate () &#123; return new RestTemplate(); &#125;&#125; Controller层：通过restTemplate远程调用服务，PRODUCER-TICKET是提供服务的应用名称 1234567891011121314@RestControllerpublic class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(\"/buy/&#123;name&#125;/&#123;date&#125;\") public String buy(@PathVariable String name, @PathVariable int date) &#123; String s = restTemplate.getForObject(\"http://PRODUCER-TICKET/ticket/\"+date, String.class); return name + \" buy \" + s; &#125;&#125; 4、测试 启动eureka-server工程 打包eureka-producer-ticket成两个不同的jar包(只修改了端口号分别为8001，8002)，然后java -jar启动 启动eureka-consumer-user应用 访问http://localhost:8761/可以看到已经多了两个提供服务的应用，和一个消费服务的应用 请求eureka-consumer-user工程中的Controller两次 查看提供服务的工程，发现一边调用了一次","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习12_安全","slug":"2019-04-12-SpringBoot学习12_安全","date":"2019-04-12T13:03:00.000Z","updated":"2019-04-12T14:37:03.413Z","comments":true,"path":"2019/04/12/2019-04-12-SpringBoot学习12_安全/","link":"","permalink":"http://yoursite.com/2019/04/12/2019-04-12-SpringBoot学习12_安全/","excerpt":"","text":"一、Demo（使用Thymeleaf整合Security） pom.xml 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;!-- 切换Thymeleaf版本 --&gt; &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf与security整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Controllerpublic class KungfuController &#123; private final String PREFIX = \"pages/\"; /** * 欢迎页 * @return */ @GetMapping(\"/\") public String index() &#123; return \"welcome\"; &#125; /** * 登陆页 * @return */ @GetMapping(\"/userlogin\") public String loginPage() &#123; return PREFIX+\"login\"; &#125; /** * level1页面映射 * @param path * @return */ @GetMapping(\"/level1/&#123;path&#125;\") public String level1(@PathVariable(\"path\")String path) &#123; return PREFIX+\"level1/\"+path; &#125; /** * level2页面映射 * @param path * @return */ @GetMapping(\"/level2/&#123;path&#125;\") public String level2(@PathVariable(\"path\")String path) &#123; return PREFIX+\"level2/\"+path; &#125; /** * level3页面映射 * @param path * @return */ @GetMapping(\"/level3/&#123;path&#125;\") public String level3(@PathVariable(\"path\")String path) &#123; return PREFIX+\"level3/\"+path; &#125;&#125; WebSecurityConfigurerAdapter的子类MySecurityConfig，使用@EnableWebSecurity开启WEB安全 1、定制请求的规则，/不需要经过授权，/level1/**需要VIP1的权限才能访问（没有权限就会跳到登录页面），其他同理 2、默认开启了登录http.formLogin();，以Get方式请求/login就会跳转到Spring写好的登录页面，以Post请求/login就会处理登录请求（Spring会处理） 3、自定义注销按钮http.logout();，设置请求/logout就会处理注销清除用户登录记录（Spring会处理），默认注销后重定向/login?logout（登录页面）请求中，通过http.logout().logoutSuccessUrl(&quot;/&quot;);自定义请求注销后重定向到哪个请求上 4、开启记住我（自动登录）功能http.rememberMe();原理跟Servlet时期使用一样：把用户名和密码存到Cookie中，下次访问该网站时会带上Cookie，然后拦截到Cookie中的用户名和密码实现自动登录 5、通过实现PasswordEncoder类在encode方法上直接返回原来的字符串，不需要编码。在matches方法中直接通过明文的方式匹配。 6、定制认证规则（这里使用内存的方式），比如使用用户名zhangsan，密码12345登录就有VIP1、VIP2的权限，其他同理，有了响应的权限之后就能访问对应的路径了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //定制请求的授权规则 http.authorizeRequests() .antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); http.formLogin(); http.logout().logoutSuccessUrl(\"/\"); http.rememberMe(); &#125; /** * 定制认证规则 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //可以设置内存指定的登录的账号密码,指定角色 auth.inMemoryAuthentication() //这样，页面提交时候，密码以明文的方式进行匹配。 .passwordEncoder(new MyPasswordEncoder()) .withUser(\"zhangsan\").password(\"12345\").roles(\"VIP1\", \"VIP2\" , \"VIP3\") .and() .withUser(\"lisi\").password(\"12345\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"12345\").roles(\"VIP1\", \"VIP3\"); &#125; public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125; &#125;&#125; 工程目录 所有的秘籍展示 在html页面中使用Thymeleaf整合Security的标签 welcome.html 1、引入thymeleaf命名空间和thymeleaf整合security的标签 ​ xmlns:th=&quot;http://www.thymeleaf.org&quot; ​ xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot; 2、通过sec:authorize=&quot;!isAuthenticated()&quot;标签判断是否授权来动态显示不同的内容 3、通过sec:authentication=&quot;name&quot;获取当前登录的用户名 4、通过sec:authentication=&quot;principal.authorities&quot;获取该用户所拥有的所有角色 5、通过sec:authorize=&quot;hasRole(&#39;VIP1&#39;)&quot;判断当前是否有VIP1角色的权限，其他同理，来达到每个用户拥有的不同的角色动态的显示自己能访问的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity4\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=\"center\"&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;&lt;!-- 如果没有授权通过就显示游客 --&gt;&lt;div sec:authorize=\"!isAuthenticated()\"&gt; &lt;h2 align=\"center\"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=\"@&#123;/login&#125;\"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;!-- 如果授权通过了显示注销、用户信息、用户的角色 --&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;h2 align=\"center\"&gt; &lt;span sec:authentication=\"name\"&gt;&lt;/span&gt; 您好，您的角色有 &lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"&gt; &lt;/form&gt;&lt;/div&gt;&lt;hr&gt;&lt;div sec:authorize=\"hasRole('VIP1')\"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/1&#125;\"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/2&#125;\"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/3&#125;\"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('VIP2')\"&gt; &lt;h3&gt;高级武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level2/1&#125;\"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level2/2&#125;\"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level2/3&#125;\"&gt;梯云纵&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('VIP3')\"&gt; &lt;h3&gt;绝世武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level3/1&#125;\"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level3/2&#125;\"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level3/3&#125;\"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试 1、使用zhangsan用户登录 2、登录成功进入主页 3、登录时勾选了记住我，所以Cookie中会带用户信息，退出浏览器之后再进入会自动登录 二、自定义登录页面1、前面说了默认请求登录页面和处理登录的方式，也可以通过下面这种方式来自定义登录页面http.formLogin().loginPage(&quot;/userlogin&quot;).usernameParameter(&quot;user&quot;).passwordParameter(&quot;pwd&quot;); 由默认就会变成Get请求/userlogin来到自己写好的登陆页面，或者请求没有权限的页面也会跳到/userlogin，Post请求/userlogin来处理登录（Spring会处理），参数名称默认为username，password，通过上面的方式可以自定义 2、登录页面的记住我可以通过http.rememberMe().rememberMeParameter(&quot;remeberme&quot;);自定义[记住我]功能的参数名（默认是remeber-me） 12345678910111213@Override protected void configure(HttpSecurity http) throws Exception &#123; //定制请求的授权规则 http.authorizeRequests() .antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); http.formLogin().loginPage(\"/userlogin\") .usernameParameter(\"user\").passwordParameter(\"pwd\"); http.logout().logoutSuccessUrl(\"/\"); http.rememberMe().rememberMeParameter(\"remeberme\"); &#125; 3、登录页面 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 align=\"center\"&gt;欢迎登陆武林秘籍管理系统&lt;/h1&gt; &lt;hr&gt; &lt;div align=\"center\"&gt; &lt;form th:action=\"@&#123;/userlogin&#125;\" method=\"post\"&gt; 用户名:&lt;input name=\"user\"/&gt;&lt;br&gt; 密码:&lt;input name=\"pwd\"&gt;&lt;br/&gt; &lt;input type=\"checkbox\" name=\"remeberme\"/&gt;记住我&lt;br/&gt; &lt;input type=\"submit\" value=\"登陆\"&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、测试，也是和使用Spring定义的登录页面一样的效果（注：记得welcome.html中的登录a标签要换成/userlogin）","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习11_任务&邮件","slug":"2019-04-12-SpringBoot学习11_任务与邮件","date":"2019-04-12T11:38:00.000Z","updated":"2019-04-12T12:41:26.679Z","comments":true,"path":"2019/04/12/2019-04-12-SpringBoot学习11_任务与邮件/","link":"","permalink":"http://yoursite.com/2019/04/12/2019-04-12-SpringBoot学习11_任务与邮件/","excerpt":"","text":"一、异步任务​ 在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。 主配置类（@EnableAsync开启异步注解功能） 12345678@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class Springboot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot12TaskApplication.class, args); &#125;&#125; Controller（调用异步方法） 调用异步方法时，因为开启了异步注解功能，异步方法会由另外一个线程去执行，下面代码会由当前线程执行 1234567891011121314@RestControllerpublic class AsyncController &#123; @Autowired private AsyncService asyncService; @GetMapping(\"/hello\") public String hello() &#123; //调用异步方法 asyncService.hello(); //因为是异步的，所以这里会直接返回，上面由另外一个线程去执行 return \"success\"; &#125;&#125; Service（使用@Async注解） 12345678910111213141516@Servicepublic class AsyncService &#123; /** * 告诉Spring这是一个异步方法 */ @Async public void hello() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"hello\"); &#125;&#125; 可以看到异步方法会sleep3秒，一般情况下浏览器会等待3秒才会响应，这里使用了异步功能，所以会异步执行 二、定时任务​ 项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供TaskExecutor 、TaskScheduler 接口。 1、两个注解：@EnableScheduling、@Scheduled 2、cron表达式： 字段 允许值 允许的特殊字符 秒 0-59 , - */ 分 0-59 , - */ 小时 0-23 , - */ 日期 1-31 , - *? / L W C 月份 1-12 , - */ 星期 0-7或SUN-SAT0,7是SUN , - *? / L C # 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 是代表每次，而这里又指定了周一到周六，如果用就会冲突，使用?来冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期四 几个例子 second(秒) minute(分), hour(时), day of month(日), month(月) , day of week(周几). 【0 0/5 14,18 ?】每天14点整和18点整，每隔5分钟执行一次 【0 15 10 ? * 1-6】每个月的周一至周六10:15分执行一次；?冲突匹配，是代表每次，而这里又指定了周一到 周六，如果用就会冲突，使用?来冲突匹配 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次 【0 1-7】 周一到周日每分钟的0秒执行一次 【0 43-44 * 1-7】周一到周日每小时的43-44分钟的0秒执行一次 3、Demo 在主配置类上标注@EnableScheduling 开启定时调度注解功能 Service使用@Scheduled(cron = “0-4 1-7”)周一到周日每小时的每分钟0-4秒内执行该方法 1234567@Servicepublic class SchduledService &#123; @Scheduled(cron = \"0-4 * * * * 1-7\") public void hello() &#123; System.out.println(\"hello\"); &#125;&#125; 三、邮件任务 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; SpringBoot自动配置类MailSenderAutoConfiguration，定义MailProperties内容，配置在application.yml中，会自动装配JavaMailSender application.yml 1234567#qq邮箱的是smtp.qq.comspring.mail.host=邮箱服务器spring.mail.username=邮箱地址#登录qq邮箱-&gt;设置-&gt;账户-&gt;生成授权码spring.mail.password=授权码#qq邮箱一定要开启ssl安全协议不然会报错spring.mail.properties.mail.smtp.ssl.enable=true 测试发送普通邮件 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot12TaskApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; @Test public void contextLoads() &#123; //创建一个简单邮件对象 SimpleMailMessage mailMessage = new SimpleMailMessage(); //邮件标题 mailMessage.setSubject(\"开会\"); //邮件内容 mailMessage.setText(\"今晚7:30软件分院304开会！\"); //设置谁发送的 mailMessage.setFrom(\"xxx\"); //设置发送给哪个邮箱 mailMessage.setTo(\"xxx@gmail.com\"); javaMailSender.send(mailMessage); &#125;&#125; 测试发送带附件的邮件 12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot12TaskApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; @Test public void testSendMultipart() throws Exception&#123; //创建一个复杂的消息邮件对象 MimeMessage mimeMessage = javaMailSender.createMimeMessage(); //创建帮助类 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); //邮件标题 helper.setSubject(\"开会（附件）\"); //设置启用html标签格式的内容 helper.setText(\"&lt;b style='color:red'&gt;今晚7:30软件分院304开会！&lt;/b&gt;\", true); //设置谁发送的 helper.setFrom(\"xxx\"); //设置发送给哪个邮箱 helper.setTo(\"xxx@gmail.com\"); //上传文件 helper.addAttachment(\"1.jpg\", new File(\"C:\\\\Users\\\\Administrator\\\\Pictures\\\\Saved Pictures\\\\oynn.jpg\")); helper.addAttachment(\"2.jpg\", new File(\"C:\\\\Users\\\\Administrator\\\\Pictures\\\\Saved Pictures\\\\oynn02.jpg\")); javaMailSender.send(mimeMessage); &#125;&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Linux用户管理","slug":"2019-04-09-Linux用户管理","date":"2019-04-09T14:22:00.000Z","updated":"2019-04-12T11:35:06.290Z","comments":true,"path":"2019/04/09/2019-04-09-Linux用户管理/","link":"","permalink":"http://yoursite.com/2019/04/09/2019-04-09-Linux用户管理/","excerpt":"","text":"一、Linux用户配置文件Linux配置文件是非常多的，这里只说四个重要的 /etc/passwd用户信息文件 /etc/shadow 影子文件 /etc/group组信息文件 /etc/gshadow组密码文件 1、用户信息文件​ /etc/passwd 用户管理简介: 越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范，在linux中主要是通过用户配置文件来查看和修改用户信息。 初始组和附加组说明： 初始组：用户已登录就拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用 户名相同的组名作为这个用户的初始组 附加组：之后用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。 /etc/passwd设置 以第一行的root用户来举例说明 root:x:0:0:root:/root:/bin/bash 第一字段：用户名称 第二字段：密码标志（centos6和centos7无意义了） 第三字段：UID（用户ID） ​ 0：超级用户 ​ 1-499： 系统用户(伪用户;Linux系统自带的很多软件都需要系统用户来支持启动，但是这些系统 ​ 户是不能用来登陆的) ​ 500-65535：普通用户 第四字段：GID（用户初始组ID） 第五字段：用户说明（默认就是用户名，也可以自己修改） 第六字段：家目录 ​ 普通用户：/home/用户名/ ​ 超级用户：/root/ 第七字段：登录之后的shell 123456789101112131415161718192021222324252627 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 4 adm:x:3:4:adm:/var/adm:/sbin/nologin 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin10 operator:x:11:0:operator:/root:/sbin/nologin11 games:x:12:100:games:/usr/games:/sbin/nologin12 ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin13 nobody:x:99:99:Nobody:/:/sbin/nologin14 avahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologin15 systemd-bus-proxy:x:999:997:systemd Bus Proxy:/:/sbin/nologin16 systemd-network:x:998:996:systemd Network Management:/:/sbin/nologin17 dbus:x:81:81:System message bus:/:/sbin/nologin18 polkitd:x:997:995:User for polkitd:/:/sbin/nologin19 tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin20 postfix:x:89:89::/var/spool/postfix:/sbin/nologin21 sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin22 dockerroot:x:996:993:Docker User:/var/lib/docker:/sbin/nologin #下面是自己添加的用户23 zhangsan:x:1000:1000::/home/zhangsan:/bin/bash24 lisi:x:1001:1001::/home/lisi:/bin/bash25 testuser:x:1002:1002:test user:/home/testuser:/bin/bash 2、影子文件​ /etc/shadow ​ 第一字段：用户名 ​ 第二字段：加密密码 ​ 加密算法为SHA512散列加密算法 ​ 如果密码位是”!!”（代表锁定了）或者”*”（代表没有密码），不能登录 ​ 第三字段：密码最后一次修改日期 ​ 使用1970年1月1日作为标准时间，每过一天时间戳+1 ​ 第四字段：两次密码的修改最小间隔时间（和第三个字段相比） ​ 第五字段：密码有效期限（和第三个字段相比） ​ 第六字段：密码修改到期前的警告天数（和第五个字段相比） ​ 第七字段：密码过期后的宽限天数(和第五个字段相比) ​ 0：代表密码过期后立即失效 ​ -1：代表密码永远不失效 ​ 第八字段：账号失效时间 ​ 要用时间戳表示 ​ 第九字段：保留 1234567891011121314151617181920212223242526272829 1 root:$6$VsE.SDFhC2LG1zie$H60peSW6Oz1gwsw3pXpGnRvKjrmEvEHKhdQky8tkBNGcY6AKY6A2H2Sffj RItQKSL/8f1gNwATEC/HIDxX9H01::0:99999:7::: 2 bin:*:16659:0:99999:7::: 3 daemon:*:16659:0:99999:7::: 4 adm:*:16659:0:99999:7::: 5 lp:*:16659:0:99999:7::: 6 sync:*:16659:0:99999:7::: 7 shutdown:*:16659:0:99999:7::: 8 halt:*:16659:0:99999:7::: 9 mail:*:16659:0:99999:7:::10 operator:*:16659:0:99999:7:::11 games:*:16659:0:99999:7:::12 ftp:*:16659:0:99999:7:::13 nobody:*:16659:0:99999:7:::14 avahi-autoipd:!!:17941::::::15 systemd-bus-proxy:!!:17941::::::16 systemd-network:!!:17941::::::17 dbus:!!:17941::::::18 polkitd:!!:17941::::::19 tss:!!:17941::::::20 postfix:!!:17941::::::21 sshd:!!:17941::::::22 dockerroot:!!:17941::::::23 zhangsan:$6$pijbttcg$pQY0lCT61hJh9FrwlBdZIhP1KxJk21keQ/ER0DsIlsg8oF015pvlddzMNHAnJB.C KiziCIdmH3TqFRzaHWrd60:17995:0:99999:7:::24 lisi:$6$LgAqOmYD$38l9NI1L6BWYjETiu0Z9Sia8fh5qDwJ0M8sG39gNXlvSVq3wQkjWkpeLZBsU.QHbkOV7 1FiqDQPzZxhDxsPlB/:17995:0:99999:7:::25 testuser:$6$wkev.JGc$12ipqH//xtXVZWEezuuPH8wPYisoaRLHSDxrSiyzP.2VUQ9I5DzR0DGy9Zr0yfjC FCOw9T.eoKHlc.DhL1LEw.:17995:0:99999:7::: ​ 时间戳换算方式 ​ 把时间戳换算成日期[17991] 1date -d \"1970-01-01 [时间戳] days\" ​ 把日期换算成时间戳 1echo $(($(date --date=\"2016/01/06\" +%s)/86400+1)) 3、组信息文件​ /etc/group ​ 第一字段：组名 ​ 第二字段：组密码标志(拥有组密码的用户，可以往组里添加或者删除用户) ​ 第三字段：GID（组id） ​ 第四字段：组中附加用户(例如 root组中的有testuser用户) 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 root:x:0:testuser 2 bin:x:1:testuser 3 daemon:x:2: 4 sys:x:3: 5 adm:x:4: 6 tty:x:5: 7 disk:x:6: 8 lp:x:7: 9 mem:x:8:10 kmem:x:9:11 wheel:x:10:12 cdrom:x:11:13 mail:x:12:postfix14 man:x:15:15 dialout:x:18:16 floppy:x:19:17 games:x:20:18 tape:x:30:19 video:x:39:20 ftp:x:50:21 lock:x:54:22 audio:x:63:23 nobody:x:99:24 users:x:100:25 avahi-autoipd:x:170:26 utmp:x:22:27 utempter:x:35:28 ssh_keys:x:999:29 input:x:998:30 systemd-journal:x:190:31 systemd-bus-proxy:x:997:32 systemd-network:x:996:33 dbus:x:81:34 polkitd:x:995:35 dip:x:40:36 tss:x:59:37 postdrop:x:90:38 postfix:x:89:39 sshd:x:74:40 cgred:x:994:41 dockerroot:x:993:42 docker:x:992:43 zhangsan:x:1000:44 lisi:x:1001:45 testuser:x:1002: 4、组密码文件​ /etc/gshadow ​ 第一字段：组名 ​ 第二字段：组密码 ​ 第三字段：组管理员用户名 ​ 第四字段：组中附加用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 root:::testuser 2 bin:::testuser 3 daemon::: 4 sys::: 5 adm::: 6 tty::: 7 disk::: 8 lp::: 9 mem:::10 kmem:::11 wheel:::12 cdrom:::13 mail:::postfix14 man:::15 dialout:::16 floppy:::17 games:::18 tape:::19 video:::20 ftp:::21 lock:::22 audio:::23 nobody:::24 users:::25 avahi-autoipd:!::26 utmp:!::27 utempter:!::28 ssh_keys:!::29 input:!::30 systemd-journal:!::31 systemd-bus-proxy:!::32 systemd-network:!::33 dbus:!::34 polkitd:!::35 dip:!::36 tss:!::37 postdrop:!::38 postfix:!::39 sshd:!::40 cgred:!::41 dockerroot:!::42 docker:!::43 zhangsan:!::44 lisi:!::45 testuser:!:: 二、LINUX用户相关命令 查看当前登录用户 whoami 12[root@localhost network-scripts]# whoamiroot 查看用户ID，组ID，所在的组 id [用户名] 12[root@localhost network-scripts]# id rootuid=0(root) gid=0(root) groups=0(root) 用户添加命令 useradd [选项] 用户名 -u ：手工指定用户的UID号 -d ：手工指定用户的家目录 -c ：手工指定用户的说明 -g ：手工指定用户的初始组 -G ：手工指定用户的附加组 -s ：手工指定用户的登录shell。默认是/bin/bash eg：（一般不会使用这些选项，Linux中默认设置的就是最好的） 1useradd -G root,bin -d /home/testuser -c \"test user\" -s /bin/bash testuser 查看组信息 groups ：查看当前登录用户所在的组（很多博客都是说查看当前登录用户的组内成员，测试并不是，man查看了下才知道自己测试的是对的） groups test ：查看test用户所在的组以及还存在于哪些组中 用户添加命令默认设置 ​ /etc/default/useradd ​ GROUP=100 #用户默认组 ​ HOME=/home #用户家目录 ​ INACTIVE=-1 #密码过期宽限时间（shadow文件7字段） ​ EXPIRE= #密码失效时间(8) ​ SHELL=/bin/bash #默认shell ​ SKEL=/etc/skel #默认模板 ​ CREATE_MAIL_SPPPL=yes #是否建立邮箱 修改用户密码 ​ passwd [选项] 用户名 ​ -S 查询用户密码的状态（仅root用户可以） ​ -l 暂时锁定用户（仅root用户可以） ​ -u 解锁用户（仅root用户可以） ​ eg： 12[root@localhost ~]# passwd -S testusertestuser PS 2019-04-09 0 99999 7 -1 (Password set, SHA512 crypt.) ​ 密码修改间隔时间(0) ​ 密码有效期(99999) ​ 警告时间(7) ​ 密码不失效(-1) ​ eg：passwd -l 用户 ​ 锁定原理为在shadow文件中，用户第二个字段前加上”!!”号 删除用户 userdel [选项] [用户名] -r 删除用户的同时删除用户家目录 ​ 删除原理是：删除了以下文件中的用户信息 ​ /etc/passwd ​ /etc/shadow ​ /etc/group ​ /etc/gshadow ​ /home/sc ​ /var/spool/mail/sc 切换用户 su [用户名] eg: 123[root@localhost ~]# su testuser[testuser@localhost root]$ whoamitestuser 切换时连用户的环境变量一同切换 直接使用su 用户 切换模式只切换了用户，但是没有切换用户变量，所以要想把用户和环境变量一起改变的话，需要使用su - root 命令形式。可以使用echo $PATH查看两者的区别 添加组 groupadd [选项] [组名] -g GID：指定组ID（最好不要指定，这样可能导致Linux处理组的时候发生异常） 删除组 groupdel [组名] 删除组的时候需要注意，如果组中有初始用户则不能删除这个组，可以通过删除这个用户，再删除组。 把用户添加入组或从组中删除(操作对象是附加用户) gpasswd [选项] [用户] [组名] -a ：把用户加入组 -d ：把用户从组中删除 eg：把testuser用户添加进root组 12[root@localhost ~]# gpasswd -a testuser rootAdding user testuser to group root eg：把testuser用户从root组中删除 12[root@localhost ~]# gpasswd -d testuser rootRemoving user testuser from group root 可以进入/etc/group验证 或者通过grep testuser /etc/group命令查看变化 注：其实Linux中很多指令原理都是帮我们操作文件","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Spring Boot学习10_整合Elasticsearch","slug":"2019-04-08-SpringBoot学习10_整合Elasticsearch","date":"2019-04-08T13:21:00.000Z","updated":"2019-04-08T15:32:24.345Z","comments":true,"path":"2019/04/08/2019-04-08-SpringBoot学习10_整合Elasticsearch/","link":"","permalink":"http://yoursite.com/2019/04/08/2019-04-08-SpringBoot学习10_整合Elasticsearch/","excerpt":"","text":"一、Elasticsearch概念•以 员工文档 的形式存储为例：一个文档代表一个员工数据。存储数据到 ElasticSearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存储在哪里。 •一个 ElasticSearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。 •类似关系： ​ –索引-数据库 ​ –类型-表 ​ –文档-表中的记录 ​ –属性-列 更多详细内容见官方文档 二、Elasticsearch入门2.1、安装Elasticsearch1、在虚拟机中通过Docker拉取elasticsearch镜像 1docker pull elasticsearch 2、运行镜像并使其运行成容器（9200是暴露给web端的，9300是在分布式系统中各个节点交互暴露的接口） 1docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -p 9200:9200 -p 9300:9300 --name my_es 5acf0e8da90b 3、拷贝配置文件到宿主机（必须保证容器中的ES是启动状态） 从这步开始一定要跟着做，不然后面使用SpringData的接口操作时会报错。详细见[ARTS第三周](https://github.com/LonerYang/ARTS/blob/master/ARTS/2019-04-07-ARTS%E7%AC%AC%E4%B8%89%E5%91%A8.md) 1docker cp my_es:/usr/share/elasticsearch/config/elasticsearch.yml: /usr/share/elasticsearch.yml 4、停止 和 删除原来创建的容器 12docker stop elasticsearchdocker rm my_es 5、重新执行创建容器命令（重点：挂载文件） 1docker run -di --name=my_es -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch 6、 修改 /usr/share/elasticsearch.yml 将 transport.host: 0.0.0.0 前的 # 去掉后保存文件退出。 其作用是允许任何ip地址访问 elasticsearch 开发测试阶段可以这么做，生产环境下指定具体的IP 7、重启后发现重启启动失败了（纯宿主机问题），这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等 8、系统调优 （1）修改 /etc/security/limits.conf 追加内容 12* soft nofile 65536* hard nofile 65536 说明：nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制（2）修改 /etc/sysctl.conf 追加内容 1vm.max_map_count=655360 说明：限制一个进程可以拥有的VMA(虚拟内存区域)的数量 9、重启虚拟机 2.2、基本操作1、存储文档 对于雇员目录，我们将做如下操作： 每个雇员存储一个文档，包含该雇员的所有信息。 每个文档都将是 employee 类型 。 该类型位于 索引 megacorp 内。 该索引保存在我们的 Elasticsearch 集群中。 实践中这非常简单（尽管看起来有很多步骤），我们可以通过一条命令完成所有这些动作： 12345678PUT /megacorp/employee/1&#123; \"first_name\" : \"John\", \"last_name\" : \"Smith\", \"age\" : 25, \"about\" : \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ]&#125; 注意，路径 /megacorp/employee/1 包含了三部分的信息： megacorp 索引名称 employee 类型名称 1 特定雇员的ID 请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息，他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。 很简单！无需进行执行管理任务，如创建一个索引或指定每个属性的数据类型之类的，可以直接只索引一个文档。Elasticsearch 默认地完成其他一切，因此所有必需的管理任务都在后台使用默认设置完成。 进行下一步前，让我们增加更多的员工信息到目录中： 1234567891011121314151617PUT /megacorp/employee/2&#123; \"first_name\" : \"Jane\", \"last_name\" : \"Smith\", \"age\" : 32, \"about\" : \"I like to collect rock albums\", \"interests\": [ \"music\" ]&#125;PUT /megacorp/employee/3&#123; \"first_name\" : \"Douglas\", \"last_name\" : \"Fir\", \"age\" : 35, \"about\": \"I like to build cabinets\", \"interests\": [ \"forestry\" ]&#125; 可以使用Postman软件模拟PUT请求 比如存储员工id为1的文档，下面会响应成功后的信息（上面的其他操作同样） 2、检索文档 目前我们已经在 Elasticsearch 中存储了一些数据， 接下来就能专注于实现应用的业务需求了。第一个需求是可以检索到单个雇员的数据。 这在 Elasticsearch 中很简单。简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档： 1GET /megacorp/employee/1 返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档： 1234567891011121314&#123; \"_index\" : \"megacorp\", \"_type\" : \"employee\", \"_id\" : \"1\", \"_version\" : 1, \"found\" : true, \"_source\" : &#123; \"first_name\" : \"John\", \"last_name\" : \"Smith\", \"age\" : 25, \"about\" : \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] &#125;&#125; 将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT 。3、轻量搜索 一个 GET 是相当简单的，可以直接得到指定的文档。 现在尝试点儿稍微高级的功能，比如一个简单的搜索！ 第一个尝试的几乎是最简单的搜索了。我们使用下列请求来搜索所有雇员： 1GET /megacorp/employee/_search 可以看到，我们仍然使用索引库 megacorp 以及类型 employee，但与指定一个文档 ID 不同，这次使用 _search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"took\": 6, \"timed_out\": false, \"_shards\": &#123; ... &#125;, \"hits\": &#123; \"total\": 3, \"max_score\": 1, \"hits\": [ &#123; \"_index\": \"megacorp\", \"_type\": \"employee\", \"_id\": \"3\", \"_score\": 1, \"_source\": &#123; \"first_name\": \"Douglas\", \"last_name\": \"Fir\", \"age\": 35, \"about\": \"I like to build cabinets\", \"interests\": [ \"forestry\" ] &#125; &#125;, &#123; \"_index\": \"megacorp\", \"_type\": \"employee\", \"_id\": \"1\", \"_score\": 1, \"_source\": &#123; \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] &#125; &#125;, &#123; \"_index\": \"megacorp\", \"_type\": \"employee\", \"_id\": \"2\", \"_score\": 1, \"_source\": &#123; \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] &#125; &#125; ] &#125;&#125; 注意：返回结果不仅告知匹配了哪些文档，还包含了整个文档本身：显示搜索结果给最终用户所需的全部信息。 接下来，尝试下搜索姓氏为 Smith 的雇员。为此，我们将使用一个 高亮 搜索，很容易通过命令行完成。这个方法一般涉及到一个 查询字符串 （query-string） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口： 1GET /megacorp/employee/_search?q=last_name:Smith 我们仍然在请求路径中使用 _search 端点，并将查询本身赋值给参数 q= 。返回结果给出了所有的 Smith： 1234567891011121314151617181920212223242526272829&#123; ... \"hits\": &#123; \"total\": 2, \"max_score\": 0.30685282, \"hits\": [ &#123; ... \"_source\": &#123; \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] &#125; &#125;, &#123; ... \"_source\": &#123; \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] &#125; &#125; ] &#125;&#125; 4、 使用查询表达式搜索 Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性（参见 轻量 搜索）。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。 领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ： 12345678PUT /megacorp/employee/_search&#123; \"query\" : &#123; \"match\" : &#123; \"last_name\" : \"Smith\" &#125; &#125;&#125; 返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 query-string 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一，后续将会了解）。 5、更复杂的搜索 现在尝试下更复杂的搜索。 同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 30 的。查询需要稍作调整，使用过滤器 filter ，它支持高效地执行一个结构化查询。 1234567891011121314151617PUT /megacorp/employee/_search&#123; \"query\" : &#123; \"bool\": &#123; \"must\": &#123; \"match\" : &#123; \"last_name\" : \"smith\" &#125; &#125;, \"filter\": &#123; \"range\" : &#123; \"age\" : &#123; \"gt\" : 30 &#125; &#125; &#125; &#125; &#125;&#125; 这部分与我们之前使用的 match 查询 一样。 这部分是一个 range 过滤器 ， 它能找到年龄大于 30 的文档，其中 gt 表示_大于(_great than)。 目前无需太多担心语法问题，后续会更详细地介绍。只需明确我们添加了一个 过滤器 用于执行一个范围查询，并复用之前的 match 查询。现在结果只返回了一个雇员，叫 Jane Smith，32 岁。 12345678910111213141516171819&#123; ... \"hits\": &#123; \"total\": 1, \"max_score\": 0.30685282, \"hits\": [ &#123; ... \"_source\": &#123; \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] &#125; &#125; ] &#125;&#125; 更多详细内容见官方文档 三、SpringBoot整合Elasticsearch3.1、简介SpringBoot默认支持两种技术来和ES交互 1、Jest（默认不生效）需要导入Jest工具包（具体文档可去Github搜索） 2、SpringBoot提供的API：继承SpringData的接口和ElasticsearchTempldate组件 ​ 需要指定cluster-name和cluster-nodes，这种方法可能会报超时错误，就是ES版本不合适 ​ 如果版本不适配： ​ 1）、升级Springboot版本 ​ 2）、安装对应版本ElasticSearch spring data elasticsearch（spring-data-elasticsearch包版本） elasticsearch(ES版本) 3.2.x 6.5.0 3.1.x 6.2.2 3.0.x 5.5.0 2.1.x 2.4.0 2.0.x 2.2.0 1.3.x 1.5.2 3.2、JestClient操作ES maven依赖 123456&lt;!-- 引入操作ElasticSearch的API --&gt; &lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt; &lt;/dependency&gt; Article.java 12345678@Datapublic class Article &#123; @JestId private Integer id; private String author; private String title; private String content; &#125; application.properties 1spring.elasticsearch.jest.uris=http://192.168.25.157:9200 测试类 12345678910111213141516171819202122232425262728293031323334353637383940@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot11ElasticsearchApplicationTests &#123; @Autowired private JestClient jestClient; @Test public void testIndex () throws IOException &#123; Article article = new Article(); article.setId(1); article.setAuthor(\"Yang\"); article.setTitle(\"好消息\"); article.setContent(\"Hello World\"); Index index = new Index.Builder(article).index(\"ahead\").type(\"article\").build(); jestClient.execute(index); &#125; @Test public void testSearch() throws IOException &#123; String json = \"&#123;\\n\" + \" \\\"query\\\" : &#123;\\n\" + \" \\\"match\\\" : &#123;\\n\" + \" \\\"content\\\" : \\\"hello\\\"\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \"&#125;\"; Search search = new Search.Builder(json).addIndex(\"ahead\").addType(\"article\").build(); SearchResult result = jestClient.execute(search); //转换为对象 Article article = result.getSourceAsObject(Article.class, true); //获取响应的所有信息 JsonObject jsonObject = result.getJsonObject(); System.out.println(article); System.out.println(jsonObject); &#125;&#125; 先执行存储文档方法没问题，然后再执行检索方法，结果正确 更多详细信息参考官方文档 3.3、SpringData的接口操作ES maven依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; Book.java 1234567@Document(indexName = \"ahead\", type = \"book\")@Datapublic class Book &#123; private Integer id; private String name; private String author;&#125; BookRepository.java 12345678910public interface BookRepository extends ElasticsearchRepository&lt;Book, Integer&gt; &#123; /** * 按照SpringData所定义的规范来创建方法底层就会帮我们实现 * 某个方法对应什么操作具体可参考官方文档 * 通过书名模糊查询 * @param name * @return */ List&lt;Book&gt; findByNameLike(String name);&#125; application.properties 12spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=192.168.25.157:9300 cluster-name可通过访问ip:9200获取 测试类 1234567891011121314151617181920212223@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot11ElasticsearchApplicationTests &#123; @Autowired private BookRepository bookRepository; @Test public void testRepositoryIndex() &#123; Book book = new Book(); book.setId(1); book.setName(\"西游记\"); book.setAuthor(\"吴承恩\"); bookRepository.index(book); &#125; @Test public void testRepositorySearch() &#123; List&lt;Book&gt; book = bookRepository.findByNameLike(\"游\"); System.out.println(book); &#125;&#125; 先执行存储方法没问题，然后执行检索方法，结果正确。 3.4、ElasticsearchTemplate操作ES用的还是上面的环境 测试类 123456789101112131415161718192021222324252627@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot11ElasticsearchApplicationTests &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testElasticsearchTemplateIndex() &#123; Book book = new Book(); book.setId(2); book.setName(\"三国演义\"); book.setAuthor(\"罗贯中\"); IndexQuery indexQuery = new IndexQueryBuilder().withObject(book).build(); elasticsearchTemplate.index(indexQuery); &#125; @Test public void testElasticsearchTemplateSearch() &#123; SearchQuery searchQuery = new NativeSearchQueryBuilder() .withQuery(new MatchQueryBuilder(\"name\", \"国\")) .build(); List&lt;Book&gt; books = elasticsearchTemplate.queryForList(searchQuery, Book.class); System.out.println(books); &#125;&#125; 先执行存储文档方法成功后，再执行检索方法结果正确。 更多详细信息参考官方文档","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习09_整合RabbitMQ","slug":"2019-04-05-SpringBoot学习09_整合RabbitMQ","date":"2019-04-05T12:32:00.000Z","updated":"2019-04-06T01:32:14.239Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习09_整合RabbitMQ/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习09_整合RabbitMQ/","excerpt":"","text":"一、RabbitMQ基本概念简介1、RabbitMQ简介：RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。 2、核心概念： Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 路由键作用：发送到Exchange（交换器）中，交换器通过消息的路由键来决定把消息存放在哪一个队列中（交换器与队列绑定会指定一个绑定键也可以说路由键，交换器就是通过消息的路由键与自己绑定的队列的绑定键来匹配对应的队列） Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange 和Queue的绑定可以是多对多的关系。 Connection 网络连接，比如一个TCP连接。 Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 Broker 表示消息队列服务器实体（安装RabbitMQ软件的服务器） 3、下图表示了消息运行的原理 ​ 程序发送消息到指定的Exchange，Exchange根据消息的路由键把消息存放在匹配的队列中，消费者程序 通过信道去队列中获取消息 二、RabbitMQ运行机制Exchange类型： Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topi、headers。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型： 1、Direct Exchange（点对点式） 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。 2、Fanout Exchange（订阅式） 每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的。 3、Topic Exchange（匹配订阅式） topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号”*”。 ​ #匹配0个或多个单词，*匹配一个单词。 三、安装RabbitMQ测试1、通过Docker安装RabbitMQ（management是带WEB后台管理系统的） 1docker pull rabbitmq:3-management 2、运行RabbitMQ ​ 5672端口暴露给程序使用的，15672是WEB管理系统使用的 1docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 1f53405491bc 3、通过浏览器访问，然后通过用户名guest，密码guest登录进去 4、通过WEB后台管理系统创建三种不同类型的Exchange测试RabbitMQ， ​ 分别为exchange.direct、 exchange.fanout、exchange.topic ​ 创建四个队列：ahead、ahead.emps、ahead.news、softxueyuan.news 5、 为三种不同的类型的Exchange以不同的绑定键/路由键来绑定这四个队列 ![AWA32F.png](https://s2.ax1x.com/2019/04/05/AWA32F.png) 6、测试 测试exchange.direct发送消息（消息的路由键为ahead），点击Pulish message。查看Queue，只有ahead队列接收到信息（exchange.direct与ahead之间的绑定键为ahead）。 测试exchange.fanout，随便指定一个路由键，点击Pulish message，与其绑定的所有Queue都增加了一条消息 测试exchange.top，指定路由键为ahead.hello，点击Pulish message，查看Queue，绑定键为ahead.#的队列接收到了消息 结论： 类型为direct的Exchange，消息只会发送给消息的路由键与绑定时的路由键完全匹配的队列 类型为fanout的Exchange，无论消息的路由键是什么，消息会发送给与其绑定的所有队列 类型为topic的Exchange，topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号”*”。 #匹配0个或多个单词，*匹配一个单词。消息会发送给匹配的队列 四、Spring Boot整合Redis1.RabbitTemplate创建SpringBoot项目，向导选择RabbitMQ模块。 在RabbitAutoConfiguration自动配置类中向Spring容器中注册了RabbitTemplate组件（通过他可以操作RabbitMQ） 在RabbitProperties中有很多属性，可以通过全局配置文件application.properties配置，默认用户名、密码、 端口、ip地址、虚拟主机（默认为/），需要改的自己来指定，不需要改的使用默认的就行 1）、配置ip地址注意不要使用http前缀 application.properties 1spring.rabbitmq.host=192.168.25.157 2）、在测试类中测试，发送一个Map类型的信息到exchange.direct的交换器，指定路由键ahead.news 123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot10AmqpApplicationTests &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 给direct类型的交换器发送消息（点对点） * */ @Test public void contextLoads() &#123; //可以通过配置文件自定义消息头和消息体// rabbitTemplate.send(exchange, routingKey, message); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"msg\", \"使用RabbitMQ发送的第一个消息\"); map.put(\"data\", Arrays.asList(\"helloworld\", true, 123)); //常用的是下面这种方式，会自动转换消息头和消息体，只要传一个对象过去就行 rabbitTemplate.convertAndSend(\"exchange.direct\", \"ahead.news\", map); &#125; 3）、查看队列ahead.news（与exchange.direct的交换器的绑定键为ahead.news）， 查看信息都是序列化的二级制 4）、在测试类中也可以接收到该消息，使用自动转换方法就可以自动把序列化反序列化成原来的数据（接收到消息后，队列中的消息会被删除掉） 查看RabbitTemplate类中默认使用SimpleMessageConverter转换器，该转换器是使用字节数组输出流通过UTF-8编码发送消息 2.自定义序列化机制1）、SimpleMessageConverter实现了接口MessageConverter，查看MessageConverter实现类有Jackson2JsonMessageConverter类 2）、可以自定义个配置类往Spring容器中注册Jackson2JsonMessageConverter组件，就可以达到自定义RabbitMQ的序列化机制了 12345678@Configurationpublic class MyAMQPConfig &#123; @Bean public MessageConverter messageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 3）、再次启动上面的测试方法，查看消息显示的Json格式的字符串消息 3.AmqpAdmin​ 1）、在RabbitAutoConfiguration自动配置类中还注册了AmqpAdmin组件，使用代码来创建Exchange和 Queue还有Bingding（Exchange绑定Queue的规则） ​ 2）、代码实现 12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot10AmqpApplicationTests &#123; @Autowired private AmqpAdmin amqpAdmin; @Test public void testAmqpAdmin1() &#123; amqpAdmin.declareExchange(new DirectExchange(\"amqp.admin.exchange\")); &#125; @Test public void testAmqpAdmin2() &#123; amqpAdmin.declareQueue(new Queue(\"amqp.admin.queue\")); &#125; @Test public void testAmqpAdmin3() &#123; /** * param1：绑定目标的名称 * param2：绑定目标的类型 * param3：交换器名称 * param4：绑定的路由键 * param5：需要传的参数没有就传null */ amqpAdmin.declareBinding(new Binding(\"amqp.admin.queue\", Binding.DestinationType.QUEUE, \"amqp.admin.exchange\", \"amqp.admin.key\", null)); &#125; ​ 3）、按顺序执行代码，通过后台管理系统查看已经创建了名称为amqp.admin.exchange的Exchange， ​ 名称为amqp.admin.queue的Queue，且按照amqp.admin.key绑定键被绑定 4.@RabbitListener&amp;@EnableRabbit工程中都是在Service方法中监听某一个队列的消息，只要队列一有消息就会监听到，从而获取到消息并进行相关业务的处理 在主程序配置类上标注@EnableRabbit 123456789@EnableRabbit@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot10AmqpApplication.class, args); &#125;&#125; Book.java 12345@Datapublic class Book &#123; private String name; private String author;&#125; BookService 1234567891011121314151617181920@Servicepublic class BookService &#123; /** * 被@RabbitListener标注的方法用来监听指定的队列，只要队列中有消息进入就会以参数的形式接收到该 * 消息 * @param book */ @RabbitListener(queues = \"ahead.news\") public void receive(Book book) &#123; System.out.println(book); &#125; /** * 参数使用Message对象以获取更多的消息属性（比如消息头，消息体） */ @RabbitListener(queues = \"ahead\") public void receiveMessage(Message message) &#123; System.out.println(message.getMessageProperties()); System.out.println(message.getBody()); &#125;&#125; 测试类 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot10AmqpApplicationTests &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSendMsg() &#123; rabbitTemplate.convertAndSend(\"exchange.direct\", \"ahead.news\", new Book(\"三国演义\", \"罗贯中\")); rabbitTemplate.convertAndSend(\"exchange.direct\", \"ahead\", new Book(\"红楼梦\", \"曹雪芹\")); &#125; 1）、先启动应用，这时候BookService方法会进行监听 2）、启动测试方法 3）、查看控制台已经接收到被监听的队列中的消息","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习08_整合Redis","slug":"2019-04-05-SpringBoot学习08_整合Redis","date":"2019-04-05T03:02:00.000Z","updated":"2019-04-05T03:00:46.432Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习08_整合Redis/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习08_整合Redis/","excerpt":"","text":"一、环境搭建1、在前面的Demo的基础上在pom文件上添加上redis的starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、在全局配置文件中指定配置 123456789101112131415spring.redis.host=ipspring.redis.port=6379#如果有密码spring.redis.password=#连接超时时间（毫秒）spring.redis.timeout=10000#连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=8#连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1#连接池中最大空闲数spring.redis.jedis.pool.max-idle=8#连接池中最小空闲连接spring.redis.jedis.pool.min-idle=3 3、启动项目RedisCacheConfiguration也是匹配的，说明这次使用的缓存配置会使用Redis缓存的配置 二、RedisTemplate&amp;序列化机制1、在RedisAutoConfiguraion自动配置类中会自动注册RedisTemplate组件和StringRedisTemplate组件 二者区别： ​ RedisTemplate：k-v都是Object类型 ​ StringRedisTemplate：k-v都是String类型 Spring给用户提供了两个可用的模板，就像使用Hibernate会有HibernateTemplate，使用jdbc会有JdbcTemplate 2、所以我们使用的话就直接注入两个模板（注：使用RedisTemplate存储对象到缓存中，该对象所属的类一定要实现Serializable接口） Redis五大数据类型：String(字符串)、Hash(哈希表)、Set(集合)、List(链表)、Zset(有序集合)对应操作的方法如下 opsForValue[String] opsForHash[Hash] opsForSet[Set] opsForList[List] opsForZset[Zset] 12345678910111213141516171819202122232425@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot09CacheApplicationTests &#123; @Autowired private EmployeeMapper employeeMapper; @Autowired private RedisTemplate&lt;Object, Object&gt; redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void test01() &#123; ValueOperations&lt;String, String&gt; string = stringRedisTemplate.opsForValue(); string.set(\"k1\", \"Hello\"); &#125; @Test public void test02() &#123; //源码可以找到默认使用JdkSerializationRedisSerializer ValueOperations&lt;Object, Object&gt; string = redisTemplate.opsForValue(); Employee employee = employeeMapper.selectEmployeeById(1); string.set(\"emp01\", employee); &#125; 3、执行上述方法测试，查看redis缓存中的数据对象是被序列化成了二进制 ​ 3.1、进入到RedisTemplate类查看afterPropertiesSet方法，只要defaultSerializer为null（默认成员变量就 ​ 是为null），就初始化一个JdkSerializationRedisSerializer序列化器。 三、自定义RedisTemplate1、一般都是使用json格式的字符串存储在缓存中，通过前面的RedisAutoConfiguration类可以知道如果容器中有RedisTemplate组件就不会注册，所以我可以自定义RedisTemplate使用Json的序列化器 2、自定义RedisTemplate 123456789101112@Configurationpublic class MyRedisConfig &#123; @Bean public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Employee.class); template.setDefaultSerializer(jackson2JsonRedisSerializer); return template; &#125; 3、删除掉刚刚在Redis中缓存的数据，重新测试RedisTemplate 12345678@Test public void test02() &#123; //源码可以找到默认使用JdkSerializationRedisSerializer， //可以自定义Serializer；eg：这里自定义一个Json序列化器 ValueOperations&lt;Object, Object&gt; string = redisTemplate.opsForValue(); Employee employee = employeeMapper.selectEmployeeById(1); string.set(\"emp01\", employee); &#125; 测试成功 四、自定义CacheManager前面是Unit Test，真正用到工程上使用缓存注解还是默认会使用JdkSerializationRedisSerializer序列化器 1、Redis默认的CacheManager1）、启动项目RedisCacheConfiguration也是匹配的，只要导入Redis的starter就会使用RedisCacheConfiguration的配置，进入该类，会向容器中注册RedisCacheManager缓存管理器并且使用JdkSerializationRedisSerializer序列化器 2）、搭建缓存测试（用了前面的常用缓存注解的Demo环境） EmployeeService.java 123456@Cacheable(cacheNames = &#123;\"emp\"&#125;) public Employee getEmployeeById(Integer id) &#123; System.out.println(id + \"号员工被查询\"); Employee employee = employeeMapper.selectEmployeeById(id); return employee; &#125; EmployeeController.java 12345678@Autowired private EmployeeService employeeService; @GetMapping(\"/emp/&#123;id&#125;\") public Employee getEmployeeById(@PathVariable Integer id) &#123; Employee employee = employeeService.getEmployeeById(id); return employee; &#125; 3）、启动项目访问localhost:8080/emp/1测试 key：emp::1 value：序列化对象二进制码 key的生成规则：指定的cacheNames+”::”+指定的key 2、自定义CacheManager这里增加一个DepartmentService&amp;一个DepartmentController，这样的话就要自定义两个CacheManager。且在缓存注解中的cacheManager属性指定用哪个CacheManager。 MyRedisConfig.java ​ 注：这里自定义了三个CacheManager，因为自定义了多个CacheManager的话，必须要通过 **@Primary注解指定一个默认CacheManager，用作缓存注解没有指定cacheManager属性，默认使用的** ​ CacheManager 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Configurationpublic class MyRedisConfig &#123; @Primary @Bean public RedisCacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); JdkSerializationRedisSerializer jdkSerializationRedisSerializer = new JdkSerializationRedisSerializer(); // 配置序列化（解决乱码的问题） 不写默认不过期 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(jdkSerializationRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125; @Bean public RedisCacheManager empCacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer&lt;Employee&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Employee.class); // 配置序列化（解决乱码的问题） 不写默认不过期 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(jdkSerializationRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125; @Bean public RedisCacheManager empCacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer&lt;Department&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Department.class); // 配置序列化（解决乱码的问题） 不写默认不过期 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(jdkSerializationRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125; EmployeeService.java 123456789@Autowired private EmployeeMapper employeeMapper @Cacheable(cacheNames = &#123;\"emp\"&#125;, cacheManager = \"empCacheManager\") public Employee getEmployeeById(Integer id) &#123; System.out.println(id + \"号员工被查询\"); Employee employee = employeeMapper.selectEmployeeById(id); return employee; &#125; DepartmentService.java 123456789@Autowired private DepartmentMapper departmentMapper; @Cacheable(cacheNames = &#123;\"dept\"&#125;, cacheManager = \"deptCacheManager\") public Department getDepartmentById(Integer id) &#123; System.out.println(id + \"号部门被查询\"); Department department = departmentMapper.selectDepartmentById(id); return department; &#125; EmployeeController.java 12345678@Autowired private EmployeeService employeeService; @GetMapping(\"/emp/&#123;id&#125;\") public Employee getEmployeeById(@PathVariable Integer id) &#123; Employee employee = employeeService.getEmployeeById(id); return employee; &#125; DepartmentController.java 123456789@Autowiredprivate DepartmentService departmentService; @GetMapping(\"/dept/&#123;id&#125;\")public Department getDepartmentById(@PathVariable Integer id) &#123; Department department = departmentService.getDepartmentById(id); return department;&#125; 结果：访问测试 ​ 访问EmployeeController：localhost:8080/emp/1成功显示结果 ​ 访问DepartmentController：localhost:8080/dept/1成功显示结果 查看Redis：以json格式正确存储到Redis缓存中 ​ 1）、在开发中如果每个需要缓存的对象都要自定义一个对应的CacheManager那太麻烦了，之前的做法 都是在初始化Jackson2JsonRedisSerializer时通过构造方法指定类型，这时候我们可以将其的类型 指定 为Object，只不过要加几行代码 ​ MyRedisConfig.java 123456789101112131415161718192021222324@Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题） RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125; ​ 2）、使用缓存注解只有返回值会被存储缓存中，这时候可以通过自动注入缓存管理器来灵活的使用缓存 ​ 以DepartmentService为例（不需要使用缓存注解） 12345678910111213141516171819202122232425@Servicepublic class DepartmentService &#123; @Autowired private CacheManager cacheManager; @Autowired private DepartmentMapper departmentMapper; public Department getDepartmentById(Integer id) &#123; //业务中灵活的使用缓存；自动注入自定义好的deptCacheManager //获取名称为dept的缓存组件，没有默认会创建一个名称为dept的缓存组件 Cache cache = cacheManager.getCache(\"dept\"); //先在缓存中查，没有查到再去数据库中查询然后再添加到缓存中去 //在Redis中使用的key：cacheName::这里指定的key SimpleValueWrapper valueWrapper = (SimpleValueWrapper) cache.get(id); Department department = null; if (valueWrapper == null) &#123; department = departmentMapper.selectDepartmentById(id); cache.put(id,department); &#125; else &#123; department = (Department)valueWrapper.get(); &#125; return department; &#125;&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习08_缓存工作原理","slug":"2019-04-05-SpringBoot学习08_缓存运行流程","date":"2019-04-05T03:00:00.000Z","updated":"2019-04-05T02:59:57.586Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习08_缓存运行流程/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习08_缓存运行流程/","excerpt":"","text":"一、原理分析原理性的东西每次都是XXXAutoConfiguration配置类，缓存应该就是CacheAutoConfiguration类 1、进入CacheAutoConfiguration类上面有个@Import({CacheAutoConfiguration.CacheConfigurationImportSelector.class}) 会导入一个CacheConfigurationImportSelector类，进入这个类 2、CacheConfigurationImportSelector类中有个selectImports方法，这个方法会返回一个数组，debug启动看看返回了些什么 3、会返回很多缓存配置类 4、在全部配置文件application.properties中指定debug=true，查看只有SimpleCacheConfiguration匹配，其他的配置类都没有被匹配 12345678910111213141516171819SimpleCacheConfiguration matched:CaffeineCacheConfiguration: Did not match:CouchbaseCacheConfiguration: Did not match:EhCacheCacheConfiguration: Did not match:GenericCacheConfiguration: Did not match:HazelcastCacheConfiguration: Did not match:InfinispanCacheConfiguration: Did not match:JCacheCacheConfiguration: Did not match:NoOpCacheConfiguration: Did not match:RedisCacheConfiguration: Did not match: 5、进入SimpleCacheConfiguration类，该类会向容器中注册一个ConcurrentMapCacheManager组件，也就是前面提到的CacheManager。进入ConcurrentMapCacheManager类 6、里面有个ConcurrentMap用来管理缓存组件 还有getCache方法，给其打上断点，后面调试用 7、getCache方法根据key会获得Cache缓存组件，进入Cache，这是个接口，因为这是ConcurrentMapCacheManager缓存管理器，所以进入ConcurrentMapCache缓存组件 8、ConcurrentMapCache类中有个ConcurrentMap用来存储缓存数据的，lookup方法用来从缓存中获取值，put方法把数据存到缓存中，并给两个方法打上断点方便后面测试。 二、调试第一次请求 1、以@Cacheable注解测试 2、Debug启动，并访问EmployeeController（localhost:8080/emp/1） ​ 首先会进入到ConcurrentMapCacheManager类的getCache方法，根据cacheNames去缓存管理器中获取对 应的缓存，如果没有就会创建一个ConcurrentMapCache组件并设置到缓存管理器的map中去。 3、上一篇文章中讲过@Cacheable注解不设置key的值默认就会是参数。这里的参数为1，也就是对应的参数值。 ​ 3.1、看debug执行的代码顺序，后退几步可以看到有个generateKey方法 ​ 3.2、进入generateKey方法==》context.generateKey(result) ​ ==》protected Object generateKey(@Nullable Object result) ​ 只要注解上指定了key就会走if判断里面的代码，否则走下面这句 ​ ==》return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args); ​ 3.3、keyGenerator是个接口类型的键生成策略，该接口下面有个实现类为SimpleKeyGenerator类 ​ ​ 3.4、进入SimpleKeyGenerator类，上面有行代码就是调用了generate方法 ​ return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);$ ​ 查看SimpleKeyGenerator类的generator方法 ​ SimpleKeyGenerator生成key的默认策略： ​ 如果没有参数：key = new SimpleKey(new Object[0])); ​ 如果有一个参数： key = 参数的值 ​ 如果有多个参数：key = new SimpleKey(params) 4、回到lookup方法，点击下一步，从缓存组件中获取的值就是空的。 5、放行，会执行目标方法从数据库中查询到数据 6、放行，会执行ConcurrentMapCache的put的方法把数据存到缓存组件中 7、最后放行，浏览器就显示了查到的数据 测试第二次请求 1、访问EmployeeController（localhost:8080/emp/1）仍然会进入到ConcurrentMapCacheManager的getCache方法，只不过这次缓存管理器中已经有了key为emp的缓存组件直接将其返回。 2、放行进入ConcurrentMapCache的lookup方法。 3、点击下一步，这次就能从缓存组件中获取到数据。 4、放行，这次没有进入到目标方法，浏览器直接显示了数据 结论： 运行流程：以@Cacheable为例 1、方法运行之前先去查询Cache，以cacheNames指定的名字获取 （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数 ​ key是按照某种策略生成的，默认使用SimpleKeyGenerator生成key SimpleKeyGenerator生成key的默认策略： ​ 如果没有参数：key = new SimpleKey(new Object[0])); ​ 如果有一个参数： key = 参数的值 ​ 如果有多个参数：key = new SimpleKey(params) 3、在缓存中没有查到数据就调用目标方法 4、将目标方法返回的结果，放进缓存中 @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据 三、自定义KeyGenerator创建配置类MyKeyGenerator并给容器中注册一个自定义的KeyGenerator，打上断点方便后面测试 给EmployeeService的查询方法指定自定义的键生成策略 12345678910111213@Configurationpublic class MyKeyGenerator &#123; @Bean public KeyGenerator myGenerator() &#123; return new KeyGenerator()&#123; @Override public Object generate(Object target, Method method, Object... params) &#123; return method.getName() + Arrays.asList(params).toString() + \"yang\"; &#125; &#125;; &#125;&#125; 123456@Cacheable(cacheNames = &#123;\"emp\"&#125;, keyGenerator = \"myGenerator\")public Employee getEmployeeById(Integer id) &#123; System.out.println(id + \"号员工被查询\"); Employee employee = employeeMapper.selectEmployeeById(id); return employee;&#125; 1、debug运行，访问EmployeeController（localhost:8080/emp/1），第一步还是到ConcurrentMapCacheManager的getCache方法 2、放行，进入到了自定义的KeyGenerator的generator方法 3、放行，到ConcurrentMapCache组件的lookup方法，发现这个key已经是按照我们自定义的生成了。 结论：可以自定义一个KeyGenerator键生成策略，然后注册到容器中，并在缓存注解上指定就会按照自定义生成 的生成策略来生成key","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习08_常用缓存注解使用","slug":"2019-04-05-SpringBoot学习08_常用缓存注解使用","date":"2019-04-04T16:32:00.000Z","updated":"2019-04-04T16:32:12.252Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习08_常用缓存注解使用/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习08_常用缓存注解使用/","excerpt":"","text":"一、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。 •CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 •CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 •Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 •Entry是一个存储在Cache中的key-value对。 •Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 二、Spring缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache 和org.springframework.cache.CacheManager接口来统一不同的缓存技术； 并支持使用JCache（JSR-107）注解简化我们开发； •Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； •Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； • 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直 接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取 • 使用Spring缓存抽象时我们需要关注以下两点； 1、确定方法需要被缓存以及他们的缓存策略 2、从缓存中读取之前缓存存储的数据 r.com/i/AgMRne) 三、几个重要概念&amp;缓存注解 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 四、Demo使用Springboot+Mybatis搭建环境 全局配置文件application.properties 12345spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?serverTimezone=UTCspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=passwordmybatis.configuration.map-underscore-to-camel-case=true 创建spring_cache数据库，并创建employee表和department表 创建对应的Bean、Mapper Employee.java 12345678910111213@Datapublic class Employee implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; private String lastName; private String email; /** * 性别 1男 0女 */ private Integer gender; private Integer dId;&#125; Department.java 12345678@Datapublic class Department implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; private String departmentName;&#125; EmployeeMapper.java 1234567891011121314151617181920212223242526272829303132333435363738public interface EmployeeMapper &#123; /** * 增加员工 * @param employee */ @Insert(\"INSERT INTO employee (lastName, email, gender, d_id) VALUES(#&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125;, #&#123;dId&#125;)\") void insertEmployee(Employee employee); /** * 根据id删除员工 * @param id */ @Delete(\"DELETE FROM employee WHERE id = #&#123;id&#125;\") void deleteEmployeeById(Integer id); /** * 根据id修改员工 * @param employee */ @Update(\"UPDATE employee SET lastName = #&#123;lastName&#125;, email = #&#123;email&#125;, gender = #&#123;gender&#125;, d_id = #&#123;dId&#125; WHERE id = #&#123;id&#125;\") void updateEmployeeById(Employee employee); /** * 根据id查询员工 * @param id * @return */ @Select(\"SELECT * FROM employee WHERE id = #&#123;id&#125;\") Employee selectEmployeeById(Integer id); /** * 根据lastName查询员工 * @param lastName */ @Select(\"SELECT * FROM employee WHERE lastName = #&#123;lastName&#125;\") Employee selectEmployeeByLastName(String lastName);&#125; Department.java 123456789101112131415/** * @author Yang * @version 1.0 * @time 2019/4/1 */public interface DepartmentMapper &#123; /** * 根据id查询部门表 * @param id * @return */ @Select(\"SELECT * FROM department WHERE id = #&#123;id&#125;\") Department selectDepartmentById(Integer id);&#125; SpringBoot主程序类Springboot09CacheApplication.java 12345678@SpringBootApplication@MapperScan(\"com.ahead.springboot.mapper\")@EnableCachingpublic class Springboot09CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot09CacheApplication.class, args); &#125;&#125; 1、@CacheableCacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字 cacheNames/value: 指定缓存组件的名字（缓存到哪个缓存组件中） key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值， 1-方法的返回值 编写SpEl；#id;参数id的值 #a0 #p0 #root.args[0] keyGenerator：key的生成器；可以自己指定key的生成器的组件id(可以自定义一个KeyGenerator，然后注册到容器中)（下一篇运行流程原理会测试） key/keyGenerator：二选一使用 cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器（后面单独有一篇写这个的） condition：指定符合条件的情况下才缓存 condition = “#id &gt; 1” ：id大于1才进行缓存 unless：否定缓存/排除条件；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果并进行判断 unless = “#result == null” unless = “#id == 2” : id等于2就不缓存（如果满足condition也满足unless，以unless的为准） sync：是否同步；在多线程环境下，某些操作可能使用相同参数同步调用。 默认情况下（默认不同步，也就是异步），缓存不锁定任何资源，可能导致多次计算，而违反了缓存的目的。 对于这些特定的情况，属性 sync 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞， 直到返回结果更新到缓存中。 在上面属性中有些属性是能通过SpEl表达式获取的 | 名字 | 位置 | 描述 | 示例 || ————— | —————— | ———————————————————— | ——————– || methodName | root object | 当前被调用的方法名 | #root.methodName || method | root object | 当前被调用的方法 | #root.method.name || target | root object | 当前被调用的目标对象 | #root.target || targetClass | root object | 当前被调用的目标对象类 | #root.targetClass || args | root object | 当前被调用的方法的参数列表 | #root.args[0] || caches | root object | 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache | #root.caches[0].name || argument name | evaluation context | 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引； | #iban 、 #a0 、 #p0 || result | evaluation context | 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false） | #result | 1.1、EmployeeService.java 123456@Cacheable(cacheNames = &#123;\"emp\"&#125;)public Employee getEmployeeById(Integer id) &#123; System.out.println(id + \"号员工被查询\"); Employee employee = employeeMapper.selectEmployeeById(id); return employee;&#125; 1.2、EmployeeController.java 12345678@Autowired private EmployeeService employeeService; @GetMapping(\"/emp/&#123;id&#125;\") public Employee getEmployeeById(@PathVariable Integer id) &#123; Employee employee = employeeService.getEmployeeById(id); return employee; &#125; 1.3、访问http://localhost:8080/emp/1测试 ​ 结果：第一遍显示查询SQL语句并打印1号员工被查询，第二次请求没有 ​ 其他的属性可以自行测试 2、@CachePut运行流程： 先调用目标方法（目标方法一定会被执行） 将方法的返回值存到缓存中 2.1、EmploeeService.java @Cacheable不能使用#result，因为它是先根据key查询缓存再执行目标方法（详细见运行流程那一篇），目标方法都没执行就要使用key，没有#result 1234567891011/** * 如果与查询方法所用的key不一致，导致缓存中有两份数据 * 防止上述问题发生： * 指定一致的key */@CachePut(cacheNames = &#123;\"emp\"&#125;, key = \"#result.id\") public Employee modifyEmployeeById(Employee employee) &#123; System.out.println(employee.getId() + \"号员工被修改!\"); employeeMapper.updateEmployeeById(employee); return employee; &#125; 2.2、EmploeeController.java 12345@GetMapping(\"/emp\") public Employee modifyEmployeeById(Employee employee) &#123; Employee emp = employeeService.modifyEmployeeById(employee); return emp; &#125; 结果：修改员工对象后（http://localhost:8080/emp?id=1&amp;lastName=Yang&amp;gender=0），再查询相同对象（http://localhost:8080/emp/1）控制台不会打印查询SQL语句，**修改后会将方法的返回值存到缓存中** 3、@CacheEvict@CacheEvict删除缓存中的数据 key：指定要删除的key allEntries：是否删除该缓存组件中的所有缓存（默认false） beforeInvocation：是否在目标方法执行之前清除缓存 默认false：在目标方法执行之后清除缓存；如果目标方法执行时出错了就不会清除缓存了 beforeInvocation = true：在目标方法执行之前清除缓存；不管目标方法出错与否都会清除缓存 3.1、EmployeeService.java 12345@CacheEvict(cacheNames = &#123;&quot;emp&quot;&#125;, key = &quot;#id&quot;) public void removeEmployeeById(Integer id) &#123; System.out.println(id + &quot;号员工在缓存中被删除！&quot;); //方便测试是否删除缓存中的数据，这里不需要删除数据库中的数据 &#125; 3.2、EmployeeController.java 12345@GetMapping(\"/delemp/&#123;id&#125;\") public String removeEmployeeById(@PathVariable Integer id) &#123; employeeService.removeEmployeeById(id); return \"success\"; &#125; 结果： 1）、查询一号员工(http://localhost:8080/emp/1)，先使其在缓存中，再删除1号员工(http://localhost:8080/delemp/1)，再查询一号员工(http://localhost:8080/emp/1)，控制台打印了SQL查询语句，缓存中的数据被删除了。 2）、beforeInvocation默认为false，在目标方法执行之后清除缓存；如果目标方法执行时出错了就不会清除缓存了这里使其报错，最终的重复上述访问测试，删除报错，查询时没有发送SQL查询语句，缓存中的数据没有被删除 可以指定beforeInvocation=true；在目标方法执行之前清除缓存；这时候虽然删除报错，但是查询时发送了SQL查询语句，缓存中的数据被删除 123456@CacheEvict(cacheNames = &#123;\"emp\"&#125;, key = \"#id\")public void removeEmployeeById(Integer id) &#123; int i = 1 / 0; System.out.println(id + \"号员工在缓存中被删除！\"); //方便测试是否删除缓存中的数据，这里不需要删除数据库中的数据&#125; 3）、指定allEntries = true，这时候访问会删除该Cache组件中所有的缓存，查询1号和2号员工都发送了SQL查询语句，缓存组件数据被清空 123456@CacheEvict(cacheNames = &#123;\"emp\"&#125;, key = \"#id\", allEntries = true)public void removeEmployeeById(Integer id) &#123; int i = 1 / 0; System.out.println(id + \"号员工在缓存中被删除！\"); //方便测试是否删除缓存中的数据，这里不需要删除数据库中的数据&#125; 4、@Caching其属性是缓存注解的集合，因此可以配置复杂的缓存配置 12345678910111213@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching &#123; Cacheable[] cacheable() default &#123;&#125;; CachePut[] put() default &#123;&#125;; CacheEvict[] evict() default &#123;&#125;;&#125; 以下面为例，这时候既会以lastName为key缓存数据，也会以id缓存数据，这时候查询(http://localhost:8080/emp/1)在控制台是不会打印SQL查询语句的 EmployeeService.java 123456789101112131415161718/** * @Caching：配置复杂的缓存配置 * * @param lastName * @return */ @Caching( cacheable = &#123; @Cacheable(cacheNames = \"emp\", key = \"#lastName\") &#125;, put = &#123; @CachePut(cacheNames = \"emp\", key = \"#result.id\") &#125; ) public Employee getEmployeeByLastName(String lastName) &#123; Employee employee = employeeMapper.selectEmployeeByLastName(lastName); return employee; &#125; EmployeeController.java 1234@GetMapping(\"/emp/lastname/&#123;lastName&#125;\") public Employee getEmployeeByLastName(@PathVariable String lastName) &#123; return employeeService.getEmployeeByLastName(lastName); &#125; 5、CacheConfig标注在类上，抽取每个方法中相同的属性，这里只要定义一次就ok，以cacheNames为例 123@CacheConfig(cacheNames = \"emp\")@Servicepublic class EmployeeService &#123;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习07_自定义starter","slug":"2019-04-05-SpringBoot学习07_自定义starter","date":"2019-04-04T16:21:00.000Z","updated":"2019-04-04T16:28:35.649Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习07_自定义starter/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习07_自定义starter/","excerpt":"","text":"​ 查看Spring Boot的源码，starter包并没有真正的代码，代码都在autoconfigurer包中，所以我也可以照葫芦画瓢，创建一个starter项目和一个autoconfigurer项目，在autoconfigurer项目中写自动配置类，在starter项目中依赖autoconfigurer项目，到时候别人用就直接引入starter的坐标就能使用我自定义的starter了 Mybatis的starter与autoconfigurer也是自己写的，所以我们的命名方式可以根据它这样来定义为ahead-spring-boot-starter，ahead-spring-boot-starter-autoconfigurer 1、创建一个普通的maven工程，打包方式为jar，名称为ahead-spring-boot-starter 2、创建一个Spring boot应用，命名为ahead-spring-boot-starter-autoconfigurer，不需要添加任何组件，只保留默认的spring-boot-starter依赖就行，删除自带的maven插件，最终的pom文件如下 3、编写自定义的starter 我在前面就写过SpringBoot的配置原理，通过全局配置文件中的值与xxxProperties属性映射并添加到组件中去，在配置类中就能获取到xxxProperties对象并获取其中的属性值设置给某些组件的属性，最后在classpath路径下的META-INF文件夹下的spring.factories文件中指定需要自动配置的类，就会被SpringBoot读取到，达到了自动配置的效果 3.1、创建HelloProperties类并指定与全局配置文件中的那个下面的属性进行映射 3.2、编写HelloService组件 3.3、编写HelloAutoConfiguration自动配置类，并注册HelloService组件 3.4、在classpath下的META-INF文件夹下的spring.factories文件指定要自动配置的类（之前用@Configuration注解标注的配置类因为在Spring Boot主配置类的扫描范围内，而这里的扫描不到，就需要在文件中指定自动配置类的位置，这样Spring Boot就能获取到） 3.5、在starter项目中引入autoconfigurer项目的坐标，并通过maven命令先打包 ahead-spring-boot-starter-autoconfigurer项目在打包ahead-spring-boot-starter项目 4、编写一个Spring Boot应用进行测试 4.1、引入自定义的starter 4.2、在全局配置文件中指定HelloProperties中的name属性值 4.3、编写HelloController并启动应用通过浏览器访问测试。 4.4、自动配置成功","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习06_整合JPA","slug":"2019-04-05-SpringBoot学习06_整合JPA","date":"2019-04-04T16:17:00.000Z","updated":"2019-04-04T16:20:43.486Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习06_整合JPA/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习06_整合JPA/","excerpt":"","text":"一、SpringData与JPA简介Spring下的子项目SpringData在数据访问这块提供了一套接口来简化数据访问，提供了很多接口，只需要实现其接口不需要写任何代码就能使用了，底层已经实现了基本的CRUD方法与分页方法，其中包含关系型数据库(mysql等等)与NoSQL(redis,hbase等等)。 JPA（Java Persistence API)是SUN官方推出的Java持久化规范，它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。简单来说就是一种规范并不提供实现（好比JDBC与各大关系型数据库驱动的关系一样） 二、整合JPA1、创建jpa数据库（空表） 2、编写与数据库表映射的pojo，可以使用JPA的注解编写一些表中字段的属性 3、编写UserRepository接口继承JpaRepository（SpringData提供的） 4、在全局配置文件中配置JPA的属性（Spring Boot的JPA的启动器默认使用hibernate实现） spring.jpa.hibernate.ddl-auto=update(没有对应的表就创建，有就更新) spring.jpa.show-sql=true(控制台打印执行的SQL语句) 5、启动发现数据库自动创建了与pojo对应的t_user表了 6、编写UserController测试，因为我们UserRepository继承了SpringData提供的接口所以这里能直接从容器中自动注入（SpringData提供的接口中底层已经写好了基本的CRUD方法，这里直接调用就行）","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习06_整合Mybatis","slug":"2019-04-05-SpringBoot学习06_整合Mybatis","date":"2019-04-04T16:09:00.000Z","updated":"2019-04-04T16:15:24.616Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习06_整合Mybatis/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习06_整合Mybatis/","excerpt":"","text":"一、环境搭建1、创建项目时添加WEB、JDBC、MySQL、MyBatis启动器 2、创建mybatis数据库，并创建employee表与department表，还有对应的pojo（使用了lombok的@Data注解在编译时自动生成getter，setter，toString方法） 3、全局配置文件 二、整合注解版的Mybatis1、DeparmentMapper，这里的Mapper可以使用@Mapper注解在容器中注册，每个Mapper都要这样写太麻烦了，也可以在配置类中指定某个包下的所有Mapper接口，我在下面的配置类写了。 2、使用配置类配置Mybatis的全局配置 上面的数据库中的字段与Java中属性字段并没有对应，这时候我们需要开启驼峰命名法，在查数据的时候就能映射上了，但是注解版的怎么配置呢？ 前面我写过定制嵌入式的Servlet容器的原理，就是自己写一个定制器，最终SpringBoot会获取所有的定制器并调用它们的方法，Mybatis也是一样的原理（不过这是Mybatis自己写的） 在MybatisAutoConfiguration中会往容器中注册SqlSessionFactoryBean组件，这里面会创建一个SqlSessionFactoryBean对象然后调用applyConfiguration方法 3、进入applyConfiguration方法，这里会获取所有的ConfigurationCustomizer定制器且调用它们的customize方法传入配置类进去，所以我们只需要把自定义的ConfigurationCustomizer定制器注册到容器中和给配置类设置开启驼峰命名法，就会被读取到了。设置扫描mapper包下所有Mapper接口 4、编写DepartmentController测试 三、整合非注解版Mybatis（常用）1、EmployeeMapper与对应的SQL映射文件（与Mybatis相关的配置放在classpath下的mybatis文件夹下） 2、使用全局配置文件配置开启驼峰命名法并设置别名 3、在全局配置文件中指定SQL映射文件与Mybatis全局配置文件的路径（在MybatisProperties也有对应的属性映射） 4、编写EmployeeController测试","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习06_整合Druid与配置监控数据源","slug":"2019-04-05-SpringBoot学习06_整合Druid与配置监控数据源","date":"2019-04-04T16:00:00.000Z","updated":"2019-04-04T16:08:30.384Z","comments":true,"path":"2019/04/05/2019-04-05-SpringBoot学习06_整合Druid与配置监控数据源/","link":"","permalink":"http://yoursite.com/2019/04/05/2019-04-05-SpringBoot学习06_整合Druid与配置监控数据源/","excerpt":"","text":"该文章写的demo用的是上一篇的环境 使用Druid的好处就是能够监控到应用中的一些信息，比如操作了多少次，执行了什么SQL语句等等。 1、引入druid的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 2、在全局配置文件中除了配置基本的jdbc连接数据库的属性外还有下面多出来的配置 1234567891011121314151617181920212223242526272829spring: datasource: url: jdbc:mysql://192.168.25.157/jdbc?serverTimezone=UTC driver-class-name: com.mysql.jdbc.Driver username: root password: 123456 initialization-mode: always schema: - classpath:auto_create.sql data: - classpath:insert.sql type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'WallFilter'用于防火墙 filters: stat, wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3、Spring Boot通过DataSourceProperties映射得到的属性值会设置给DataSource,但是在DataSourceProperties中没有对应的属性与多出来的配置进行映射，IDEA会黄色警告了，因此我们可以自定义一个配置类并注册Druid类型的数据源，然后使用@ConfigurationProperties(prefix = “spring.datasource”)注解让全局配置文件中与其映射，最后就能达到我们所需要的效果了。 4、为了能够使用Druid的监控功能我们需要进行一些配置 配置一个管理后台的StatViewServlet，并设置初始化参数和访问路径 配置一个WEB监控的WebStatFilter，并设置拦截路径与不拦截的路径 DruidConfig.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druidDataSource() &#123; return new DruidDataSource(); &#125; //配置DruidDataSource的监控 /** * 配置一个管理后台的Servlet * @return */ @Bean public ServletRegistrationBean&lt;StatViewServlet&gt; statViewServlet() &#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet()); Map&lt;String, String&gt; initMap = new HashMap&lt;&gt;(); //登陆的用户名 key在StatViewServlet的父类中能够找到 initMap.put(\"loginUsername\", \"root\"); //登陆的密码 initMap.put(\"loginPassword\", \"20180101\"); //允许哪个地址能访问 默认就是允许所有访问 initMap.put(\"allow\", \"\"); //设置哪个不能访问 initMap.put(\"deny\", \"192.168.0.125\"); //设置Servlet的初始化参数 bean.setInitParameters(initMap); //设置访问路径 bean.setUrlMappings(Arrays.asList(\"/druid/*\")); return bean; &#125; /** * 配置一个WEB监控的Filter * @return */ @Bean public FilterRegistrationBean&lt;WebStatFilter&gt; webStatFilter() &#123; FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;(new WebStatFilter()); Map&lt;String, String&gt; initMap = new HashMap&lt;&gt;(); //设置不拦截哪个请求 initMap.put(\"exclusions\", \"*.js, *.css, /druid/**\"); //设置过滤器的初始化参数 bean.setInitParameters(initMap); //设置什么都拦截，这样才能监控出数据 bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 5、启动应用访问测试，具有很多监控的功能，因为我们在启动应用的时候创建了表和插入了数据，因此在SQL监控功能中能够找到","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习06_整合JDBC","slug":"2019-04-04-SpringBoot学习06_整合JDBC","date":"2019-04-04T15:47:00.000Z","updated":"2019-04-04T15:55:15.578Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习06_整合JDBC/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习06_整合JDBC/","excerpt":"","text":"一、Spring Boot整合JDBC1、创建Spring Boot应用时，除了要添加的WEB模块还需要额外添加JDBC启动器和MySQL启动器 2、创建数据库jdbc并创建一张Employee表，添加一条数据 123456spring: datasource: url: jdbc:mysql://localhost/jdbc?serverTimezone=UTC driver-class-name: com.mysql.jdbc.Driver username: 用户名 password: 密码 4、编写Controller测试，自动注入JdbcTemplate(Spring Boot自动配置好了) 原理1、在DataSourceConfiguration类中有自动配置的组件，Spring Boot支持org.apache.tomcat.jdbc.pool.DataSource com.zaxxer.hikari.HikariDataSource org.apache.commons.dbcp2.BasicDataSource Spring Boot默认使用的HikariDataSource这个连接池，在源码中发现Spring Boot也支持通过全局配置文件使用spring.datasource.type指定额外的连接池（通过build方法） 2、在JdbcTemplateAutoConfiguration类中会把JdbcTemplate配置到容器中，这也是为什么我们在上面的demo中能直接从容器中自动注入该组件的实例 二、Spring Boot还支持启动时能自动创建表和插入数据1、在全局配置进行配置：spring.datasource.schema指定的是启动应用时在数据库执行的sql文件（建表语句），spring.datasource.data指定的也是sql文件（增删改语句） 当然也可以不设置这两个属性，默认建表的sql文件名是schema.sql/schema-all.sql，增删改的sql文件名是data.sql/data-all.sql 1234567891011spring: datasource: url: jdbc:mysql://localhost/jdbc?serverTimezone=UTC driver-class-name: com.mysql.jdbc.Driver username: 用户名 password: 密码 initialization-mode: always schema: - classpath:auto_create.sql data: - classpath:insert.sql 2、启动应用测试 原理1、在DataSourceInitializationConfiguration配置类中会导入一个DataSourceInitializerInvoker组件 2、点到DataSourceInitializerInvoker类中，官方注释说该bean初始化时会运行schema-.schema-\\.sql-*.sql* 3、在DataSourceInitializerInvoker类中有个设置完属性之后会调用的afterPropertiesSet方法，该方法中调用了createSchema方法 4、点进createSchema方法会调用getScripts方法（传入spring.datasource.schema和schema进去） 5、进入getScripts方法，这里面会从classpath路径下获取sql文件，而拼装起来的文件名就是根据传过来的参数所决定的。（platform=”all”）,所以这里的文件名为schema.sql和schema-all.sql 6、在DataSourceInitializerInvoker类中还有个监听方法，该方法会调用initSchema方法 7、进入initSchema方法又是调用getScripts方法而传入的参数就是spring.datasource.data和data，所以这个一定是获得类路径下的data.sql和data-all.sql文件 所以默认使用的文件名就是schema.sql/schema-all.sql，data.sql/data-all.sql，也可以通过spring.datasource.data/spring.datasource.schema指定自定义文件名的sql文件","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习05_Docker入门","slug":"2019-04-04-SpringBoot学习05_Docker入门","date":"2019-04-04T15:41:00.000Z","updated":"2019-04-05T04:04:13.338Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习05_Docker入门/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习05_Docker入门/","excerpt":"","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。（来自百度百科） 一、核心概念docker镜像：镜像就是一个只读的模板，用于创建Docker容器的模板 docker容器：容器是独立运行的一个或一组应用 docker客户端：客户端通过命令行或者其他工具使用Docker docker主机：一个物理或者虚拟的机器用于执行docker守护进程和容器 docker仓库：docker仓库用来保存镜像，可以理解为代码控制中的代码仓库 二、常用命令1、搜索镜像 1[root@localhost ~]# docker search tomcat 2、拉取镜像 1[root@localhost ~]# docker pull tomcat:#版本/tag默认是最新版本 3、删除镜像 必须先删除对应的容器，删除对应的容器又必须先停止对应容器 1docker rmi image.id 4、根据镜像启动容器 1docker run --name mytomcat -d tomcat:latest 5、查看运行中的容器 1docker ps 6、 停止运行中的容器 1docker stop #容器的id 7、查看所有的容器 1docker ps -a 8、启动容器 1docker start #容器id 9、删除一个容器 1docker rm #容器id 10、启动一个做了端口映射的tomcat 123[root@localhost ~]# docker run -d -p 8888:8080 tomcat#-d：后台运行#-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 11、为了演示简单关闭了linux的防火墙 12service firewalld status #查看防火墙状态service firewalld stop #关闭防火墙 12、查看容器的日志 1docker logs container-name/container-id 更多命令参看 docker 可以参考每一个镜像的文档 三、安装MySQL示例1、拉取mysql镜像 1docker pull mysql 2、错误的启动 1234567891011121314[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846#mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan#错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and #MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 3、正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 4、做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 5、几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面#改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci#指定mysql的一些配置参数","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习05_Docker卸载与安装","slug":"2019-04-04-SpringBoot学习05_Docker卸载与安装","date":"2019-04-04T15:36:00.000Z","updated":"2019-04-04T15:39:32.964Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习05_Docker卸载与安装/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习05_Docker卸载与安装/","excerpt":"","text":"一、完全的卸载centos上的docker 1首先搜索已经安装的docker 安装包 1[root@localhost ~]# yum list installed|grep docker 或者使用该命令 1234[root@localhost ~]# rpm -qa|grep docker docker.x86_64 2:1.12.6-16.el7.centos @extras docker-client.x86_64 2:1.12.6-16.el7.centos @extras docker-common.x86_64 2:1.12.6-16.el7.centos @extra= 2 分别删除安装包 123[root@localhost ~]#yum –y remove docker.x86_64 [root@localhost ~]#yum –y remove docker-client.x86_64 [root@localhost ~]#yum –y remove docker-common.x86_64 3 删除docker 镜像 1[root@localhost ~]# rm -rf /var/lib/docker 4 再次check docker是否已经卸载成功 12[root@localhost ~]# rm -rf /var/lib/docker [root@localhost ~]# 如果没有搜索到，那么表示已经卸载成功。 如果没有完全卸载最后通过镜像启动起来创建容器的时候可能会报错（坑） 二、安装docker（这里使用的是centos7） 1、安装docker的linux内核版本需要3.10.0及以上版本，使用 uname -r检查内核版本 2、保证yum包更新到最新 yum -y update 3、安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 4、设置yum源 yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo 如果上面的没用就使用国内阿里云的 yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 5、查看仓库中所有的docker版本并选择特定版本安装 yum list docker-ce –showduplicates | sort -r 6、安装docker，指定版本 我选的是17.12.1.ce yum install docker-ce-17.12.1.ce 7、启动并设置开机启动 systemctl start docker.service systemctl enable docker.service 8、查看docker版本 docker version, 有client端与service端表示安装和启动都成功了 123456789101112131415161718Client: Version: 18.09.2 API version: 1.39 Go version: go1.10.6 Git commit: 6247962 Built: Sun Feb 10 04:13:27 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.2 API version: 1.39 (minimum version 1.12) Go version: go1.10.6 Git commit: 6247962 Built: Sun Feb 10 03:47:25 2019 OS/Arch: linux/amd64 Experimental: false 9、使用阿里云镜像，用国外的官网拉取镜像会很慢，进去注册自己的账号，点击控制台，左边搜索容器镜像服务 10、点击镜像加速器，复制选中的内容到linux系统下就行了","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_外部Servlet容器启动原理","slug":"2019-04-04-SpringBoot学习04_外部Servlet容器启动原理","date":"2019-04-04T15:29:00.000Z","updated":"2019-04-04T15:33:43.801Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器启动原理/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器启动原理/","excerpt":"","text":"1、创建使用外部Servlet容器的Spring Boot的项目，会多一个类。 2、通过外部的tomcat的启动时会发现先启动tomcat，然后就会启动之前Spring Boot的主配置类程序。 3、在Servlet3.0的有几个规范 服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例 ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名** 还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；** 该文件就在spring-web包下 4、在应用启动时就会加载web应用里面每一个jar包里面ServletContainerInitializer实例中的onStartup方法 这里会获得感兴趣的类的实例并遍历调用它们的onStartup方法 5、在ServletContainerInitializer的实现类SpringServletContainerInitializer上有个@HandlesTypes({WebApplicationInitializer.class})，WebApplicationInitializer就是我们感兴趣的类，查看WebApplicationInitializer接口的子类发现就有我们上面比嵌入式Servlet容器的Spring Boot项目多余出来的ServletInitializer类 6、而我们这个类没有onStartUp方法，进入它父类找到onStartUp方法 主要就是这个createRootApplicationContext方法，我们进入这个方法 7、configure方法ServletInitializer类有这个方法，所以就会调用自己的configure方法，传进去的参数是当前项目的主配置类 8、最后构建出一个SpringApplication对象并调用run方法跑起来。 9、而run方法一路点过去，会发现到了之前我们主配置类启动时调用的run方法，最终我们的SpringBoot应用就启动起来了。 总结：在外部的Servlet的容器启动的时候因为Servlet3.0有个规则就会加载所有感兴趣类中的onStartUp方法，然后调用我们多出来的ServletInitializer类的Configure方法，把当前项目的主配置类传进去，创建出SpringApplication对象并启动SpringBoot应用。最终项目就是tomcat先启动，然后再是Spring Boot项目启动，当然Spring Boot中的功能是一样能用的","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_外部Servlet容器JSP支持","slug":"2019-04-04-SpringBoot学习04_外部Servlet容器JSP支持","date":"2019-04-04T15:23:00.000Z","updated":"2019-04-04T15:28:31.564Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器JSP支持/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习04_外部Servlet容器JSP支持/","excerpt":"","text":"Spring Boot的嵌入式的Servlet容器虽然方便，快捷，支持jar包的方式运行项目 但是却是不能支持jsp的，这时候我们可以使用外部的Servlet容器。 1、新建一个Module，然后next 2、项目的坐标，这里要改成war包，下一步 3、选中web模块，然后next，再finish完成项目的创建 4、但是我们项目中并没有webapp，不需要自己创建，可以通过ide来自动创建 5、选中项目按f4或右键open module setting，点击web 6、点击右边的添加 7、把地址修改成如下图，点击ok，然后apply 8、点击右上角的添加选中web.xml 9、修改地址如下，版本也是可以选择的，点击ok，apply，ok，关闭 10、创建hello.jsp，这时候需要添加tomcat容器(自行添加)，部署项目到tomcat容器上，访问成功","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_嵌入式Servlet容器启动原理","slug":"2019-04-04-SpringBoot学习04_嵌入式Servlet容器启动原理","date":"2019-04-04T15:13:00.000Z","updated":"2019-04-04T15:21:07.755Z","comments":true,"path":"2019/04/04/2019-04-04-SpringBoot学习04_嵌入式Servlet容器启动原理/","link":"","permalink":"http://yoursite.com/2019/04/04/2019-04-04-SpringBoot学习04_嵌入式Servlet容器启动原理/","excerpt":"","text":"注：看完这一篇再回头看上一篇就会理解了 上一篇文章解释了嵌入式Servlet容器的默认配置和修改配置的原理，但其前提条件是创建嵌入式Servlet容器工厂。下面就进行debug解释嵌入式Servlet容器是怎么启动的。 1、来到ServletWebServerFactoryConfiguration类给组件TomcatServletWebServerFactory打上断点。再来到TomcatServletWebServerFactory类上给getWebServer方法打上断点并debug运行 2、先是创建好一个Spring Boot应用并启动项目 3、刷新容器 4、进入createApplicationContext方法看容器怎么创建的 会判断当前项目是否为web项目，然后创建一个web的IOC容器， 5、一直调用，来到真正的代码逻辑上。(刷新刚才创建好的容器，都是一些初始化方法) 6、下一步来到了获取嵌入式的Servlet容器工厂中，IOC容器机制就是有人需要时我才会通过注册的组件创建对象返回给你，这里需要获取容器工厂。 7、一旦需要获取容器工厂了，IOC容器就会创建TomcatServletWebServerFactory（ServletWebServerFactory的子类）对象，它一创建就会惊动bean注册后置处理器（BeanPostProcessorsRegistrar），就会调用所有的定制器定制Servlet容器的相关配置。(上一篇文章详解了地址) 8、不重要的不看，直接放行 这一步就会通过嵌入式的Servlet容器工厂获得嵌入式的Servlet容器 9、最终来到这里创建Tomcat容器并进行初始化一些值，getTomcatWebServer中会启动Tomcat(上一篇文章详解了地址)","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Linux文本编辑器vi/vim","slug":"2019-04-02-Linux文本编辑器vim","date":"2019-04-02T10:20:00.000Z","updated":"2019-04-02T12:57:17.618Z","comments":true,"path":"2019/04/02/2019-04-02-Linux文本编辑器vim/","link":"","permalink":"http://yoursite.com/2019/04/02/2019-04-02-Linux文本编辑器vim/","excerpt":"","text":"只会总结常用命令，不常用的文档就行 一、介绍1、Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 2、二者的区别 vi：相当于普通文本打开，默认Linux系统自带 vim：相当于一个IDE，如果有特殊的代码或者关键字会有不同颜色的显示（没有自带，使用 yum -y install vim 安装） 3、vim 键盘图： 二、vi/vim工作模式vi/vim工作分为三种模式：命令模式、输入模式、底线命令模式 1、命令模式：用户刚刚启动 vi/vim，便进入了命令模式。该模式下等待用户做出进一步的指令，进入输入模式或底线模式。 输入模式快捷键 i 切换到插入模式，并在当前光标位置之前开始插入 I 将光标移至当前行的开头位置，并切换到插入模式 a 切换到插入模式，并在当前光标位置之后开始插入 A 将光标移至当前行的结尾位置，并切换到插入模式 o 在当前行的下方新打开一个行，并切换至插入模式 O 在当前行的上方新打开一个行，并切换至插入模式 r 替换当前光标所在位置的字符 R 从当前光标所在位置开始替换输出后面的内容，按ESC结束 D 删除光标所在处到行尾的内容 gg 跳转到文档第一行 G 跳转到文档到最后一行 x 删除光标所在位置的字符 yy 复制当前行 P 粘贴到当前行的上面（大写） p 粘贴到当前行的下面（小写） u 取消上一步操作 2、输入模式编辑模式，即进入文本编辑模式。 3、底线命令模式底线命令模式可以输入单个或多个字符的命令，调用不同的VI编辑功能，可用的命令多样。 底线命令模式功能 :set nu 设置行号** :set nonu 设置取消行号 :n 前往某一行 :wq 保存修改并且退出 :q! 不保存修改退出 /string 在文件中所搜制定字符串string n 查看字符串上一个出现的位置 N查看字符串上一个出现的位置 4、vim默认的初始化设置通过编辑”/root/.vimrc”文件可以设置vim编辑器初始化的一些设置 例如在改文件中输入该命令保存退出：:set nu 默认使用vim进入文件编辑就会显示行号了","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Linux课堂之网络命令详解","slug":"2019-03-29-Linux课堂之网络命令详解","date":"2019-03-29T03:14:00.000Z","updated":"2019-03-29T03:15:08.253Z","comments":true,"path":"2019/03/29/2019-03-29-Linux课堂之网络命令详解/","link":"","permalink":"http://yoursite.com/2019/03/29/2019-03-29-Linux课堂之网络命令详解/","excerpt":"","text":"一、网络相关命令1、用ping命令测试Linux是否联网ping[选项] [网址/ip] ping 网址还是会被解析成 ip 地址 选项：-c n Linux中 ping 默认是无限 ping ，可以使用 -c选择设置 ping 的次数，如果不使用 -c选项，无限 ping 可以使用 Ctrl + c 退出 eg：使用 ping -c 3 www.baidu.com 命令 ping 百度3次 123456789[root@localhost ~]# ping -c 3 www.baidu.comPING www.a.shifen.com (183.232.231.172) 56(84) bytes of data.64 bytes from localhost (183.232.231.172): icmp_seq=1 ttl=128 time=65.8 ms64 bytes from localhost (183.232.231.172): icmp_seq=2 ttl=128 time=104 ms64 bytes from localhost (183.232.231.172): icmp_seq=3 ttl=128 time=79.6 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2026msrtt min/avg/max/mdev = 65.831/83.310/104.460/15.985 ms 2、使用 ip addr 查看网卡信息eno16777736：网卡代号 inet 192.168.35.157： ip地址inet6：IPv6的地址，还不怎么普及 lo：loop设备的意思，地址是127.0.0.1即本机回送地址 12345678910111213[root@localhost ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:11:08:1f brd ff:ff:ff:ff:ff:ff inet 192.168.35.157/24 brd 192.168.35.255 scope global noprefixroute eno16777736 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe11:81f/64 scope link valid_lft forever preferred_lft forever 3、traceroute [网址] 显示本机到目标网址的路径traceroute [网址] 1234567891011[root@instance-y2jixxt2 ~]# traceroute www.baidu.comtraceroute to www.baidu.com (220.181.112.244), 30 hops max, 60 byte packets 1 10.166.49.30 (10.166.49.30) 1.129 ms 1.592 ms 10.166.49.20 (10.166.49.20) 1.076 ms 2 10.166.13.127 (10.166.13.127) 6.982 ms 7.031 ms 10.166.14.127 (10.166.14.127) 4.317 ms 3 10.166.97.3 (10.166.97.3) 0.911 ms 10.166.97.5 (10.166.97.5) 0.880 ms 10.166.97.1 (10.166.97.1) 0.957 ms 4 10.166.50.4 (10.166.50.4) 9.345 ms 10.166.50.2 (10.166.50.2) 0.925 ms 10.166.50.6 (10.166.50.6) 0.925 ms 5 182.61.253.22 (182.61.253.22) 3.570 ms 182.61.253.20 (182.61.253.20) 3.543 ms 182.61.253.30 (182.61.253.30) 3.537 ms 6 192.168.0.33 (192.168.0.33) 3.044 ms 192.168.0.29 (192.168.0.29) 2.959 ms 2.885 ms 7 10.34.238.245 (10.34.238.245) 3.278 ms 3.267 ms * 8 * * * 9 * * * 4、查看网络状态netstat [选项] -t TCP 协议 -u UDP 协议 -l 监听 -r 路由 -n 显示 ip地址和端口号 常用的组合 4.1、netstat -tlun查看端口信息 4.2、netstat -an 查看本地所有网络连接 4.3、netstat -rn 查看本地路由网关 二、扩展命令5、finger [用户名] 查看用户信息eg：查看 root 用户信息 12345678910[root@localhost ~]# finger root#登录名 #用户名Login: root Name: root#用户所拥有的路径 #使用bash shellDirectory: /root Shell: /bin/bash#什么时候开机的On since Fri Mar 29 08:38 (CST) on pts/0 from 192.168.25.1 3 seconds idleNo mail.No Plan. finger 相当于 env env：查看当前用户的环境信息 1234567891011121314151617181920212223242526[root@localhost ~]# envXDG_SESSION_ID=1HOSTNAME=localhost.localdomainSELINUX_ROLE_REQUESTED=TERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=192.168.25.1 9652 22SELINUX_USE_CURRENT_RANGE=SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:MAIL=/var/spool/mail/rootPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/binPWD=/rootLANG=en_US.UTF-8SELINUX_LEVEL_REQUESTED=HISTCONTROL=ignoredupsSHLVL=1HOME=/rootLOGNAME=rootSSH_CONNECTION=192.168.25.1 9652 192.168.25.157 22LESSOPEN=||/usr/bin/lesspipe.sh %sXDG_RUNTIME_DIR=/run/user/0_=/usr/bin/envOLDPWD=/home 6、echo输出命令1、eg：打印字符串输出到控制台中 echo &quot;aaa&quot; 12[root@localhost ~]# echo \"aaa\"aaa 2、echo [信息] &gt;&gt; [文件名] ：追加内容到文件后面 ​ echo [信息] &gt; [文件名]：将内容覆盖文件中原有的内容 eg：通过echo bb &gt;&gt; a.txt 将字符串 bb 追加到 a.txt 文件中 123456789#a.txt文件中本来就有aa字符串[root@localhost study-linux]# cat a.txtaa#使用echo命令追加[root@localhost study-linux]# echo bb &gt;&gt; a.txt#查看a.txt文件中的内容发现bb已经追加到aa后面了[root@localhost study-linux]# cat a.txtaabb eg：通过 echo cc &gt; a.txt 将字符串 cc 覆盖 a.txt原有的内容 123456[root@localhost study-linux]# cat a.txtaabb[root@localhost study-linux]# echo cc &gt; a.txt[root@localhost study-linux]# cat a.txtcc 7、有关时间的命令date ：查看当前系统时间 eg： 12[root@localhost study-linux]# dateFri Mar 29 11:00:00 CST 2019 man date：查看帮助文档发现可以通过 date 加上格式就可以修改系统默认时间 MMDDhhmmCCYY.ss ===&gt; 月/日/时/分/公元/年/.秒 1234567891011121314151617181920212223DATE(1) User Commands DATE(1)NAME date - print or set the system date and timeSYNOPSIS date [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION Display the current time in the given FORMAT, or set the system date. Mandatory arguments to long options are mandatory for short options too. -d, --date=STRING display time described by STRING, not 'now' -f, --file=DATEFILE like --date once for each line of DATEFILE -I[TIMESPEC], --iso-8601[=TIMESPEC] output date/time in ISO 8601 format. TIMESPEC='date' for date only (the default), 'hours', 'minutes', 'seconds', or 'ns' for date and time to the indicated precision. eg：修改系统默认时间为2020年1月1号12时24分48秒 1234[root@localhost study-linux]# date 010112242020.48Wed Jan 1 12:24:48 CST 2020[root@localhost study-linux]# dateWed Jan 1 12:24:49 CST 2020 cal：日历 eg：cal -y 2019 查看2019年的整年的日历 12345678910111213141516171819202122232425262728293031323334[root@localhost study-linux]# cal -y 2019 2019 January February March Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 1 2 1 2 6 7 8 9 10 11 12 3 4 5 6 7 8 9 3 4 5 6 7 8 913 14 15 16 17 18 19 10 11 12 13 14 15 16 10 11 12 13 14 15 1620 21 22 23 24 25 26 17 18 19 20 21 22 23 17 18 19 20 21 22 2327 28 29 30 31 24 25 26 27 28 24 25 26 27 28 29 30 31 April May June Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 1 2 3 4 1 7 8 9 10 11 12 13 5 6 7 8 9 10 11 2 3 4 5 6 7 814 15 16 17 18 19 20 12 13 14 15 16 17 18 9 10 11 12 13 14 1521 22 23 24 25 26 27 19 20 21 22 23 24 25 16 17 18 19 20 21 2228 29 30 26 27 28 29 30 31 23 24 25 26 27 28 29 30 July August September Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 1 2 3 1 2 3 4 5 6 7 7 8 9 10 11 12 13 4 5 6 7 8 9 10 8 9 10 11 12 13 1414 15 16 17 18 19 20 11 12 13 14 15 16 17 15 16 17 18 19 20 2121 22 23 24 25 26 27 18 19 20 21 22 23 24 22 23 24 25 26 27 2828 29 30 31 25 26 27 28 29 30 31 29 30 October November December Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 1 2 1 2 3 4 5 6 7 6 7 8 9 10 11 12 3 4 5 6 7 8 9 8 9 10 11 12 13 1413 14 15 16 17 18 19 10 11 12 13 14 15 16 15 16 17 18 19 20 2120 21 22 23 24 25 26 17 18 19 20 21 22 23 22 23 24 25 26 27 2827 28 29 30 31 24 25 26 27 28 29 30 29 30 31 eg：cal 3 2019 查看2019年3月的整月的日历 123456789[root@localhost study-linux]# cal 3 2019 March 2019 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 3031 8、设置别名命令alias：查看系统所有被设置别名的命令 eg：alias al = ’ls -i‘ 设置ls -i 命令的别名为al （重启后失效） 123[root@localhost study-linux]# alias al='ls -i'[root@localhost study-linux]# al24560 a.txt 9、帮助文档命令man [命令名称] help [命令名称] 只能查看Linux内部命令（不是外部额外安装的）， 使用 type [命令] 查看是否为内部命令 whereis [命令]：查看命令文件信息（查看到命令安装路径、查看到命令帮助文档的安装路径） which[命令]：只能查看到命令的安装路径","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Spring Boot学习04_嵌入式Servlet容器自动配置原理","slug":"2019-03-28-SpringBoot学习04_嵌入式Servlet容器自动配置原理","date":"2019-03-28T14:38:00.000Z","updated":"2019-03-28T14:50:12.095Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器自动配置原理/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器自动配置原理/","excerpt":"","text":"在Spring Boot的自动配置包下，找到web模块中的servlet文件夹下的ServletWebServerFactoryConfiguration类 一、嵌入式Servlet容器默认的配置原理1、该类中有三个静态内部类（都是配置类）： EmbeddedUndertow、EmbeddedJetty、EmbeddedTomcat 这里拿EmbeddedTomcat来举例说明 @ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class}) 判断classpath下有没有Servlet, Tomcat, UpgradeProtocol这三个类，也就是看maven有没有引入对应的依赖，如果引入了对应的依赖，下面的配置就生效。（上一篇文章SpringBoot切换嵌入式容器就是根据这里来的链接） 2、@ConditionalOnMissingBean(value = {ServletWebServerFactory.class},search = SearchStrategy.CURRENT) 如果容器中没有ServletWebServerFactory这个组件下面的配置就生效 点进ServletWebServerFactory看，该接口只有一个方法，前面只判断这个类型的组件有没有在容器中，而该类型又只有一个方法，说明最终Spring Boot会调用该接口实现类中的getWebServer方法。 3、查看ServletWebServerFactory接口的实现，有三个很面熟的实现类，就是上面ServletWebServerFactoryConfiguration类中要往容器中添加的组件 4、进入TomcatServletWebServerFactory类中查看getWebServer方法 首先会创建一个Tomcat对象，给其设置连接器等一些配置 最终还会调用getTomcatWebServer方法 this.getTomcatWebServer(tomcat); –&gt;return new TomcatWebServer(tomcat, this.getPort() &gt;= 0); 端口号默认是8080所以上面传过去的是true，进入TomcatWebServer的构造方法TomcatWebServer中，在构造方法中又调用了this.initialize();进入initialize方法，该方法就会启动tomcat。(所以这一切都是建立在创建好嵌入式Servlet容器之后) 二、修改SpringBoot初始化嵌入式Servlet容器的默认配置原理上一篇文章（链接）中我们自己配置个WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;组件就可以实现修改SpringBoot初始化嵌入式Servlet容器的默认配置了，下面开始说怎么修改其默认配置的。 在ServletWebServerFactoryAutoConfiguration类上面有 @EnableConfigurationProperties，@Import注解 1、@EnableConfigurationProperties({ServerProperties.class}) 把ServerProperties注册到容器中，并读取全局配置文件中的数据赋值给类中的属性。 只有一个有参构造，形参的值(serverProperties)会从容器中获取，最终交给ServletWebServerFactoryCustomizer类，进入ServletWebServerFactoryCustomizer类 该类也是WebServerFactoryCustomizer的子类 里面有个customize方法会把从容器中获取到的servlerProperties中的值拿出来然后一个一个的设置给factory，最后交给那个map。 2.1、通过@Import往容器中导入了一个BeanPostProcessorsRegistrar类，该类中的作用是 bean注册后置处理器：Bean初始化前后（创建好对象，还没赋值）执行初始化工作(容器中某个组件要创建bean，就会惊动后置处理器，容器中要创建bean这个才会触发，下面的方法才会被调用) 2.2、进入BeanPostProcessorsRegistrar类查看registerBeanDefinitions方法(注册bean的定义)，然后调用registerSyntheticBeanIfMissing方法 2.3、我们点进WebServerFactoryCustomizerBeanPostProcessor类中只需要看postProcessBeforeInitialization方法，在bean创建好之后，初始化之前的调用的方法，该方法首先会判断当前的bean如果为WebServerFactory类型（我们前面需要往容器中注册三个嵌入式Servlet容器就是该接口的实现类，所以当前这个bean就是嵌入式的Servlet容器），就调用postProcessBeforeInitialization方法 2.4、进入postProcessBeforeInitialization方法，该方法会获得所有的定制器，然后遍历，调用每个定制器的customize方法，并把嵌入式的Servlet容器传进去。 上一篇文章（链接）中我们修改嵌入式的Servlet容器的配置也是往容器中添加一个WebServerFactoryCustomizer组件，并在其customize方法中修改配置。 在前面说到通过配置文件来修改配置也是在WebServerFactoryCustomizer的子类中重写了 customize方法，并在其customize方法中修改配置。 回到这里的postProcessBeforeInitialization方法，我们这里把嵌入式的Servlet容器传过去，调用所有定制器的customize方法，不就是调用的上面两种修改配置的重写后的customize方法吗，我们在重写后的customize方法中对参数进行设置值，就是对我们这里传过去的嵌入式Servlet容器设置值，最终通过全局配置文件中配置和往容器中添加一个WebServerFactoryCustomizer组件就可以达到修改嵌入式的Servlet容器的默认值了 往容器中添加一个WebServerFactoryCustomizer组件 前面说到的，经过一系列的逻辑最终全局配置文件中的值会在这里给嵌入式的Servlet容器进行赋值 注：看完这一篇文章要结合下一篇文章来理解","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_嵌入式Servlet容器基本API","slug":"2019-03-28-SpringBoot学习04_嵌入式Servlet容器基本API","date":"2019-03-28T14:32:00.000Z","updated":"2019-03-28T14:33:12.837Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器基本API/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_嵌入式Servlet容器基本API/","excerpt":"","text":"一、嵌入式Servlet容器配置修改1、通过全局配置文件修改(application.properties/yml) 之前的文章说过自动配置原理(文章地址)，只要涉及到自动配置的一定是在xxxAutoConfiguration类中，而xxxAutoConfiguration类中自动配置的组件会在xxxProperties类中获取值，而xxxProperties类与全局配置文件中映射了，所以我们只需要在配置文件给对应的属性赋值就会被Spring Boot自动配置上。 在ServerProperties中有很多属性，还有很多静态内部类，这些我们都可以在全局配置文件中进行配置，比如服务的端口号，请求的项目路径等等。 这里测试端口号和项目路径 2、给容器中配置WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;组件，在匿名内部类中的customize方法里面设置 二、注册Servlet三大组件1、Servlet：往容器中注册一个ServletRegistration&lt;Servlet类名&gt; 2、Filter：往容器中注册一个FilterRegistrationBean&lt;Filter类名&gt; 3、Listener：往容器中注册一个ServletListenerRegistrationBean&lt;Listener类名&gt; 三、切换其他Servlet容器Spring Boot支持三种嵌入式Servlet容器，默认使用Tomcat 1、Tomcat 2、Jetty 3、Undertow 我们可以通过IDEA的依赖关系图来判断。由下面关系图可知，我们只要把对应的依赖排除，要使用哪种嵌入式Servlet容器只要添加对应的依赖就行了。 对应的Undertow也是一样的道理。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_自适应定制错误数据原理","slug":"2019-03-28-SpringBoot学习04_自适应定制错误数据原理","date":"2019-03-28T13:41:00.000Z","updated":"2019-03-28T14:07:08.142Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_自适应定制错误数据原理/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_自适应定制错误数据原理/","excerpt":"","text":"在我们访问Spring Boot应用的时候，出现譬如404，500的错误，默认会跳到如下页面 而做服务端的，浏览器并非为唯一客户端，还有安卓客户端app显示错误数据的方式，如下：（使用postman工具模拟安卓客户端app接受请求），Spring Boot会响应给安卓客户端json数据 这样的页面终归是不友好的，一般会自己定制页面或定制json数据（符合项目风格的错误页面） 前面的文章说了Spring Boot的自动配置一般都会在xxxAutoConfiguration类中 一、错误页面的自动配置在ErrorMvcAutoConfiguration类中1、该类中有个errorPageCustomizer方法，返回的类型是ErrorPageCustomizer（错误页面定制器），只要项目中出现4xx或者5xx错误就会执行该方法。 2、我们点进ErrorPageCustomizer类中查看registerErrorPages方法，而该方法呢会发送一个getPath()请求，最终获得是@Value(“${error.path:/error}”)，意思是从配置文件中获取error.path的值，如果没有就使用”/error”请求url 3、只要请求”/error”，那么在ErrorMvcAutoConfigutaion类中注册的BasicErrorController就会起作用了。 4、点进该类中查看发现该类就是映射”/error”请求的 5、该类中有两个方法errorHtml方法返回ModelAndView，这两个方法都能接收”/error”请求，error方法返回ResponseEntity也就是json数据，说明这两个方法对应的就是浏览器和客户端，errorHtml方法上的produces等于”text/html”，就是响应html类型的数据，而在浏览器中优先接受的就是该类型，客户端优先接受的是application/json类型，所以Spring Boot就能自适应返回不同的数据了 二、浏览器怎么定制错误页面(errorHtml方法)1、进入resolveErrorView方法，点进去 this.resolveErrorView(request, response, status, model); –&gt;resolver.resolveErrorView(request, status, model); 进入到ErrorViewResolver接口，该接口只有一个实现类，进入DefaultErrorViewResolver类中的resolveErrorView方法（DefaultErrorViewResolver也是在ErrorMvcAutoConfiguration类中进行注册了的） 2、resolveErrorView方法会调用resolve方法，会传入状态码和model(后面解释怎么来的)进去，SERIES_VIEWS中有4xx，5xx 3、进入到resolve方法，里面会拼一个视图名称”error/“ 加上传进来的状态码(4xx,5xx)， 这里会根据你的错误类型是什么就会拼成什么类型的视图名称。接着看下面有个方法判断有没有使用模板，如果使用了模板就直接把拼好的视图名称当作逻辑视图名称创建ModelAndView对象返回（使用了Thymeleaf模板，会有一个Thymeleaf视图解析器：前缀是classpath:templates/,后缀是html），如果没有就调用下面resolveResource方法 4、进入resolveResource方法里面的逻辑就是获得静态资源映射的路径(专栏前面的文章有详细讲过(链接))，然后跟传过来的视图名称拼起来并加上html后缀 5、最后说明我们只要把4xx，5xx命名html错误页面放在error文件夹下，然后把error文件夹放入templates文件夹下Spring Boot就会根据是什么类型的错误而跳转到指定的错误页面中。静态资源文件夹下的错误页面就不测试了，一定也是有用的 6、之前Spring Boot默认的错误处理页面中的数据是怎么获得的呢 回到errorHtml方法，点进getErrorAttributes方法 protected Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) –&gt;return this.errorAttributes.getErrorAttributes(webRequest, includeStackTrace); this.errorAttributes就是ErrorAttributes接口类型的，该类只有一个实现类DefaultErrorAttributes(在ErrorMvcAutoConfiguration类中在容器中注册了) 6.1、看getErrorAttributes方法中会创建一个Map，而下面的方法处理就是往该map中添加一些错误数据，比如status状态码，error错误提示信息，exception异常类型。添加完成之后将该Map返回作为model 6.2、所以我们在模板里面就能通过表达式取到错误信息了，异常必须在全局配置中设置项目中包含异常server.error.include-exception=true 7、Spring Boot默认的页面是怎么组成的呢 如果ModelAndView为空(说明自己在规定的路径中没有自定义错误页面)就自己创建一个ModelAndView，然后返回 7.1、在ErrorMvcAutoConfiguraion类中配置了一个组件name就是error，点进defaultErrorView（StaticView类型） 7.2、该类中有个视图渲染方法，就是一个组装好的html字符串和之前Spring Boot默认处理错误页面中的信息一样。 三、客户端怎么定制错误数据（error方法）1、error方法中获取Map数据也是和上面一样的逻辑，最后转换成一个json数据返回给安卓客户端 2、之前说了哪个数据的获得其实是在容器中获取一个ErrorAttributes类型的实例然后调用该实例的getErrorAttributes方法，而ErrorAttributes类型的实例又是在ErrorMvcAutoConfiguration中进行了配置。 3、ErrorMvcAutoConfiguration中配置ErrorAttributes的方法上面有@ConditionalOnMissingBean，意思是容器中没有ErrorAttributes这个类型我就自动配置，那我们就可以写一个DefaultErrorAttributes的子类并重写getErrorAttributes方法，然后添加到容器中。这样的话上面Spring Boot的自动配置ErrorAttributes就不会生效，到时候调用getErrorAttributes方法就会调用我们自己重写的方法，以达到我们定制异常数据的效果。 4、我们这里调用父类的方法，先把Spring Boot默认可以获得到的数据先拿到，然后自己可以添加一些额外的数据并返回，最终获得到的model就是我们这个map，浏览器和客户端的数据都是在这获得到的。 5、如果项目中要处理对应的异常类型但是我们又要兼顾Spring Boot的自适应异常处理，在Spring MVC中我们就已经学习了自定义异常处理。这时候我们只需要根据Spring MVC的来做，最终我们请求转发到 “/error”请求，就会由BasicErrorController来处理自适应。最终又会执行到我们重写的getErrorAttributes方法中，我们自定义的异常信息就能放到request域中，在重写的getErrorAttributes中取出来放到map中，在前端就能取到自定义的错误值了。 总结：在ErrorMvcAutoConfiguration类中自动重要的四个组件1、DefaultErrorAttributes：封装异常数据的，getErrorAttributes方法 2、BasicErrorController：处理异常请求的，映射error请求，进行自适应处理 3、ErrorPageCustomizer：错误页面定制器，出现了4xx，5xx的错误就会执行该类中的 registerErrorPages方法，然后发送error请求 4、DefaultErrorViewResolver：异常视图解析器，resolveErrorView方法根据是什么类型 的异常就解析成什么视图名称 1、在error文件夹下创建4xx,5xx为名的html后缀的页面，用到了模板就把error文件夹放入templates文件夹。没有用到模板就放到静态资源映射路径文件夹下。项目出现了错误，Spring Boot就可以找到对应的页面。 2、页面中可以通过模板中的表达式取到错误信息，也可以通过重写方法配合自定义异常处理器来定制错误信息 12345678910&lt;!-- 状态码 --&gt;&lt;h1&gt;status:[[$&#123;status&#125;]]&lt;/h1&gt;&lt;!-- 时间 --&gt;&lt;h3&gt;time:[[$&#123;#dates.format(timestamp, 'yyyy-MM-dd HH:mm:ss')&#125;]]&lt;/h3&gt;&lt;!-- 错误提示 --&gt;&lt;h3&gt;error:[[$&#123;error&#125;]]&lt;/h3&gt;&lt;!-- 异常信息 --&gt;&lt;h3&gt;message:[[$&#123;message&#125;]]&lt;/h3&gt;&lt;!-- 异常对象 --&gt;&lt;h3&gt;exception:[[$&#123;exception&#125;]]&lt;/h3&gt;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_CRUD总结","slug":"2019-03-28-SpringBoot学习04_例子总结","date":"2019-03-28T13:08:00.000Z","updated":"2019-05-21T08:25:53.961Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_例子总结/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_例子总结/","excerpt":"","text":"本文仅仅是本人做了一个CRUD的demo用来总结知识点的。 一、Spring Boot的国际化比如下面这个页面需要进行中英文的切换，而且根据浏览器的语言进行不同的显示，这时候就要用到国际化技术。 1、在SpringMVC中做国际化1）、编写国际化配置文件 2）、使用ResourceBundleMessageSource管理国际化资源文件 （Spring Boot已经自动配置好） 在MessageSourceAutoConfiguration类中已经自动配置好 3）、在页面中使用fmt:message取出国际化内容 2、SpringBoot做国际化2.1、所以在Spring Boot中只需要编写国际化配置文件，取出国际化内容使用Thymeleaf中的表达式。 2.2、国际化配置文件不在全局配置文件中修改的话，通过源码也可以发现默认使用的是基础名称(基础名称的意思为去掉国家代码和语言代码的名称)为messages所以只要在classpath路径下编写messages.properties做国际化文件，但是我使用的是在classpath文件下新建了一个i18n文件夹，然后在全局配置文件配置了。这样的话Spring Boot就能通过ResourceBundleMessageSource来管理我的国际化资源文件了。 2.3、Spring Boot的区域解析器在WebMvcAutoConfiguration类中能找到，只要容器中没有(@ConditionOnMissingBean)就用SpringBoot配置的，进入AcceptHeaderLocaleResolver类 AcceptHeaderLocaleResolver（该类实现了LocaleResolver接口） –&gt;public Locale resolveLocale(HttpServletRequest request) resolveLocale()方法里面是通过request获取请求头中的语言，说明Spring Boot默认就是根据浏览器的语言来决定用哪种国际化配置文件的。 2.4、自定义区域处理器并添加到容器中，这样就能根据自己的需求来决定怎么使用国际化 3、使用Thymeleaf获取国际化配置文件中的内容#{key}：取到properties配置文件中的值. eg：#{login.username},这样如果是中文环境就会获得中文配置文件的值，如果是英文就会获得英文配置文件中的值 这是默认的值 二、Spring Boot使用拦截器该篇文件中已经解释了为什么实现WebMvcConfigurer接口就能使SpringBoot读取到我们自定义的配置 文章地址 1、先自定义一个拦截器 2、然后在匿名内部类中重写添加拦截器的方法就能达到拦截器的效果了 三、RESTful1、之前我们定义的url都是直接在url上定义对应的意思，而现在我们就可以通过请求方式的不同来达到一样的效果，这样的写法明显更好些 URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3、前端页面一般只支持POST,GET请求，怎么进行PUT,DELETE请求呢 3.1、配置HiddenHttpMethodFilter（Spring Boot已经帮我们配置了） 3.2、必须是POST请求 3.3、需要有一个input请求参数，name=”_method” value=”你需要的请求方式” 四、Thymeleaf使用1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、Thymeleaf中公共页抽取1、抽取公共片段 123&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 2、引入公共片段 1&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt; ~{templatename::selector}：模板名(文件名)::选择器 ~{templatename::fragmentname}:模板名(文件名)::片段名 3、默认效果： insert的公共片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~{}： 行内写法可以加上：[[~{}]];[(~{})]； 有三种方式可以引入 1、th:insert：把片段整个插入到div中，包括根元素 2、th:replace：把片段整个替换掉这个div，包括根元素(使用最多的) 3、th:include：把片段内的内容插入到该div中，不包括根元素 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 通过th:replace引入的方式还可以传参数过去，片段通过${activeUrl}可以取到参数值 小知识点：1、Thymeleaf里面可以通过#strings.isEmpty()判断是否为空 2、#dates.format(xxx,pattern)解决时间格式问题 3、通过th:attr可以达到使用Thymeleaf的语法来设置前端页面中的属性 th:attr=”属性值=thymeleaf语法”，多个中间使用逗号隔开 4、#Spring Boot默认转换的时间格式为yyyy/MM/dd，可通过下面的配置修改 spring.mvc.date-format=yyyy-MM-dd 给自己加油打气：一定要坚持下去，不需要太努力，正常的学习，坚持就行了，加油！","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_Spring MVC自动配置原理","slug":"2019-03-28-SpringBoot学习04_SpringMVC自动配置原理","date":"2019-03-28T12:36:00.000Z","updated":"2019-03-28T13:00:30.729Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_SpringMVC自动配置原理/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_SpringMVC自动配置原理/","excerpt":"","text":"这里复制官网的一段话—&gt;原地址 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. Spring Boot为SpringMVC提供了自动配置，使用于大多数程序 The auto-configuration adds the following features on top of Spring’s defaults: 自动配置在Spring的默认配置之上添加了以下功能 一、包含ContentNegotiatingViewResolver和BeanNameViewResolver类 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 1.1、查看WebMvcAutoConfiguration类中的viewResolver()方法的返回值ContentNegotiatingViewResolver 1.2、进ContentNegotiatingViewResolver类中找到resolveViewName()[解析视图名称]方法。 this.getCandidateViews(viewName, locale, requestedMediaTypes) –&gt;private List getCandidateViews（xxx,xxx,xxx） –&gt;this.viewResolvers 1.3、该类中有个初始化viewResolvers的方法，可以看到该方法中从容器中获得所有的ViewResolver类型的类 1.4、说明ContentNegotiatingViewResolver类就是组合所有的视图解析器 如何定制：通过源码我们可以推导出，我们可以自己编写一个视图解析器类，实现ViewResolver接口，Spring Boot就会把我们自定义的视图解析器和默认的自动组合起来。 在主程序中编写一个静态内部类，并配置到容器中。 1.5、在DispatcherServlet中的doDispatch方法打上断点，启动然后在浏览器随便访问项目的一个url，可以看到我们自定义的视图解析器已经被组合进去了。 Support for serving static resources, including support for WebJars (covered later in this document)). 支持提供静态资源，包括对WebJars的支持：详情见上一篇文章。 二、自动注册了Converter，GenericConverter，Formatter类 utomatic registration of Converter, GenericConverter, and Formatter beans. 2.1、依然可以在WebMvcAutoConfiguration类中找到，下面这段代码的意思是从容器中分别获得Converter，GenericConverter，Formatter这三个类型的所有组件，并添加到格式化注册表中，也就是帮我们自动配置这三个类。 Converter：转换器，我们前端传过来的数据都是文本字符串格式的，而我们在形参上接收是有不同的类型的，比如传一个11过来，前端是文本形式的，这时候Converter类就会把这个11转换为int类型，GenericConverter也是同样的效果。 Formatter：格式化器，比如前端传过来的时间格式是1999/11/20，或者1999-11-20，这时候Formatter类就会把它们转换为Date类型 添加自己的格式化器，我们只需要实现对应的接口然后放入容器中即可。 三、对HttpMessageConverters类进行了支持 Support for HttpMessageConverters (covered later in this document). 3.1、官方文档也解释了其作用，意思就是把对象类型能转换为json和xml形式返回 3.2、只有一个构造方法，会从容器中获得，然后配置HttpMessageConverter。如果我们要配置自己的HttpMessageConverter，就可以自己写个组件，然后添加到容器中，Spring Boot就会自动获取了。 四、自动注册了MessageCodesResolver类 Automatic registration of MessageCodesResolver (covered later in this document). 4.1、找到getMessageCodesResolver()方法 public MessageCodesResolver getMessageCodesResolver() –&gt;this.mvcProperties.getMessageCodesResolverFormat() –&gt;public Format getMessageCodesResolverFormat() –&gt;Format 进入到Format类中看官方的注释可以很清楚的知道这是校验错误信息的处理，比如JSR303 Static index.html support. 静态index.html支持，详情见上一篇文章。 Custom Favicon support (covered later in this document). 自定义图标支持，详情见上一篇文章。 Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动注册了ConfigurableWebBindingInitializer类 这个就不用说了吧，Spring MVC中用来做参数绑定的类 If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapterinstance to provide such components. 如果想使用Spring Boot提供给我们的自动配置而且你还要加上自己自定义的配置的话你可以使用@Configuration注解且类型必须是WebMvcConfigurer，但是你不能使用@EnableWebMvc注解 五、实现WebMvcConfigurer接口测试 5.2、为什么实现WebMvcConfigurer接口就能达到这样的效果 在WebMvcAutoConfiguration类中有个WebMvcAutoConfigurationAdapter静态内部类，它也实现了WebMvcConfigurer接口，在这个类上有个 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) 在所有自动配置前会向容器中添加一个EnableWebMvcConfiguration组件。 5.3、我们进入EnableWebMvcConfiguration类，也是一个配置类，里面有很多组件，重要的是它父类 5.4、父类中有个setConfigurers(List configurers)方法，方法上加 @Autowired注解，其参数就会从容器中获取，而它参数类型又是WebMvcConfigurer类型的集合，我们前面自己写的配置就是实现了WebMvcConfigurer接口的类， 5.5、该类中有很多这样的方法，拿其中一个举例吧 this.configurers.addViewControllers(registry) –&gt;public void addViewControllers(ViewControllerRegistry registry) addViewControllers(ViewControllerRegistry registry)方法中会遍历WebMvcConfigurer类型的集合，并调用其中每个的addViewControllers()方法，同理可得：其它的自定义配置类也是实现WebMvcConfigurer接口，并实现其方法，这时候会被该类全部调用，所以我们自定义的配置类就与Spring Boot的配置一起生效了 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 如果你想全面接管SpringMVC，请在你的配置类上使用@EnableWebMvc。 意思是你不使用SpringBoot提供的自动配置，一切由自己来配置。这里就写Demo验证了，说下为什么加了这个注解，Spring Boot的自动配置就不会生效呢？ 六、@EnableWebMvc注解使自动配置失效6.1、使用了@EnableWebMvc注解就会向容器添加一个DelegatingWebMvcConfiguration组件。其父类是WebMvcConfigurationSupport 6.2、来到WebMvcAutoConfiguration类，该配置类上有个@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})，意思是容器中如果没有WebMvcConfigurationSupport组件，WebMvcAutoConfiguration中的配置才生效，所以使用了@EnableWebMvc注解，而使用该注解又会向容器中添加一个WebMvcConfigurationSupport组件，Spring Boot的自动配置就会失效。 结论：模式： 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置这其中就有我们上面说到的WebMvcConfigurer 3）、还有很多xxxCustomizer类，继承可以用来定制功能（后面的嵌入式的Servlet容器就是一个例子）","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习04_web静态资源映射规则(源码)","slug":"2019-03-28-SpringBoot学习04_web静态资源映射规则","date":"2019-03-28T12:06:00.000Z","updated":"2019-03-28T12:31:35.982Z","comments":true,"path":"2019/03/28/2019-03-28-SpringBoot学习04_web静态资源映射规则/","link":"","permalink":"http://yoursite.com/2019/03/28/2019-03-28-SpringBoot学习04_web静态资源映射规则/","excerpt":"","text":"在前面讲了Spring Boot的自动配置原理，所以静态资源映射的规则自然也能在自动配置类源码中找到，所有的跟web mvc有关的配置都可以在WebMvcAutoConfiguration类中找到 一、Spring Boot提供了一种webjar的方式引入前端的一些资源（如jquery，bootstrap等）WebMvcAutoConfiguration类中有个内部类WebMvcAutoConfigurationAdapter中有个addResourceHandlers方法（添加资源处理器） 从该方法中可以看出所有匹配/webjars/**这种路径规则的都去 classpath:/META-INF/resources/webjars/中找，下面进行测试。 1234567891011121314151617181920212223242526public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol(). toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; this.customizeResourceHandlerRegistration(registry. addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;). addResourceLocations (new String[]&#123;\"classpath:/META-INF/resources/webjars/\"&#125;). setCachePeriod(this.getSeconds(cachePeriod)). setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler (new String[]&#123;staticPathPattern&#125;). addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())). setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; &#125; 1.2、测试：这里引入jquery的webJars，并通过浏览器访问，在jquery的webjars中也有对应的路径 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 二、自定义静态资源存储路径那我们自己引入的静态资源在哪找呢，在上面提到的方法中有一段这个代码 123456String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler (new String[]&#123;staticPathPattern&#125;). addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())). setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); 2.1、this.mvcProperties.getStaticPathPattern()** –&gt;public String getStaticPathPattern() –&gt;this.staticPathPattern = “/\\“** 2.2、接着看该代码块的后半部分 this.resourceProperties.getStaticLocations() –&gt;public String[] getStaticLocations() –&gt;private String[] staticLocations –&gt;this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS –&gt;new String[]{“classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“}; ==上面的所展现代码的意思是访问项目的任意资源，如果没有对应的Controller映射到都 去下面四个路径找，优先级从上到下。 “classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ “/“：当前项目的根路径 测试classpath:/static/asserts/js/feather.min.js 三、Spring Boot 中的Welcome pageSpring Boot默认也提供了欢迎页面，就在前面提到的方法下面有个welcomePageHandlerMapping方法，上面有@Bean，说明也是容器中的一个组件 3.1、这其中有个getStaticLocations（）方法，点进去看自然也是上面提到过的四种静态资源的路径，这里意思就是会在上面那四种路径中找index.html，第二张截图的方法获得的结果是 /*，我们访问项目的默认路径localhost:8080自然也是满足/**的匹配的。 3.2、测试 四、SpringBoot中logo配置每个网站都有自己的logo，像Spring Boot官网的logo图标就是这样 4.1、Spring Boot也提供了这样的功能，在往下面翻会找到一个静态内部类FaviconConfiguration，看里面faviconHandlerMapping()这个方法 4.2、this.faviconRequestHandler() –&gt;public ResourceHttpRequestHandler faviconRequestHandler() –&gt;this.resolveFaviconLocations() –&gt;private List resolveFaviconLocations() –&gt;this.resourceProperties.getStaticLocations() 最终还是找到前面提到的那四种静态资源路径，而对应的url是**/favicon.ico，不管多少级的url，最后以favicon.ico结尾的都会去上面四种静态资源路径中找 测试访问 总结：1）、所有 /webjars/\\ ，都去 classpath:/META-INF/resources/webjars/ 找资源；==** webjars：以jar包的方式引入静态资源； 2）、”/\\“ 访问当前项目的任何资源，都去（静态资源的文件夹）找映射** “classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“ “/“：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc 3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/\\“映射；==** localhost:8080/ 找index页面 4）、所有的 \\/favicon.ico 都是在静态资源文件下找；**","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Linux进程管理","slug":"2019-03-27-Linux进程管理方法","date":"2019-03-27T14:37:00.000Z","updated":"2019-03-27T14:57:39.559Z","comments":true,"path":"2019/03/27/2019-03-27-Linux进程管理方法/","link":"","permalink":"http://yoursite.com/2019/03/27/2019-03-27-Linux进程管理方法/","excerpt":"","text":"进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 #类似LS之类的命令都会产生进程。 1、查看系统运行了哪些进程ps aux #查看系统中所有的进程，使用BSD操作系统格式 ps -le #查看系统中所有的进程，使用LINUX标准格式 2、动态查看电脑负载状态 top [选项] -d 秒数：指定top命令每隔几秒更新，默认是3秒。 在top命令的交互模式当中可以执行的命令： ?或h：查看帮助文档 P:以CPU使用率排序，默认就是此项 M:以内存使用率排序 N:以PID排序 q:退出top 第一行任务列队信息 第二行进程信息 第三行CPU行为信息 第四行物理内存信息 第五行交换分区（swap）信息 3、停止进程运命令kill [选项] -l ：查看可用的进程信号 eg: Kill -1 22354 #重启PID为22354的程序 Kill -9 22354 #强制杀死PID为22354的程序","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Linux压缩解压文件","slug":"2019-03-27-Linux压缩解压文件","date":"2019-03-27T13:37:00.000Z","updated":"2019-03-27T13:37:31.559Z","comments":true,"path":"2019/03/27/2019-03-27-Linux压缩解压文件/","link":"","permalink":"http://yoursite.com/2019/03/27/2019-03-27-Linux压缩解压文件/","excerpt":"","text":"一、LINUX中的常见的压缩格式zip、gz、bz2 二、gz压缩文件的压缩与解压1、压缩：gzip [文件路径]gz文件压缩文件特点: 1）、不保留源文件，压缩完成后删除源文件 2）、不能压缩文件夹 eg：压缩文件 a.txt 压缩完成后删除源文件 12345678[root@instance-y2jixxt2 study-linux]# touch a.txt[root@instance-y2jixxt2 study-linux]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 19:43 a.txt[root@instance-y2jixxt2 study-linux]# gzip a.txt[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 26 Mar 27 19:43 a.txt.gz eg：不能压缩文件夹 1234567[root@instance-y2jixxt2 study-linux]# mkdir aa[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 19:45 aa-rw-r--r-- 1 root root 26 Mar 27 19:43 a.txt.gz[root@instance-y2jixxt2 study-linux]# gzip aagzip: aa is a directory -- ignored 2、解压：gunzip [文件路径]eg：解压压缩包 a.txt.gz 1234567[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 26 Mar 27 19:40 a.txt.gz[root@instance-y2jixxt2 study-linux]# gunzip a.txt.gz[root@instance-y2jixxt2 study-linux]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 19:40 a.txt 三、zip压缩文件的压缩与解压1、压缩：zip [选项] [压缩后文件名] [文件或目录]2、解压：unzip [文件路径]-r:压缩文件夹，把所有子目录以及文件一起处理 eg：压缩 a.txt文件 （默认后缀名为zip） 1234567[root@instance-y2jixxt2 study-linux]# touch a.txt[root@instance-y2jixxt2 study-linux]# zip a a.txt adding: a.txt (stored 0%)[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 0 Mar 27 19:50 a.txt-rw-r--r-- 1 root root 160 Mar 27 19:50 a.zip eg：压缩 a 文件夹 如果不使用 -r文件夹中的文件是不会被压缩的 1234567891011121314151617181920212223242526272829[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 19:54 aa[root@instance-y2jixxt2 study-linux]# cd aa[root@instance-y2jixxt2 aa]# touch aa.txt[root@instance-y2jixxt2 aa]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:00 aa.txt[root@instance-y2jixxt2 aa]# cd ..[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:00 aa#压缩文件夹aa[root@instance-y2jixxt2 study-linux]# zip aa aa adding: aa/ (stored 0%)[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:00 aa-rw-r--r-- 1 root root 156 Mar 27 20:03 aa.zip#删除原来的aa文件夹[root@instance-y2jixxt2 study-linux]# rm -rf aa#解压刚刚压缩好的aa.zip[root@instance-y2jixxt2 study-linux]# unzip aa.zipArchive: aa.zip creating: aa/[root@instance-y2jixxt2 study-linux]# cd aa#进入解压后的文件夹发现并没有aa.txt[root@instance-y2jixxt2 aa]# lltotal 0 使用 -r 压缩文件夹，文件夹所有子目录以及文件也会一起处理 1234567891011121314151617181920212223242526[root@instance-y2jixxt2 study-linux]# cd aa[root@instance-y2jixxt2 aa]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:09 aa.txt[root@instance-y2jixxt2 aa]# cd ..[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:09 aa#加上选项 -r 压缩[root@instance-y2jixxt2 study-linux]# zip -r aa aa adding: aa/ (stored 0%) adding: aa/aa.txt (stored 0%)[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:09 aa-rw-r--r-- 1 root root 302 Mar 27 20:11 aa.zip[root@instance-y2jixxt2 study-linux]# rm -rf aa[root@instance-y2jixxt2 study-linux]# unzip aa.zipArchive: aa.zip creating: aa/ extracting: aa/aa.txt [root@instance-y2jixxt2 study-linux]# cd aa#解压后文件夹所有子目录以及文件也会解压出来[root@instance-y2jixxt2 aa]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:09 aa.txt 四、bzip2压缩文件的压缩与解压1、压缩：bzip2 [选项] [文件]特点：不能压缩文件夹 -k 压缩后不删除源文件 eg：压缩 aa.txt 默认删除源文件 12345678910111213141516[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa[root@instance-y2jixxt2 study-linux]# bzip2 aabzip2: Input file aa is a directory.[root@instance-y2jixxt2 study-linux]# touch aa.txt[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa-rw-r--r-- 1 root root 0 Mar 27 20:23 aa.txt#压缩aa.txt文件[root@instance-y2jixxt2 study-linux]# bzip2 aa.txt[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa-rw-r--r-- 1 root root 14 Mar 27 20:23 aa.txt.bz2 eg：使用选项 -k 不删除源文件 12345678[root@instance-y2jixxt2 study-linux]# touch bb.txt[root@instance-y2jixxt2 study-linux]# bzip2 -k bb.txt[root@instance-y2jixxt2 study-linux]# lltotal 12drwxr-xr-x 2 root root 4096 Mar 27 20:18 aa-rw-r--r-- 1 root root 14 Mar 27 20:23 aa.txt.bz2-rw-r--r-- 1 root root 0 Mar 27 20:26 bb.txt-rw-r--r-- 1 root root 14 Mar 27 20:26 bb.txt.bz2 2、解压：bunzip2 [文件路径]eg：解压 aa.txt.bz2 1234567[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 14 Mar 27 20:29 aa.txt.bz2[root@instance-y2jixxt2 study-linux]# bunzip2 aa.txt.bz2[root@instance-y2jixxt2 study-linux]# lltotal 0-rw-r--r-- 1 root root 0 Mar 27 20:29 aa.txt eg：使用选项 -k 不删除源文件 12345678[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 14 Mar 27 20:29 aa.txt.bz2[root@instance-y2jixxt2 study-linux]# bunzip2 -k aa.txt.bz2[root@instance-y2jixxt2 study-linux]# lltotal 4-rw-r--r-- 1 root root 0 Mar 27 20:29 aa.txt-rw-r--r-- 1 root root 14 Mar 27 20:29 aa.txt.bz2 五、tar打包并且压缩文件（常用）1、压缩文件：tar [选项] [压缩后文件名] [需要压缩的目录或文件路径] -c 打包 -v 显示详细信息 -f 制定文件名 -z 打包使用gzip压缩（.gz） -j 打包使用bzip2压缩（.bz2） -P 来源文件绝对路径 eg：以绝对路径压缩 aa 文件夹为 aa.gz tar -zcvf aa.gz -P /home/work/study-linux/aa （bzip2压缩换成 -j 选项） 123456789[root@instance-y2jixxt2 study-linux]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa[root@instance-y2jixxt2 study-linux]# tar -zcvf aa.gz -P /home/work/study-linux/aa/home/work/study-linux/aa/[root@instance-y2jixxt2 study-linux]# lltotal 8drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa-rw-r--r-- 1 root root 132 Mar 27 20:49 aa.gz 2、解压文件：tar [选项] [解压文件] -C [解压到的目录] -x 解包 -v 显示详细信息 -f 制定文件名 -z 使用gzip解压缩（.gz） -j 使用bzip2解压缩（.bz2） eg：解压 aa.gz 压缩包到 target 文件夹 tar -zxvf aa.gz -C target （bzip2解压换成 -j 选项） 12345678910111213141516[root@instance-y2jixxt2 study-linux]# lltotal 12drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa-rw-r--r-- 1 root root 105 Mar 27 21:26 aa.gzdrwxr-xr-x 2 root root 4096 Mar 27 21:25 target[root@instance-y2jixxt2 study-linux]# tar -zxvf aa.gz -C targetaa/[root@instance-y2jixxt2 study-linux]# lltotal 12drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa-rw-r--r-- 1 root root 105 Mar 27 21:26 aa.gzdrwxr-xr-x 3 root root 4096 Mar 27 21:27 target[root@instance-y2jixxt2 study-linux]# cd target[root@instance-y2jixxt2 target]# lltotal 4drwxr-xr-x 2 root root 4096 Mar 27 20:47 aa","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"Linux权限管理","slug":"2019-03-26-Linux权限管理","date":"2019-03-26T10:53:00.000Z","updated":"2019-03-27T15:24:32.815Z","comments":true,"path":"2019/03/26/2019-03-26-Linux权限管理/","link":"","permalink":"http://yoursite.com/2019/03/26/2019-03-26-Linux权限管理/","excerpt":"","text":"一、文件属性解释使用ll（ls -l的简写）查看文件的属性 1、文件的所有者：默认创建该文件的用户 2、文件的所有组：默认创建该文件的用户所在的组 1234[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rw-rw-r--. 1 root root 0 Mar 19 10:54 a.txt 第一列：- 为文件，d为文件夹 第二列：所有者权限，r 可读，w 可写，x 可执行 第三列：所有组权限 第四列：其他权限，其他用户的权限 第五列：该文件/目录的所有者 第六列：该文件/目录的所有组 第七列：该文件/目录的大小（不显示单位就是byte） 第八列：该文件/目录创建时间 第九列：该文件/目录名称 二、修改文件的权限u：user代表所有者，g：group代表所有组，o：other代表其他权限，a：all代表所有权限 1、修改文件权限的方式1以上述文件为例把 a.txt 文件的所有者权限加一个可执行，所有组权限加一个可执行，其他权限加一个可写使用 chmod u+x,g+x,o+w a.txt 命令修改 12345[root@localhost study-linux]# chmod u+x,g+x,o+w a.txt[root@localhost study-linux]# lltotal 4drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxrwxrw-. 1 root root 1 Mar 26 19:54 a.txt 创建b.txt，通过chmod a+x b.txt来给所有权限增加可执行 1234567891011[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rw-r--r--. 1 root root 0 Mar 26 20:14 b.txt[root@localhost study-linux]# chmod a+x b.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:14 b.txt 2、修改文件权限的方式2创建文件 c.txt ，通过 chmod u=rwx,g=rw,o=- c.txt 命令将所有者权限改为rwx，所有组权限改为rw，将其他权限设置位不可读不可写不可执行。 1234567891011121314[root@localhost study-linux]# touch c.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-rw-r--r--. 1 root root 0 Mar 26 20:17 c.txt[root@localhost study-linux]# chmod u=rwx,g=rw,o=- c.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-rwxrw----. 1 root root 0 Mar 26 20:17 c.txt 也可以通过 chmod a=r c.txt 将 c.txt 的所有权限改为r（可读） 1234567[root@localhost study-linux]# chmod a=r c.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-r--r--r--. 1 root root 0 Mar 26 20:17 c.txt 3、修改文件权限的方式3r w x 对应着数字 4 2 1 创建 d.txt 文件，通过 chmod 711 d.txt 命令将所有者权限修改为 rwx（4+2+1），所有组修改为 r（1），其他权限修改为 r （1） 12345678910111213141516[root@localhost study-linux]# touch d.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-r--r--r--. 1 root root 0 Mar 26 20:17 c.txt-rw-r--r--. 1 root root 0 Mar 26 20:23 d.txt[root@localhost study-linux]# chmod 711 d.txt[root@localhost study-linux]# lltotal 0drwxr-xr-x. 2 root root 6 Mar 26 19:51 aa-rwxr-xrw-. 1 root root 0 Mar 26 20:13 a.txt-rwxr-xr-x. 1 root root 0 Mar 26 20:17 b.txt-r--r--r--. 1 root root 0 Mar 26 20:17 c.txt-rwx--x--x. 1 root root 0 Mar 26 20:23 d.txt","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"Yang"},{"title":"编码习惯---Controller规范（转载）","slug":"2019-03-24-编码习惯---Controller规范","date":"2019-03-24T14:57:00.000Z","updated":"2019-03-24T15:49:19.894Z","comments":true,"path":"2019/03/24/2019-03-24-编码习惯---Controller规范/","link":"","permalink":"http://yoursite.com/2019/03/24/2019-03-24-编码习惯---Controller规范/","excerpt":"","text":"转载公众号:Java团长（以后方便查看） 前文回顾： 1、 《吐槽我见过的最烂的Java代码》 2、 《我的编码习惯 —— 接口定义》 第一篇文章中，我贴了2段代码，第1段是原生态的，第2段是我指定了接口定义规范，使用AOP技术之后最终交付的代码，从15行到1行，自己感受一下。 今天来说说大家关注的AOP如何实现。 先说说Controller规范，主要的内容是就是接口定义里面的内容，你只要遵循里面的规范，controller就问题不大，除了这些，还有另外的几点： 1、所有函数返回统一的ResultBean/PageResultBean格式 原因见我的接口定义这个贴。没有统一格式，AOP无法玩。 2、ResultBean/PageResultBean是controller专用的，不允许往后传！ 3、 Controller做参数格式的转换，不允许把json，map这类对象传到services去，也不允许services返回json、map。 一般情况下！写过代码都知道，map，json这种格式灵活，但是可读性差，如果放业务数据，每次阅读起来都比较困难。定义一个bean看着工作量多了，但代码清晰多了。 4、参数中一般情况不允许出现Request，Response这些对象 主要是可读性问题，一般情况下。 5、 不需要打印日志 日志在AOP里面会打印，而且我的建议是大部分日志在Services这层打印。 规范里面大部分是 不要做的项多，要做的比较少，落地比较容易。 ResultBean定义带泛型，使用了lombok。 AOP代码，主要就是打印日志和捕获异常，异常要区分已知异常和未知异常，其中未知的异常是我们重点关注的，可以做一些邮件通知啥的，已知异常可以再细分一下，可以不同的异常返回不同的返回码： 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 处理和包装异常*/public class ControllerAOP &#123; private static final Logger logger = LoggerFactory.getLogger(ControllerAOP.class); public Object handlerControllerMethod(ProceedingJoinPoint pjp) &#123; long startTime = System.currentTimeMillis(); ResultBean&lt;?&gt; result; try &#123; result = (ResultBean&lt;?&gt;) pjp.proceed(); logger.info(pjp.getSignature() + \"use time:\" + (System.currentTimeMillis() - startTime)); &#125; catch (Throwable e) &#123; result = handlerException(pjp, e); &#125; return result; &#125; private ResultBean&lt;?&gt; handlerException(ProceedingJoinPoint pjp, Throwable e) &#123; ResultBean&lt;?&gt; result = new ResultBean(); // 已知异常 if (e instanceof CheckException) &#123; result.setMsg(e.getLocalizedMessage()); result.setCode(ResultBean.FAIL); &#125; else if (e instanceof UnloginException) &#123; result.setMsg(\"Unlogin\"); result.setCode(ResultBean.NO_LOGIN); &#125; else &#123; logger.error(pjp.getSignature() + \" error \", e); //TODO 未知的异常，应该格外注意，可以发送邮件通知等 result.setMsg(e.toString()); result.setCode(ResultBean.FAIL); &#125; return result; &#125;&#125; AOP配置：(关于用java代码还是xml配置，这里我倾向于xml配置，因为这个会不定期改动) 12345678910&lt;!-- aop --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;beans:bean id=\"controllerAop\" class=\"xxx.common.aop.ControllerAOP\" /&gt; &lt;aop:config&gt; &lt;aop:aspect id=\"myAop\" ref=\"controllerAop\"&gt; &lt;aop:pointcut id=\"target\" expression=\"execution(public xxx.common.beans.ResultBean *(..))\" /&gt; &lt;aop:around method=\"handlerControllerMethod\" pointcut-ref=\"target\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 现在知道为什么要返回统一的一个ResultBean了： 为了统一格式 为了应用AOP 为了包装异常信息 分页的PageResultBean大同小异，大家自己依葫芦画瓢自己完成就好了。 贴一个简单的controller（左边的箭头表示AOP拦截了）。请对比吐槽我见过的最烂的Java代码里面原来的代码查看，没有对比就没有伤害。 最后说一句，先有统一的接口定义规范，然后有AOP实现。先有思想再有技术。技术不是关键，AOP技术也很简单，这个帖子的关键点不是技术，而是习惯和思想，不要捡了芝麻丢了西瓜。网络上讲技术的贴多，讲习惯、风格的少，这些都是我工作多年的行之有效的经验之谈，望有缘人珍惜。","categories":[],"tags":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"http://yoursite.com/tags/代码的艺术/"}],"author":"Yang"},{"title":"去掉烦人的if-else嵌套（转载）","slug":"2019-03-24-去掉烦人的if-else嵌套","date":"2019-03-24T13:40:00.000Z","updated":"2019-03-24T13:46:13.321Z","comments":true,"path":"2019/03/24/2019-03-24-去掉烦人的if-else嵌套/","link":"","permalink":"http://yoursite.com/2019/03/24/2019-03-24-去掉烦人的if-else嵌套/","excerpt":"","text":"转载公众号:Java团长（以后方便查看） 写在前面不知大家有没遇到过像“横放着的金字塔”一样的if else嵌套： 12345678910111213if (true) &#123; if (true) &#123; if (true) &#123; if (true) &#123; if (true) &#123; if (true) &#123; &#125; &#125; &#125; &#125; &#125;&#125; 我并没夸大其词，我是真的遇到过了！嵌套6、7层，一个函数几百行，简！直！看！死！人！ if else作为每种编程语言都不可或缺的条件语句，我们在编程时会大量的用到。但if else一般不建议嵌套超过三层，如果一段代码存在过多的if else嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。所以，我们程序员都应该尽量避免过多的if else嵌套。下面将会谈谈我在工作中如何减少if else嵌套的。 正文在谈我的方法之前，不妨先用个例子来说明if else嵌套过多的弊端。 想象下一个简单分享的业务需求：支持分享链接、图片、文本和图文，分享结果回调给用户（为了不跑题，这里简略了业务，实际复杂得多）。当接手到这么一个业务时，是不是觉得很简单，稍动下脑就可以动手了： 先定义分享的类型、分享Bean和分享回调类： 1234567891011121314151617181920private static final int TYPE_LINK = 0;private static final int TYPE_IMAGE = 1;private static final int TYPE_TEXT = 2;private static final int TYPE_IMAGE_TEXT = 3;public class ShareItem &#123; int type; String title; String content; String imagePath; String link;&#125;public interface ShareListener &#123; int STATE_SUCC = 0; int STATE_FAIL = 1; void onCallback(int state, String msg);&#125; 好了，然后在定义个分享接口，对每种类型分别进行分享就ok了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void share (ShareItem item, ShareListener listener) &#123; if (item != null) &#123; if (item.type == TYPE_LINK) &#123; // 分享链接 if (!TextUtils.isEmpty(item.link) &amp;&amp; !TextUtils.isEmpty(item.title)) &#123; doShareLink(item.link, item.title, item.content, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else if (item.type == TYPE_IMAGE) &#123; // 分享图片 if (!TextUtils.isEmpty(item.imagePath)) &#123; doShareImage(item.imagePath, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else if (item.type == TYPE_TEXT) &#123; // 分享文本 if (!TextUtils.isEmpty(item.content)) &#123; doShareText(item.content, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else if (item.type == TYPE_IMAGE_TEXT) &#123; // 分享图文 if (!TextUtils.isEmpty(item.imagePath) &amp;&amp; !TextUtils.isEmpty(item.content)) &#123; doShareImageAndText(item.imagePath, item.content, listener); &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"不支持的分享类型\"); &#125; &#125; &#125; else &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"ShareItem 不能为 null\"); &#125; &#125;&#125; 到此，简单的分享模型就做出来了。有没问题？老实说，如果没什么追求的话，还真没什么问题，至少思路是清晰的。但一周后呢？一个月后呢？或者一年后呢？share方法的分支有15条，这意味着你每次回看代码得让自己的大脑变成微型的处理器，考虑15种情况。如果出现bug，你又得考虑15种情况，并15种情况都要测试下。再如果现在需要加多分享小视频功能，你又得添加多3个分支，还要改代码，一点都不“开放-闭合”。再再如果后面项目交接给他人跟进，他人又要把自己大脑变成处理器来想每个分支的作用，我敢肯定有百分之八十的人都会吐槽代码。 我们程序员的脑力不应该花费在无止境的分支语句里的，应该专注于业务本身。所以我们很有必要避免写出多分支嵌套的语句。好的，我们来分析下上面的代码多分支的原因： 空值判断 业务判断 状态判断 几乎所有的业务都离不开这几个判断，从而导致if else嵌套过多。那是不是没办法解决了？答案肯定不是的。 上面的代码我是用java写的，对于java程序员来说，空值判断简直使人很沮丧，让人身心疲惫。上面的代码每次回调都要判断一次listener是否为空，又要判断用户传入的ShareItem是否为空，还要判断ShareItem里面的字段是否为空…… 对于这种情况，我采用的方法很简单：接口分层。 减少 if else 方法一：接口分层所谓接口分层指的是：把接口分为外部和内部接口，所有空值判断放在外部接口完成，只处理一次；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。 来，看代码更加直观： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void share(ShareItem item, ShareListener listener) &#123; if (item == null) &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"ShareItem 不能为 null\"); &#125; return; &#125; if (listener == null) &#123; listener = new ShareListener() &#123; @Override public void onCallback(int state, String msg) &#123; Log.i(\"DEBUG\", \"ShareListener is null\"); &#125; &#125;; &#125; shareImpl(item, listener);&#125;private void shareImpl (ShareItem item, ShareListener listener) &#123; if (item.type == TYPE_LINK) &#123; // 分享链接 if (!TextUtils.isEmpty(item.link) &amp;&amp; !TextUtils.isEmpty(item.title)) &#123; doShareLink(item.link, item.title, item.content, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else if (item.type == TYPE_IMAGE) &#123; // 分享图片 if (!TextUtils.isEmpty(item.imagePath)) &#123; doShareImage(item.imagePath, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else if (item.type == TYPE_TEXT) &#123; // 分享文本 if (!TextUtils.isEmpty(item.content)) &#123; doShareText(item.content, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else if (item.type == TYPE_IMAGE_TEXT) &#123; // 分享图文 if (!TextUtils.isEmpty(item.imagePath) &amp;&amp; !TextUtils.isEmpty(item.content)) &#123; doShareImageAndText(item.imagePath, item.content, listener); &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"分享信息不完整\"); &#125; &#125; else &#123; listener.onCallback(ShareListener.STATE_FAIL, \"不支持的分享类型\"); &#125;&#125; 可以看到，上面的代码分为外部接口share和内部接口shareImpl，ShareItem和ShareListener的判断都放在share里完成，那么shareImpl就减少了if else的嵌套了，相当于把if else分摊了。这样一来，代码的可读性好很多，嵌套也不超过3层了。 但可以看到，shareImpl里还是包含分享类型的判断，也即业务判断，我们都清楚产品经理的脑洞有多大了，分享的类型随时会改变或添加。嗯说到这里相信大家都想到用多态了。多态不但能应付业务改变的情况，也可以用来减少if else的嵌套。 减少 if else 方法二：多态利用多态，每种业务单独处理，在接口不再做任何业务判断。把ShareItem抽象出来，作为基础类，然后针对每种业务各自实现其子类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class ShareItem &#123; int type; public ShareItem(int type) &#123; this.type = type; &#125; public abstract void doShare(ShareListener listener);&#125;public class Link extends ShareItem &#123; String title; String content; String link; public Link(String link, String title, String content) &#123; super(TYPE_LINK); this.link = !TextUtils.isEmpty(link) ? link : \"default\"; this.title = !TextUtils.isEmpty(title) ? title : \"default\"; this.content = !TextUtils.isEmpty(content) ? content : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125;public class Image extends ShareItem &#123; String imagePath; public Image(String imagePath) &#123; super(TYPE_IMAGE); this.imagePath = !TextUtils.isEmpty(imagePath) ? imagePath : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125;public class Text extends ShareItem &#123; String content; public Text(String content) &#123; super(TYPE_TEXT); this.content = !TextUtils.isEmpty(content) ? content : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125;public class ImageText extends ShareItem &#123; String content; String imagePath; public ImageText(String imagePath, String content) &#123; super(TYPE_IMAGE_TEXT); this.imagePath = !TextUtils.isEmpty(imagePath) ? imagePath : \"default\"; this.content = !TextUtils.isEmpty(content) ? content : \"default\"; &#125; @Override public void doShare(ShareListener listener) &#123; // do share &#125;&#125; （注意：上面每个子类的构造方法还对每个字段做了空值处理，为空的话，赋值default，这样如果用户传了空值，在调试就会发现问题。） 实现了多态后，分享接口的就简洁多了： 1234567891011121314151617181920212223public void share(ShareItem item, ShareListener listener) &#123; if (item == null) &#123; if (listener != null) &#123; listener.onCallback(ShareListener.STATE_FAIL, \"ShareItem 不能为 null\"); &#125; return; &#125; if (listener == null) &#123; listener = new ShareListener() &#123; @Override public void onCallback(int state, String msg) &#123; Log.i(\"DEBUG\", \"ShareListener is null\"); &#125; &#125;; &#125; shareImpl(item, listener);&#125;private void shareImpl (ShareItem item, ShareListener listener) &#123; item.doShare(listener);&#125; 嘻嘻，怎样，内部接口一个if else都没了，是不是很酷~ 如果这个分享功能是自己App里面的功能，不是第三方SDK，到这里已经没问题了。但如果是第三方分享SDK的功能的话，这样暴露给用户的类增加了很多（各ShareItem的子类，相当于把if else抛给用户了），用户的接入成本提高，违背了“迪米特原则”了。 处理这种情况也很简单，再次封装一层即可。把ShareItem的子类的访问权限降低，在暴露给用户的主类里定义几个方法，在内部帮助用户创建具体的分享类型，这样用户就无需知道具体的类了： 123456789101112131415public ShareItem createLinkShareItem(String link, String title, String content) &#123; return new Link(link, title, content);&#125;public ShareItem createImageShareItem(String ImagePath) &#123; return new Image(ImagePath);&#125;public ShareItem createTextShareItem(String content) &#123; return new Text(content);&#125;public ShareItem createImageTextShareItem(String ImagePath, String content) &#123; return new ImageText(ImagePath, content);&#125; 或者有人会说，这样用户也需额外了解多几个方法。我个人觉得让用户了解多几个方法好过了解多几个类，而已方法名一看就能知道意图，成本还是挺小，是可以接受的。 其实这种情况，更多人想到的是使用工厂模式。嗯，工厂模式能解决这个问题（其实也需要用户额外了解多几个type类型），但工厂模式难免又引入分支，我们可以用Map消除分支。 减少 if else 方法三：使用Map替代分支语句把所有分享类型预先缓存在Map里，那么就可以直接get获取具体类型，消除分支： 1234567891011121314151617private Map&lt;Integer, Class&lt;? extends ShareItem&gt;&gt; map = new HashMap&lt;&gt;();private void init() &#123; map.put(TYPE_LINK, Link.class); map.put(TYPE_IMAGE, Image.class); map.put(TYPE_TEXT, Text.class); map.put(TYPE_IMAGE_TEXT, ImageText.class);&#125;public ShareItem createShareItem(int type) &#123; try &#123; Class&lt;? extends ShareItem&gt; shareItemClass = map.get(type); return shareItemClass.newInstance(); &#125; catch (Exception e) &#123; return new DefaultShareItem(); // 返回默认实现，不要返回null &#125; &#125; 这种方式跟上面分为几个方法的方式各有利弊，看大家取舍了~ 写在最后讲到这里大家有没收获呢？总结下减少if else的方法： 把接口分为外部和内部接口，所有空值判断放在外部接口完成；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。 利用多态，把业务判断消除，各子类分别关注自己的实现，并实现子类的创建方法，避免用户了解过多的类。 把分支状态信息预先缓存在Map里，直接get获取具体值，消除分支。 好了，到此就介绍完了，希望大家以后写代码能注意，有则避之，无则加勉。希望大家写的代码越来越简洁~","categories":[],"tags":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"http://yoursite.com/tags/代码的艺术/"}],"author":"Yang"},{"title":"Spring Boot学习03_日志使用原理","slug":"2019-03-21-SpringBoot学习03_日志使用原理","date":"2019-03-21T15:59:00.000Z","updated":"2019-04-04T15:07:02.164Z","comments":true,"path":"2019/03/21/2019-03-21-SpringBoot学习03_日志使用原理/","link":"","permalink":"http://yoursite.com/2019/03/21/2019-03-21-SpringBoot学习03_日志使用原理/","excerpt":"","text":"一、Spring Boot的默认日志市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 如果仅仅只有一个日志框架的话，中途要换日志框架，我们就得修改代码，维护修改非常麻烦，所以就像JDBC—数据库驱动，使用一个统一接口层，再对其接口进行实现，这样的话我们用的时候只需要使用接口层中的API,要用哪种的日志框架，直接换对应的实现jar就可以了。 日志门面（日志接口层） JCL（Jakarta Commons Logging） ：2014年就没更新了，舍弃。 jboss-logging ：只有一些特定的框架在用，一般用不着，舍弃。 SLF4j（Simple Logging Facade for Java）：选用SLF4j 日志实现 Log4j ：有性能问题，舍弃。 Logback：与log4j，slf4j出自同一人之手，为了解决Log4j的问题，重新写了一个框架可以使 用这个 JUL（java.util.logging） ：Java防止日志市场全部被Log4j抢占，勉强出个这个抵抗下，舍弃 Log4j2：与Log4j没有任何关系，只是借它之名，很好的一个日志框架，但是很多框架没有适 配起来，舍弃。 所以最后我们选用的组合是SLF4j + Logback。Spring Boot使用的也是该组合 SLF4j的使用：这里引用官网的一张图 最下面第一个就是抽象层；第二个就是日志实现，第三个是适配层，第四个还是实现。 因为log4j与JUL出现的时候太早了，那时候还没有SLF4j，所以要写一个适配层的jar包，上面实现SLF4j，使用下面jar包的API，起到承上启下的作用。 二、遗留的问题在我们使用框架开发的时候，它们使用的框架都是不同的，SLF4j也给出了对应的解决方案 我们就拿第一个来解释： 我们的项目接口层用的是SLF4J，想让项目中所有的日志输出都使用logback，但是别的框架使用的日志框架有commons logging，log4j，java util logging，如果把它们删了的话，框架运行就会报错（比如Spring框架使用的日志框架就是commons logging），SLF4J使用了与之对应的狸猫换太子包，拿第一个来说jcl-over-slf4j.jar来说，这个jar包内部中的包名和类名与commons logging众的包名类名都是一样的，但是其实现却是使用SLF4J的API，这样的话，我们到时候使用就可以把commons logging.jar给排除，然后引入jcl-over-slf4j.jar，就可以实现所有的日志输出就是logback 总结 如何让系统中所有的日志都统一到slf4j； 1、将系统中其他日志框架先排除出去； 2、用中间包来替换原有的日志框架； 3、我们导入slf4j其他的实现； 三、Spring Boot中的日志1、Spring Boot使用它来做日志功能 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 底层依赖关系(Spring boot 2.1.2使用了log4j-to-slf4j替换了之前的log4j-over-slf4j) Spring Boot底层也是使用SLF4J + logback做日志 使用中间包（狸猫换太子包）把其他的日志换成了SLF4J 2、日志使用 2.1、说明Spring Boot的默认日志级别是info 2.2、可以通过全部配置文件修改日志级别，输入的格式，默认没有日志文件输出，也可以 在全局配置文件中指定输出文件目录或者路径 下面测试了日志文件的输出位置，控制台打印日志的格式，文件中的日志格式，日 志级别 2.3、默认配置在spring-boot-2.1.2.RELEASE.jar这个包下 在这里指定了默认的日志文件在哪和日志级别的确是info 2.4、在classpath路径加入logback.xml，SpringBoot就不使用它的默认配置了，这样命 命名会跳过Spring Boot的检测，Spring Boot推荐logback-spring.xml命名方式， 这样可以在里面加标签，这 样就可以根据不同的环境来切换不同的配置了。 此时不是dev的环境所以是下面的格式 在命令行启动的时候指定环境dev，就是上面这种格式了","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习02_自动配置原理（精髓）","slug":"2019-03-19-SpringBoot学习02_自动配置原理","date":"2019-03-19T02:42:00.000Z","updated":"2019-04-04T14:52:27.102Z","comments":true,"path":"2019/03/19/2019-03-19-SpringBoot学习02_自动配置原理/","link":"","permalink":"http://yoursite.com/2019/03/19/2019-03-19-SpringBoot学习02_自动配置原理/","excerpt":"","text":"Spring Boot 配置文件中有很多可以写的配置，能写的有哪些呢？ 虽然Spring Boot的官网也有文档，自己引用依赖配置文件中也有提醒，但是这都不是正确的学习方式，如果Spring boot 更新了，难道又去看一遍文档吗？所以我们要学习其中的原理以不变应万变。 在前面我有篇文章写了Spring Boot是怎么启动的，里面说在spring-boot-autoconfigure-2.1.2.RELEASE.jar包下能找到集合中的数据，那么Spring Boot是怎么找到的呢？ 1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==接着上次的点过去 @SpringBootApplication–&gt;@EnableAutoConfiguration–&gt;@Import –&gt;AutoConfigurationImportSelector –&gt;selectImports(AnnotationMetadata annotationMetadata) –&gt;getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) –&gt;getCandidateConfigurations(annotationMetadata, attributes); –&gt;SpringFactoriesLoader.loadFactoryNames .(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); 2）、@EnableAutoConfiguration 作用：关键就是这个loadSpringFactories(@Nullable ClassLoader classLoader)方法 1.该方法会加载所有包下的META-INF/spring.factories文件2.把扫描到的这些文件的内容包装成properties对象3.从properties中获取到所有的key和value包装成Map返回 4、这里再根据类名当作key从上面包装好的Map里面获取值 5、而这个类名就是EnableAutoConfiguration.class，最终获取到这个key对应的value，封装成List返回 最终在查找包下面就只有spring-boot-autoconfigure-2.1.2.RELEASE.jar/META-INF/spring.factories这个文件下有EnableAutoConfiguration XXXAutoConfiguration每一个这样的类都是容器中的一个组件，都加入到容器中，用它们来做自动配置 3）、每一个自动配置类进行自动配置功能；4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration //表示这是一个配置类，与配置文件一样//启动指定类的ConfigurationProperties功能；//将配置文件中对应的值和HttpEncodingProperties绑定起来；//并把HttpEncodingProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，//整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //它是HttpProperties中的一个静态内部类 private final Encoding properties; //只有一个有参构造，参数的值会自动从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125;//给容器中添加一个组件 该方法就是在properties中拿到CharacterEncodingFilter的值然后添加给容器 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties. shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties. shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类，配置文件中spring.http下的属性与该类属性对应 精髓：​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件(被@Bean标注的方法)；（只 要我们要用的组件有，我们就不需要再来配置了，只需要写对应的Properties类 的属性） ​ 4）、给容器中自动配置类添加组件的时候，会从Properties类中获取某些属性。我们就 可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可 以很方便的知道哪些自动配置类生效； 自动配置启用的 没有启动，没有匹配成功的自动配置类","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习02_配置(踩坑)","slug":"2019-03-16-SpringBoot学习02_配置","date":"2019-03-16T09:29:00.000Z","updated":"2019-04-04T14:45:40.356Z","comments":true,"path":"2019/03/16/2019-03-16-SpringBoot学习02_配置/","link":"","permalink":"http://yoursite.com/2019/03/16/2019-03-16-SpringBoot学习02_配置/","excerpt":"","text":"注意：本文例子必须使用IDEA中的Project，而不是Module。 1、配置文件Spring Boot 使用全局配置文件，文件名是固定的： application.properties、application.yml 配置文件的作用：修改Spring Boot的默认配置；有些配置是Spring Boot底层给我们配置好 比如修改项目的端口号 YAML（YAML Aisn’t Markup Language） YAML 是一个标记语言 YAML不是一个标记语言 而不管它官方怎么解释，它仍然是一个标记语言。 之前使用的标记语言一般都是xxx.xml 比如表示server的port，这样大量的内容不是真正有用的数据而是标签 123&lt;server&gt; &lt;port&gt;8080&lt;/port&gt;&lt;/server&gt; YAML：以数据为中心，比json，xml更适合做配置文件 12server: port: 8080 2、YAML语法1、YAML基本语法使用缩进表示层级关系 缩进不允许使用Tab，只允许使用空格 缩进的空格数不重要，只要相同层级的元素左侧对齐即可 大小写敏感 2、YAML支持的三种数据结构YAML中表示字符串不需要使用双引号和单引号 双引号：如果使用了双引号括住了一个字符串，特殊字符不会被转义，而是会代表它 本身表示的意思。eg：”yang \\n nick” 结果：yang (换行) nick 单引号：如果使用单引号括住了一个字符串，特殊字符会被转义，特殊字符就没有任 何意义，仅仅就是个字符串。eg：’yang \\n nick’ 结果：yang \\n nick 2.1、字面量单个的不可再分的值：k:(空格)v 1name:(空格)Yang 2.2、对象(Map)键值对 123person: name:(空格)Yang age:(空格)19 行内写法： person:(空格){name:(空格)yang, age:(空格)19} 2.3、数组(Set,List) 以 - （横杆）代表该数组中一个元素 1234pets: -(空格)dog -(空格)cat -(空格)pig 行内写法： 1animals:(空格)[dog, cat, pig] YAML还支持嵌套使用：下面表示的就是person对象中有多少个宠物 1234567person: name:(空格)Yang age:(空格)19 pets: -(空格)dog -(空格)cat -(空格)pig 行内写法： 1person:(空格)&#123;name:(空格)Yang, age:(空格)19, pets:(空格)[dog, cat, pig]&#125; 3、配置文件值注入3.1、@ConfigurationProperties与@Value Demo第一种写法使用@ConfigurationProperties 1、写好一个Person对象和一个Dog对象 2、在配置文件中写好属性（yml/properties都行） 3、@ConfigurationProperties告诉SpringBoot本类中的所有属性与配置文件中的属性 进行绑定 使用该注解一定要使用@Component将该类放入容器中才能提供 @ConfigurationProperties注解的功能 prefix=”person” 配置文件中将哪个下面的属性一一映射 4、编写测试类测试成功 第二种写法使用@Value注解 该注解就相当于之前Spring配置文件中的value那个属性 3.2@ConfigurationProperties与@Value的区别1、功能 由上面的例子得到@ConfigurationProperties是批量注入属性的值 @Value是一个一个注入属性的值 2、是否支持松散语法 person.lastName 标准方式 person.last-name 大写用 - person.last_name 大写用 _ @Value不支持，报错。 @ConfigurationProperties支持 3、是否支持JSR303校验 @Value还是能获取到值不支持校验 @ConfigurationProperties报错了，说明支持JSR303校验 4、是否支持SpEl表达式 （#{写表达式}） @Value支持 @ConfigurationProperties不支持 5、是否支持复杂类型注入 @Value不支持 @ConfigurationProperties支持 结论 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 3.3、@PropertySource、@ImportResource与@Bean Demo1）、一般重要的配置都会写在全局配置文件中，不可能一个简单的POJO对象也要写在全 局配置文件中，所以这时候我们可以另外写个properties文件然后@PropertySouce 引入 2）、如果我们自己要写一些Spring的配置，就可以创建一个xml文件，然后写进去，再通 通过@ImportSource注解标注在一个配置类上就可以使其生效 编写一个HelloService类并把其配置到xml文件中，通过@ImportSource注解使其生效 编写测试方法测试 3）、Spring Boot推荐使用注解类的方式来添加组件。 这里我们使用@Configuration注解标注在类上，该类就是一个注解类。使用@Bean标注 在方法上该方法的返回值就是要添加到容器中的组件，beanName就是方法名 @Bean == 测试通过 4、配置文件占位符1、随机数 ​ ${random.value} ​ ${random.int} ​ ${random.long} ​ ${random.int(10)} ​ ${random.int[1024,65536]} 2、占位符可以用之前设置的值，如果没有设置可以使用 “ : “指定默认值（没有设置就以表达式为字符串作为值） 5、profile在开发的时候，我们一般开发时会用开发环境，上线时会用生产环境，这时候就要多 个配置文件进行切换，Spring Boot当然也提供了几种解决方案 1、多profile文件可以使用application-[profile].properties/yml命名的方式，然后在 application.properties/yml中使用spring.profiles.active指定用哪个配置文件 2、yml支持多文档块：一个yml文件中可以使用多个文档块来当作多个不同的配置两个文档用 ”—“ 区分 3、激活profile1、在配置文件中指定 spring.profiles.active=dev 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar – spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 3、虚拟机参数 ​ -Dspring.profiles.active=dev 这里我们新建了一个application-dev.properties文件，并在主配置文件中指定。 启动Spring Boot主程序发现使用的就是8088端口 6、配置文件加载位置./config(项目根路径下的config文件夹) ./(项目根路径下) ./resource/config(classpath下的config文件夹) ./resource(classpath下) 以上位置的配置文件优先级由高到低，高优先级会覆盖低优先级的重复属性，不一样的 属性会形成互补配置 （注意：这里一定要用IDEA中的Project，而不是Module!不知道什么原因，我多次测 试Module中项目根路径无效，Project有效） 官方文档说还可以使用打包的方式然后运行该jar包时添加命令 –spring.config.location指定磁盘上目录配置文件并与jar包互补配置，但我在测试时 并没有形成互补，只有指定的配置文件中的属性才有效。希望大神能够指出来哪里问题 7、外部加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低 优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 – server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置 文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置 文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源： https://docs.spring.io/spring-boot/docs/2.1.2.RELEASE/reference/htmlsingle/#boot-features-external-config","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"SpringBoot学习01_HelloWorld","slug":"2019-03-15-SpringBoot学习01_HelloWorld","date":"2019-03-15T02:58:00.000Z","updated":"2019-05-23T04:23:30.463Z","comments":true,"path":"2019/03/15/2019-03-15-SpringBoot学习01_HelloWorld/","link":"","permalink":"http://yoursite.com/2019/03/15/2019-03-15-SpringBoot学习01_HelloWorld/","excerpt":"","text":"Spring Boot 学习01_入门helloworld简化Spring应用开发的一个框架 整个Spring技术的一个大集合 J2EE开发的一站式解决方案 一、手动创建Spring Boot项目1、在IDEA新建一个maven工程 2、导入Spring Boot相关的依赖 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、编写一个主程序启动Spring Boot应用 123456789@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; //将Spring应用启动起来 SpringApplication.run(App.class, args); &#125;&#125; 4、在同包下编写一个Controller测试 123456789@Controllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; return &quot;Hello World!&quot;; &#125;&#125; 5、启动刚刚创建好的主程序通过浏览器测试访问 二、使用向导快速创建Spring Boot应用1、右键项目New-&gt;Module 2、选择Spring initializr 点击Next(注意：一定要使用jdk1.8) 3、依次填写完点击Next 4、选择自己所需要的组件点击Next(右上角可以选择Spring Boot的版本) 5、填写模块名称后点击finish完成 三、Spring Boot部署的简便 1、导入springboot打包的插件 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、运行maven的package命令，然后找到该jar包运行。 3、通过浏览器也是能访问到的 原因是因为在打包时有很多别的包与springboot项目打包到一起了，其中就包括嵌入式tomcat","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"},{"title":"Spring Boot学习01_springboot是怎么启动的","slug":"2019-03-15-SpringBoot学习01_springboot是怎么启动的","date":"2019-03-15T02:34:00.000Z","updated":"2019-05-23T04:23:02.346Z","comments":true,"path":"2019/03/15/2019-03-15-SpringBoot学习01_springboot是怎么启动的/","link":"","permalink":"http://yoursite.com/2019/03/15/2019-03-15-SpringBoot学习01_springboot是怎么启动的/","excerpt":"","text":"Spring Boot的启动就两个很难以理解的问题 一、为什么没有引入相关的jar包就可以直接用SpringMVC的功能了呢? 1、前面写那个helloworld的时候导入了一个父项目的坐标和一个依赖，我们先点进父项目的坐标看看。 2、 发现父项目中还有一个父项目再点进去 3、进去我们发现里面有一堆我们日常需要的依赖版本定义，比如activemq，aspectj等。 由此我们可以得出结论，引入的父项目坐标就是为我们引入的依赖做版本控制用的，所以在spring-boot-dependencies中定义好了的我们再引入不需要写版本了，没有的就需要自己定义版本。那依赖又是在哪里导入的呢？ 这时候我们进入官网找到对应的文档找到对应的描述，称其为starter(启动器)，SpringBoot将所有的功能场景抽取出来做成一个个的starter，在项目中引入starter相关场景的依赖也会被导入进来。要什么功能导入什么starter 点击spring-boot-starter-web，我们就能看到相应的依赖了。 二、之前使用Spring或者SpringMVC的时候都需要一堆配置，譬如HandlerMapping,HandlerAdapter等。那么这些配置是怎么生成的呢？ 点击@SpringBootApplication注解中看看，其他的都是元注解，主要就框住的那两个 1、点进@SpringBootConfiguration注解看发现该注解上有个@Configuration注解，@Configuration注解是Spring的注解，其意是被该注解标注了该类就是一个配置类， 配置类相当于配置文件 配置类也是容器中的一个组件：@Component 1.1、结论：@SpringBootConfiguration注解的作用：被标注的类就是一个配置类，就像xml配置文件，而现在是用java配置文件。并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 1.2、可以直接这样获取 2、开始说@EnableAutoConfiguration注解，我们点进去看又有两个重要的注解 @AutoConfigurationPackage，@Import 2.1、点进@AutoConfigurationPackage注解看发现有个@Import注解，该注解也是Spring中的底层注解。我们点进Registrar这个类，发现该类是个静态类，给registerBeanDefinitions方法打上断点，debug运行 2.1.1、 (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()得到的包名正是被@SpringBootApplication所标注类的包下。 2.1.2、结论：@AutoConfigurationPackage作用：将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； 可以自行测试在别的包下使用SpringMVC。 2.2、点进@Import注解上的AutoConfigurationImportSelector类 2.2.1、发现有个selectImports方法。该方法会调用当前对象getAutoConfigurationEntry()方法，点进去并打上断点，debug启动。 2.2.2、该方法最终得到一个List集合，该集合中的值就是配置类的全类名，将所有需要导入的组件以全类名的方式返回；(比如里面有aop，批处理等配置) 2.2.3、通过该集合实例化一个AutoConfigurationImportSelector.AutoConfigurationEntry对象并返回到selectImports方法。 2.2.4、selectImports拿到该集合并返回 所以有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； 在spring-boot-autoconfigure-2.1.2.RELEASE.jar包下能找到集合中的数据 以上就是Spring Boot的启动原理了。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"author":"Yang"}]}